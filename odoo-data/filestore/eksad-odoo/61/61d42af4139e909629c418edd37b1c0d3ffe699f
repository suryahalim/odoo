)]}'
{"version": 3, "sources": ["/web/static/src/views/graph/graph_arch_parser.js", "/web/static/src/views/graph/graph_controller.js", "/web/static/src/views/graph/graph_model.js", "/web/static/src/views/graph/graph_renderer.js", "/web/static/src/views/graph/graph_search_model.js", "/web/static/src/views/graph/graph_view.js", "/web/static/src/views/pivot/pivot_arch_parser.js", "/web/static/src/views/pivot/pivot_controller.js", "/web/static/src/views/pivot/pivot_header.js", "/web/static/src/views/pivot/pivot_model.js", "/web/static/src/views/pivot/pivot_renderer.js", "/web/static/src/views/pivot/pivot_search_model.js", "/web/static/src/views/pivot/pivot_view.js", "/mail/static/src/views/web/activity/activity_arch_parser.js", "/mail/static/src/views/web/activity/activity_cell.js", "/mail/static/src/views/web/activity/activity_compiler.js", "/mail/static/src/views/web/activity/activity_controller.js", "/mail/static/src/views/web/activity/activity_model.js", "/mail/static/src/views/web/activity/activity_record.js", "/mail/static/src/views/web/activity/activity_renderer.js", "/mail/static/src/views/web/activity/activity_view.js", "/crm/static/src/views/forecast_graph/forecast_graph_view.js", "/crm/static/src/views/forecast_pivot/forecast_pivot_view.js", "/analytic/static/src/views/graph/graph_view.js", "/analytic/static/src/views/pivot/pivot_renderer.js", "/analytic/static/src/views/pivot/pivot_view.js", "/project/static/src/views/project_task_graph/project_task_graph_model.js", "/project/static/src/views/project_task_graph/project_task_graph_view.js", "/project/static/src/views/project_task_pivot/project_pivot_model.js", "/project/static/src/views/project_task_pivot/project_pivot_view.js", "/project/static/src/views/burndown_chart/burndown_chart_model.js", "/project/static/src/views/burndown_chart/burndown_chart_search_model.js", "/project/static/src/views/burndown_chart/burndown_chart_view.js", "/hr/static/src/views/hr_graph_view.js", "/hr/static/src/views/hr_pivot_view.js", "/hr_skills/static/src/views/skills_graph.js", "/hr_timesheet/static/src/views/timesheet_graph/timesheet_graph_model.js", "/hr_timesheet/static/src/views/timesheet_graph/timesheet_graph_view.js", "/web_hierarchy/static/src/hierarchy_arch_parser.js", "/web_hierarchy/static/src/hierarchy_card.js", "/web_hierarchy/static/src/hierarchy_compiler.js", "/web_hierarchy/static/src/hierarchy_controller.js", "/web_hierarchy/static/src/hierarchy_model.js", "/web_hierarchy/static/src/hierarchy_node_draggable.js", "/web_hierarchy/static/src/hierarchy_renderer.js", "/web_hierarchy/static/src/hierarchy_view.js", "/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_card.js", "/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer.js", "/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_view.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/FA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3DA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzpBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC95BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtrDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1PA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5DA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3FA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACVA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACdA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACdA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9nCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACPA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["import { exprToBoolean } from \"@web/core/utils/strings\";\nimport { visitXML } from \"@web/core/utils/xml\";\nimport { GROUPABLE_TYPES } from \"@web/search/utils/misc\";\n\nconst MODES = [\"bar\", \"line\", \"pie\"];\nconst ORDERS = [\"ASC\", \"DESC\", \"asc\", \"desc\", null];\n\nexport class GraphArchParser {\n    parse(arch, fields = {}) {\n        const archInfo = { fields, fieldAttrs: {}, groupBy: [], measures: [] };\n        visitXML(arch, (node) => {\n            switch (node.tagName) {\n                case \"graph\": {\n                    if (node.hasAttribute(\"disable_linking\")) {\n                        archInfo.disableLinking = exprToBoolean(\n                            node.getAttribute(\"disable_linking\")\n                        );\n                    }\n                    if (node.hasAttribute(\"stacked\")) {\n                        archInfo.stacked = exprToBoolean(node.getAttribute(\"stacked\"));\n                    }\n                    if (node.hasAttribute(\"cumulated\")) {\n                        archInfo.cumulated = exprToBoolean(node.getAttribute(\"cumulated\"));\n                    }\n                    if (node.hasAttribute(\"cumulated_start\")) {\n                        archInfo.cumulatedStart = exprToBoolean(\n                            node.getAttribute(\"cumulated_start\")\n                        );\n                    }\n                    const mode = node.getAttribute(\"type\");\n                    if (mode && MODES.includes(mode)) {\n                        archInfo.mode = mode;\n                    }\n                    const order = node.getAttribute(\"order\");\n                    if (order && ORDERS.includes(order)) {\n                        archInfo.order = order.toUpperCase();\n                    }\n                    const title = node.getAttribute(\"string\");\n                    if (title) {\n                        archInfo.title = title;\n                    }\n                    break;\n                }\n                case \"field\": {\n                    const fieldName = node.getAttribute(\"name\"); // exists (rng validation)\n                    if (fieldName === \"id\") {\n                        break;\n                    }\n                    const string = node.getAttribute(\"string\");\n                    if (string) {\n                        if (!archInfo.fieldAttrs[fieldName]) {\n                            archInfo.fieldAttrs[fieldName] = {};\n                        }\n                        archInfo.fieldAttrs[fieldName].string = string;\n                    }\n                    const widget = node.getAttribute(\"widget\");\n                    if (widget) {\n                        if (!archInfo.fieldAttrs[fieldName]) {\n                            archInfo.fieldAttrs[fieldName] = {};\n                        }\n                        archInfo.fieldAttrs[fieldName].widget = widget;\n                    }\n                    if (\n                        node.getAttribute(\"invisible\") === \"True\" ||\n                        node.getAttribute(\"invisible\") === \"1\"\n                    ) {\n                        if (!archInfo.fieldAttrs[fieldName]) {\n                            archInfo.fieldAttrs[fieldName] = {};\n                        }\n                        archInfo.fieldAttrs[fieldName].isInvisible = true;\n                        break;\n                    }\n                    const isMeasure = node.getAttribute(\"type\") === \"measure\";\n                    if (isMeasure) {\n                        archInfo.measures.push(fieldName);\n                        // the last field with type=\"measure\" (if any) will be used as measure else __count\n                        archInfo.measure = fieldName;\n                    } else {\n                        const { type } = archInfo.fields[fieldName]; // exists (rng validation)\n                        if (GROUPABLE_TYPES.includes(type)) {\n                            let groupBy = fieldName;\n                            const interval = node.getAttribute(\"interval\");\n                            if (interval) {\n                                groupBy += `:${interval}`;\n                            }\n                            archInfo.groupBy.push(groupBy);\n                        }\n                    }\n                    break;\n                }\n            }\n        });\n        return archInfo;\n    }\n}\n", "import { Layout } from \"@web/search/layout\";\nimport { useModelWithSampleData } from \"@web/model/model\";\nimport { standardViewProps } from \"@web/views/standard_view_props\";\nimport { useSetupAction } from \"@web/search/action_hook\";\nimport { SearchBar } from \"@web/search/search_bar/search_bar\";\nimport { useSearchBarToggler } from \"@web/search/search_bar/search_bar_toggler\";\nimport { CogMenu } from \"@web/search/cog_menu/cog_menu\";\n\nimport { Component, useRef } from \"@odoo/owl\";\n\nexport class GraphController extends Component {\n    static template = \"web.GraphView\";\n    static components = { Layout, SearchBar, CogMenu };\n    static props = {\n        ...standardViewProps,\n        Model: Function,\n        modelParams: Object,\n        Renderer: Function,\n        buttonTemplate: String,\n    };\n\n    setup() {\n        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);\n\n        useSetupAction({\n            rootRef: useRef(\"root\"),\n            getLocalState: () => {\n                return { metaData: this.model.metaData };\n            },\n            getContext: () => this.getContext(),\n        });\n        this.searchBarToggler = useSearchBarToggler();\n    }\n\n    /**\n     * @returns {Object}\n     */\n    getContext() {\n        // expand context object? change keys?\n        const { measure, groupBy, mode } = this.model.metaData;\n        const context = {\n            graph_measure: measure,\n            graph_mode: mode,\n            graph_groupbys: groupBy.map((gb) => gb.spec),\n        };\n        if (mode !== \"pie\") {\n            context.graph_order = this.model.metaData.order;\n            context.graph_stacked = this.model.metaData.stacked;\n            if (mode === \"line\") {\n                context.graph_cumulated = this.model.metaData.cumulated;\n            }\n        }\n        return context;\n    }\n\n    loadAll() {\n        return this.model.forceLoadAll();\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport { sortBy, groupBy } from \"@web/core/utils/arrays\";\nimport { KeepLast, Race } from \"@web/core/utils/concurrency\";\nimport { rankInterval } from \"@web/search/utils/dates\";\nimport { getGroupBy } from \"@web/search/utils/group_by\";\nimport { GROUPABLE_TYPES } from \"@web/search/utils/misc\";\nimport { addPropertyFieldDefs, Model } from \"@web/model/model\";\nimport { computeReportMeasures, processMeasure } from \"@web/views/utils\";\nimport { Domain } from \"@web/core/domain\";\n\nexport const SEP = \" / \";\nconst DATA_LIMIT = 80;\n\nexport const SEQUENTIAL_TYPES = [\"date\", \"datetime\"];\n\n/**\n * @typedef {import(\"@web/search/search_model\").SearchParams} SearchParams\n */\n\nclass DateClasses {\n    // We view the param \"array\" as a matrix of values and undefined.\n    // An equivalence class is formed of defined values of a column.\n    // So nothing has to do with dates but we only use Dateclasses to manage\n    // identification of dates.\n    /**\n     * @param {(any[])[]} array\n     */\n    constructor(array) {\n        this.__referenceIndex = null;\n        this.__array = array;\n        for (let i = 0; i < this.__array.length; i++) {\n            const arr = this.__array[i];\n            if (arr.length && this.__referenceIndex === null) {\n                this.__referenceIndex = i;\n            }\n        }\n    }\n\n    /**\n     * @param {number} index\n     * @param {any} o\n     * @returns {string}\n     */\n    classLabel(index, o) {\n        return `${this.__array[index].indexOf(o)}`;\n    }\n\n    /**\n     * @param {string} classLabel\n     * @returns {any[]}\n     */\n    classMembers(classLabel) {\n        const classNumber = Number(classLabel);\n        const classMembers = new Set();\n        for (const arr of this.__array) {\n            if (arr[classNumber] !== undefined) {\n                classMembers.add(arr[classNumber]);\n            }\n        }\n        return [...classMembers];\n    }\n\n    /**\n     * @param {string} classLabel\n     * @param {number} [index]\n     * @returns {any}\n     */\n    representative(classLabel, index) {\n        const classNumber = Number(classLabel);\n        const i = index === undefined ? this.__referenceIndex : index;\n        if (i === null) {\n            return null;\n        }\n        return this.__array[i][classNumber];\n    }\n\n    /**\n     * @param {number} index\n     * @returns {number}\n     */\n    arrayLength(index) {\n        return this.__array[index].length;\n    }\n}\n\nexport class GraphModel extends Model {\n    /**\n     * @override\n     */\n    setup(params) {\n        // concurrency management\n        this.keepLast = new KeepLast();\n        this.race = new Race();\n        const _fetchDataPoints = this._fetchDataPoints.bind(this);\n        this._fetchDataPoints = (...args) => {\n            return this.race.add(_fetchDataPoints(...args));\n        };\n\n        this.initialGroupBy = null;\n\n        this.metaData = params;\n        this.data = null;\n        this.searchParams = null;\n        // This dataset will be added as a line plot on top of stacked bar chart.\n        this.lineOverlayDataset = null;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @param {SearchParams} searchParams\n     */\n    async load(searchParams) {\n        this.searchParams = searchParams;\n        if (!this.initialGroupBy) {\n            this.initialGroupBy = searchParams.context.graph_groupbys || this.metaData.groupBy; // = arch groupBy --> change that\n        }\n        const metaData = this._buildMetaData();\n        await addPropertyFieldDefs(\n            this.orm,\n            metaData.resModel,\n            searchParams.context,\n            metaData.fields,\n            metaData.groupBy.map((gb) => gb.fieldName)\n        );\n        await this._fetchDataPoints(metaData);\n    }\n\n    async forceLoadAll() {\n        const metaData = this._buildMetaData();\n        await this._fetchDataPoints(metaData, true);\n        this.notify();\n    }\n\n    /**\n     * @override\n     */\n    hasData() {\n        return this.dataPoints.length > 0;\n    }\n\n    /**\n     * Only supposed to be called to change one or several parameters among\n     * \"measure\", \"mode\", \"order\", \"stacked\" and \"cumulated\".\n     * @param {Object} params\n     */\n    async updateMetaData(params) {\n        if (\"measure\" in params) {\n            const metaData = this._buildMetaData(params);\n            await this._fetchDataPoints(metaData);\n            this.useSampleModel = false;\n        } else {\n            await this.race.getCurrentProm();\n            this.metaData = Object.assign({}, this.metaData, params);\n            this._prepareData();\n        }\n        this.notify();\n    }\n\n    //--------------------------------------------------------------------------\n    // Protected\n    //--------------------------------------------------------------------------\n\n    /**\n     * @protected\n     * @param {Object} [params={}]\n     * @returns {Object}\n     */\n    _buildMetaData(params) {\n        const { comparison, domain, context, groupBy } = this.searchParams;\n\n        const metaData = Object.assign({}, this.metaData, { context });\n        if (comparison) {\n            metaData.domains = comparison.domains;\n            metaData.comparisonField = comparison.fieldName;\n        } else {\n            metaData.domains = [{ arrayRepr: domain, description: null }];\n        }\n        metaData.measure = context.graph_measure || metaData.measure;\n        metaData.mode = context.graph_mode || metaData.mode;\n        metaData.groupBy = groupBy.length ? groupBy : this.initialGroupBy;\n        if (metaData.mode !== \"pie\") {\n            metaData.order = \"graph_order\" in context ? context.graph_order : metaData.order;\n            if (comparison) {\n                metaData.stacked = false;\n            } else if (\"graph_stacked\" in context) {\n                metaData.stacked = context.graph_stacked;\n            }\n            if (metaData.mode === \"line\") {\n                metaData.cumulated =\n                    \"graph_cumulated\" in context ? context.graph_cumulated : metaData.cumulated;\n            }\n        }\n\n        this._normalize(metaData);\n\n        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [\n            ...(metaData.viewMeasures || []),\n            metaData.measure,\n        ]);\n\n        return Object.assign(metaData, params);\n    }\n\n    /**\n     * Fetch the data points determined by the metaData. This function has\n     * several side effects. It can alter this.metaData and set this.dataPoints.\n     * @protected\n     * @param {Object} metaData\n     * @param {boolean} [forceUseAllDataPoints=false]\n     */\n    async _fetchDataPoints(metaData, forceUseAllDataPoints = false) {\n        this.dataPoints = await this.keepLast.add(this._loadDataPoints(metaData));\n        this.metaData = metaData;\n        this._prepareData(forceUseAllDataPoints);\n    }\n\n    /**\n     * Separates dataPoints coming from the read_group(s) into different\n     * datasets. This function returns the parameters data and labels used\n     * to produce the charts.\n     * @protected\n     * @param {Object[]} dataPoints\n     * @param {boolean} forceUseAllDataPoints\n     * @returns {Object}\n     */\n    _getData(dataPoints, forceUseAllDataPoints) {\n        const { comparisonField, groupBy, mode } = this.metaData;\n\n        let identify = false;\n        if (comparisonField && groupBy.length && groupBy[0].fieldName === comparisonField) {\n            identify = true;\n        }\n        const dateClasses = identify ? this._getDateClasses(dataPoints) : null;\n\n        const dataPtMapping = new WeakMap();\n        const datasetsTmp = {};\n        let exceeds = false;\n\n        // dataPoints --> labels\n        let labels = [];\n        const labelMap = {};\n        for (const dataPt of dataPoints) {\n            const datasetLabel = this._getDatasetLabel(dataPt);\n            if (!(datasetLabel in datasetsTmp)) {\n                if (!forceUseAllDataPoints && Object.keys(datasetsTmp).length >= DATA_LIMIT) {\n                    exceeds = true;\n                    continue;\n                }\n                datasetsTmp[datasetLabel] = {\n                    label: datasetLabel,\n                    originIndex: dataPt.originIndex,\n                }; // add the entry but don't initialize it entirely\n            }\n            dataPtMapping.set(dataPt, datasetsTmp[datasetLabel]);\n\n            const x = dataPt.labels.slice(0, mode === \"pie\" ? undefined : 1);\n            const trueLabel = x.length ? x.join(SEP) : _t(\"Total\");\n            if (dateClasses) {\n                x[0] = dateClasses.classLabel(dataPt.originIndex, x[0]);\n            }\n            const key = JSON.stringify(x);\n            if (labelMap[key] === undefined) {\n                labelMap[key] = labels.length;\n                if (dateClasses) {\n                    if (mode === \"pie\") {\n                        x[0] = dateClasses.classMembers(x[0]).join(\", \");\n                    } else {\n                        x[0] = dateClasses.representative(x[0]);\n                    }\n                }\n                const label = x.length ? x.join(SEP) : _t(\"Total\");\n                labels.push(label);\n            }\n            dataPt.labelIndex = labelMap[key];\n            dataPt.trueLabel = trueLabel;\n        }\n\n        // dataPoints + labels --> datasetsTmp --> datasets\n        for (const dataPt of dataPoints) {\n            if (!dataPtMapping.has(dataPt)) {\n                continue;\n            }\n\n            const {\n                domain,\n                labelIndex,\n                originIndex,\n                trueLabel,\n                value,\n                identifier,\n                cumulatedStart,\n            } = dataPt;\n            const dataset = dataPtMapping.get(dataPt);\n            if (!dataset.data) {\n                let dataLength = labels.length;\n                if (mode !== \"pie\" && dateClasses) {\n                    dataLength = dateClasses.arrayLength(originIndex);\n                }\n                Object.assign(dataset, {\n                    data: new Array(dataLength).fill(0),\n                    cumulatedStart,\n                    trueLabels: labels.slice(0, dataLength), // should be good // check this in case identify = true\n                    domains: new Array(dataLength).fill([]),\n                    identifiers: new Set(),\n                });\n            }\n            dataset.data[labelIndex] = value;\n            dataset.domains[labelIndex] = domain;\n            dataset.trueLabels[labelIndex] = trueLabel;\n            dataset.identifiers.add(identifier);\n        }\n        // sort by origin\n        let datasets = sortBy(Object.values(datasetsTmp), \"originIndex\");\n\n        if (mode === \"pie\") {\n            // We kinda have a matrix. We remove the zero columns and rows. This is a global operation.\n            // That's why it cannot be done before.\n            datasets = datasets.filter((dataset) => dataset.data.some((v) => Boolean(v)));\n            const labelsToKeepIndexes = {};\n            labels.forEach((_, index) => {\n                if (datasets.some((dataset) => Boolean(dataset.data[index]))) {\n                    labelsToKeepIndexes[index] = true;\n                }\n            });\n            labels = labels.filter((_, index) => labelsToKeepIndexes[index]);\n            for (const dataset of datasets) {\n                dataset.data = dataset.data.filter((_, index) => labelsToKeepIndexes[index]);\n                dataset.domains = dataset.domains.filter((_, index) => labelsToKeepIndexes[index]);\n                dataset.trueLabels = dataset.trueLabels.filter(\n                    (_, index) => labelsToKeepIndexes[index]\n                );\n            }\n        }\n\n        return {\n            datasets,\n            labels,\n            exceeds,\n        };\n    }\n\n    _getLabel(description) {\n        if (!description) {\n            return _t(\"Sum\");\n        } else {\n            return _t(\"Sum (%s)\", description);\n        }\n    }\n\n    _getLineOverlayDataset() {\n        const { domains, stacked } = this.metaData;\n        const data = this.data;\n        let lineOverlayDataset = null;\n        if (stacked) {\n            const stacks = groupBy(data.datasets, (dataset) => dataset.originIndex);\n            if (Object.keys(stacks).length == 1) {\n                const [[originIndex, datasets]] = Object.entries(stacks);\n                if (datasets.length > 1) {\n                    const data = [];\n                    for (const dataset of datasets) {\n                        for (let i = 0; i < dataset.data.length; i++) {\n                            data[i] = (data[i] || 0) + dataset.data[i];\n                        }\n                    }\n                    lineOverlayDataset = {\n                        label: this._getLabel(domains[originIndex].description),\n                        data,\n                        trueLabels: datasets[0].trueLabels,\n                    };\n                }\n            }\n        }\n        return lineOverlayDataset;\n    }\n\n    /**\n     * Determines the dataset to which the data point belongs.\n     * @protected\n     * @param {Object} dataPoint\n     * @returns {string}\n     */\n    _getDatasetLabel(dataPoint) {\n        const { measure, measures, domains, mode } = this.metaData;\n        const { labels, originIndex } = dataPoint;\n        if (mode === \"pie\") {\n            return domains[originIndex].description || \"\";\n        }\n        // ([origin] + second to last groupBys) or measure\n        let datasetLabel = labels.slice(1).join(SEP);\n        if (domains.length > 1) {\n            datasetLabel =\n                domains[originIndex].description + (datasetLabel ? SEP + datasetLabel : \"\");\n        }\n        datasetLabel = datasetLabel || measures[measure].string;\n        return datasetLabel;\n    }\n\n    /**\n     * @protected\n     * @param {Object[]} dataPoints\n     * @returns {DateClasses}\n     */\n    _getDateClasses(dataPoints) {\n        const { domains } = this.metaData;\n        const dateSets = domains.map(() => new Set());\n        for (const { labels, originIndex } of dataPoints) {\n            const date = labels[0];\n            dateSets[originIndex].add(date);\n        }\n        const arrays = dateSets.map((dateSet) => [...dateSet]);\n        return new DateClasses(arrays);\n    }\n\n    /**\n     * @protected\n     * @returns {string}\n     */\n    _getDefaultFilterLabel(field) {\n        return _t(\"None\");\n    }\n\n    /**\n     * Eventually filters and sort data points.\n     * @protected\n     * @returns {Object[]}\n     */\n    _getProcessedDataPoints() {\n        const { domains, groupBy, mode, order } = this.metaData;\n        let processedDataPoints = [];\n        if (mode === \"line\") {\n            processedDataPoints = this.dataPoints.filter(\n                (dataPoint) => dataPoint.labels[0] !== this._getDefaultFilterLabel(groupBy[0])\n            );\n        } else if (mode === \"pie\") {\n            processedDataPoints = this.dataPoints.filter(\n                (dataPoint) => dataPoint.value > 0 && dataPoint.count !== 0\n            );\n        } else {\n            processedDataPoints = this.dataPoints.filter((dataPoint) => dataPoint.count !== 0);\n        }\n\n        if (order !== null && mode !== \"pie\" && domains.length === 1 && groupBy.length > 0) {\n            // group data by their x-axis value, and then sort datapoints\n            // based on the sum of values by group in ascending/descending order\n            const groupedDataPoints = {};\n            for (const dataPt of processedDataPoints) {\n                const key = dataPt.labels[0]; // = x-axis value under the current assumptions\n                if (!groupedDataPoints[key]) {\n                    groupedDataPoints[key] = [];\n                }\n                groupedDataPoints[key].push(dataPt);\n            }\n            const groups = Object.values(groupedDataPoints);\n            const groupTotal = (group) => group.reduce((sum, dataPt) => sum + dataPt.value, 0);\n            processedDataPoints = sortBy(groups, groupTotal, order.toLowerCase()).flat();\n        }\n\n        return processedDataPoints;\n    }\n\n    /**\n     * Fetch and process graph data.  It is basically a(some) read_group(s)\n     * with correct fields for each domain.  We have to do some light processing\n     * to separate date groups in the field list, because they can be defined\n     * with an aggregation function, such as my_date:week.\n     * @protected\n     * @param {Object} metaData\n     * @returns {Object[]}\n     */\n    async _loadDataPoints(metaData) {\n        const { measure, domains, fields, groupBy, resModel, cumulatedStart } = metaData;\n        const fieldName = groupBy[0]?.fieldName;\n        const sequential_field =\n            cumulatedStart && SEQUENTIAL_TYPES.includes(fields[fieldName]?.type) ? fieldName : null;\n        const sequential_spec = sequential_field && groupBy[0].spec;\n        const measures = [\"__count\"];\n        if (measure !== \"__count\") {\n            let { aggregator, type } = fields[measure];\n            if (type === \"many2one\") {\n                aggregator = \"count_distinct\";\n            }\n            if (aggregator === undefined) {\n                throw new Error(\n                    `No aggregate function has been provided for the measure '${measure}'`\n                );\n            }\n            measures.push(`${measure}:${aggregator}`);\n        }\n\n        const numbering = {}; // used to avoid ambiguity with many2one with values with same labels:\n        // for instance [1, \"ABC\"] [3, \"ABC\"] should be distinguished.\n\n        const proms = domains.map(async (domain, originIndex) => {\n            const data = await this.orm.webReadGroup(\n                resModel,\n                domain.arrayRepr,\n                measures,\n                groupBy.map((gb) => gb.spec),\n                {\n                    lazy: false, // what is this thing???\n                    context: { fill_temporal: true, ...this.searchParams.context },\n                }\n            );\n            let start = false;\n            if (\n                cumulatedStart &&\n                sequential_field &&\n                data.groups.length &&\n                domain.arrayRepr.some((leaf) => leaf.length === 3 && leaf[0] == sequential_field)\n            ) {\n                const first_date = data.groups[0].__range[sequential_spec].from;\n                const new_domain = Domain.combine(\n                    [\n                        new Domain([[sequential_field, \"<\", first_date]]),\n                        Domain.removeDomainLeaves(domain.arrayRepr, [sequential_field]),\n                    ],\n                    \"AND\"\n                ).toList();\n                start = await this.orm.webReadGroup(\n                    resModel,\n                    new_domain,\n                    measures,\n                    groupBy.filter((gb) => gb.fieldName != sequential_field).map((gb) => gb.spec),\n                    {\n                        lazy: false, // what is this thing???\n                        context: { ...this.searchParams.context },\n                    }\n                );\n            }\n            const dataPoints = [];\n            const cumulatedStartValue = {};\n            if (start) {\n                for (const group of start.groups) {\n                    const rawValues = [];\n                    for (const gb of groupBy.filter((gb) => gb.fieldName != sequential_field)) {\n                        rawValues.push({ [gb.spec]: group[gb.spec] });\n                    }\n                    cumulatedStartValue[JSON.stringify(rawValues)] = group[measure];\n                }\n            }\n            for (const group of data.groups) {\n                const { __domain, __count } = group;\n                const labels = [];\n                const rawValues = [];\n                for (const gb of groupBy) {\n                    let label;\n                    const val = group[gb.spec];\n                    rawValues.push({ [gb.spec]: val });\n                    const fieldName = gb.fieldName;\n                    const { type } = fields[fieldName];\n                    if (type === \"boolean\") {\n                        label = `${val}`; // toUpperCase?\n                    } else if (val === false) {\n                        label = this._getDefaultFilterLabel(gb);\n                    } else if ([\"many2many\", \"many2one\"].includes(type)) {\n                        const [id, name] = val;\n                        const key = JSON.stringify([fieldName, name]);\n                        if (!numbering[key]) {\n                            numbering[key] = {};\n                        }\n                        const numbers = numbering[key];\n                        if (!numbers[id]) {\n                            numbers[id] = Object.keys(numbers).length + 1;\n                        }\n                        const num = numbers[id];\n                        label = num === 1 ? name : `${name} (${num})`;\n                    } else if (type === \"selection\") {\n                        const selected = fields[fieldName].selection.find((s) => s[0] === val);\n                        label = selected[1];\n                    } else {\n                        label = val;\n                    }\n                    labels.push(label);\n                }\n\n                let value = group[measure];\n                if (value instanceof Array) {\n                    // case where measure is a many2one and is used as groupBy\n                    value = 1;\n                }\n                if (!Number.isInteger(value)) {\n                    metaData.allIntegers = false;\n                }\n                const group_id = JSON.stringify(rawValues.slice(1));\n                dataPoints.push({\n                    count: __count,\n                    domain: __domain,\n                    value,\n                    labels,\n                    originIndex,\n                    identifier: JSON.stringify(rawValues),\n                    cumulatedStart: cumulatedStartValue[group_id] || 0,\n                });\n            }\n            return dataPoints;\n        });\n        const promResults = await Promise.all(proms);\n        return promResults.flat();\n    }\n\n    /**\n     * Process metaData.groupBy in order to keep only the finest interval option for\n     * elements based on date/datetime field (e.g. 'date:year'). This means that\n     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.\n     * For instance,\n     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].\n     * @protected\n     * @param {Object} metaData\n     */\n    _normalize(metaData) {\n        const { fields } = metaData;\n        const groupBy = [];\n        for (const gb of metaData.groupBy) {\n            let ngb = gb;\n            if (typeof gb === \"string\") {\n                ngb = getGroupBy(gb, fields);\n            }\n            groupBy.push(ngb);\n        }\n\n        const processedGroupBy = [];\n        for (const gb of groupBy) {\n            const { fieldName, interval } = gb;\n            if (!fieldName.includes(\".\")) {\n                const { groupable, type } = fields[fieldName];\n                if (\n                    // cf. _description_groupable in odoo/fields.py\n                    !groupable ||\n                    [\"id\", \"__count\"].includes(fieldName) ||\n                    !GROUPABLE_TYPES.includes(type)\n                ) {\n                    continue;\n                }\n            }\n            const index = processedGroupBy.findIndex((gb) => gb.fieldName === fieldName);\n            if (index === -1) {\n                processedGroupBy.push(gb);\n            } else if (interval) {\n                const registeredInterval = processedGroupBy[index].interval;\n                if (rankInterval(registeredInterval) < rankInterval(interval)) {\n                    processedGroupBy.splice(index, 1, gb);\n                }\n            }\n        }\n        metaData.groupBy = processedGroupBy;\n\n        metaData.measure = processMeasure(metaData.measure);\n    }\n\n    /**\n     * @protected\n     * @param {boolean} [forceUseAllDataPoints=false]\n     */\n    _prepareData(forceUseAllDataPoints = false) {\n        const processedDataPoints = this._getProcessedDataPoints();\n        this.data = this._getData(processedDataPoints, forceUseAllDataPoints);\n        this.lineOverlayDataset = null;\n        if (this.metaData.mode === \"bar\") {\n            this.lineOverlayDataset = this._getLineOverlayDataset();\n        }\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport {\n    getBorderWhite,\n    DEFAULT_BG,\n    getColor,\n    getCustomColor,\n    lightenColor,\n    darkenColor,\n} from \"@web/core/colors/colors\";\nimport { registry } from \"@web/core/registry\";\nimport { formatFloat } from \"@web/views/fields/formatters\";\nimport { SEP } from \"./graph_model\";\nimport { sortBy } from \"@web/core/utils/arrays\";\nimport { loadBundle } from \"@web/core/assets\";\nimport { renderToString } from \"@web/core/utils/render\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nimport { Component, onWillUnmount, useEffect, useRef, onWillStart } from \"@odoo/owl\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { cookie } from \"@web/core/browser/cookie\";\nimport { ReportViewMeasures } from \"@web/views/view_components/report_view_measures\";\n\nconst NO_DATA = _t(\"No data\");\nconst formatters = registry.category(\"formatters\");\n\nconst colorScheme = cookie.get(\"color_scheme\");\nconst GRAPH_LEGEND_COLOR = getCustomColor(colorScheme, \"#111827\", \"#ffffff\");\nconst GRAPH_GRID_COLOR = getCustomColor(colorScheme, \"rgba(0,0,0,.1)\", \"rgba(255,255,255,.15\");\nconst GRAPH_LABEL_COLOR = getCustomColor(colorScheme, \"#111827\", \"#E4E4E4\");\nconst NO_DATA_COLOR = getCustomColor(colorScheme, DEFAULT_BG, \"#3C3E4B\");\n\n/**\n * Custom Plugin for Line chart:\n * Draw the scale grid on top of the chart to\n * see this last one correctly.\n */\nconst gridOnTop = {\n    id: \"gridOnTop\",\n    afterDraw: (chart) => {\n        const elements = chart.getDatasetMeta(0).data || [];\n        const ctx = chart.ctx;\n        const chartArea = chart.chartArea;\n        const yAxis = chart.scales.y;\n        const xAxis = chart.scales.x;\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = GRAPH_GRID_COLOR;\n\n        // Draw Y axis scale\n        yAxis.ticks.forEach((value, index) => {\n            const y = yAxis.getPixelForTick(index);\n            ctx.beginPath();\n            // Draw the line scale\n            ctx.moveTo(chartArea.left, y);\n            ctx.lineTo(chartArea.right, y);\n            // Draw the tick mark\n            ctx.moveTo(chartArea.left - 8, y);\n            ctx.lineTo(chartArea.left, y);\n            ctx.setLineDash([]);\n            ctx.stroke();\n        });\n\n        // Draw X axis tick marks\n        xAxis.ticks.forEach((value, tickIndex) => {\n            const x = xAxis.getPixelForTick(tickIndex);\n            ctx.beginPath();\n            ctx.moveTo(x, chartArea.bottom);\n            ctx.lineTo(x, chartArea.bottom + 8);\n            ctx.stroke();\n        });\n\n        // Draw the X axis dashed line\n        elements.forEach((point, eltIndex) => {\n            xAxis.ticks.forEach((value, tickIndex) => {\n                if (point.active && eltIndex === tickIndex) {\n                    const x = xAxis.getPixelForTick(tickIndex);\n                    ctx.beginPath();\n                    ctx.moveTo(x, chartArea.top);\n                    ctx.lineTo(x, chartArea.bottom);\n                    ctx.strokeStyle = GRAPH_GRID_COLOR;\n                    ctx.stroke();\n                }\n            });\n        });\n    },\n};\n\n/**\n * @param {Object} chartArea\n * @returns {string}\n */\nfunction getMaxWidth(chartArea) {\n    const { left, right } = chartArea;\n    return Math.floor((right - left) / 1.618) + \"px\";\n}\n\n/**\n * Used to avoid too long legend items.\n * @param {string} label\n * @returns {string} shortened version of the input label\n */\nfunction shortenLabel(label) {\n    // string returned could be wrong if a groupby value contain a \" / \"!\n    const groups = label.toString().split(SEP);\n    let shortLabel = groups.slice(0, 3).join(SEP);\n    if (shortLabel.length > 30) {\n        shortLabel = `${shortLabel.slice(0, 30)}...`;\n    } else if (groups.length > 3) {\n        shortLabel = `${shortLabel}${SEP}...`;\n    }\n    return shortLabel;\n}\n\nexport class GraphRenderer extends Component {\n    static template = \"web.GraphRenderer\";\n    static components = { Dropdown, DropdownItem, ReportViewMeasures };\n    static props = [\"class?\", \"model\", \"buttonTemplate\"];\n\n    setup() {\n        this.model = this.props.model;\n\n        this.rootRef = useRef(\"root\");\n        this.canvasRef = useRef(\"canvas\");\n        this.containerRef = useRef(\"container\");\n        this.actionService = useService(\"action\");\n\n        this.chart = null;\n        this.tooltip = null;\n        this.legendTooltip = null;\n\n        onWillStart(async () => {\n            await loadBundle(\"web.chartjs_lib\");\n        });\n\n        useEffect(() => this.renderChart());\n        onWillUnmount(this.onWillUnmount);\n    }\n\n    onWillUnmount() {\n        if (this.chart) {\n            this.chart.destroy();\n        }\n    }\n\n    /**\n     * This function aims to remove a suitable number of lines from the\n     * tooltip in order to make it reasonably visible. A message indicating\n     * the number of lines is added if necessary.\n     * @param {HTMLElement} tooltip\n     * @param {number} maxTooltipHeight this the max height in pixels of the tooltip\n     */\n    adjustTooltipHeight(tooltip, maxTooltipHeight) {\n        const sizeOneLine = tooltip.querySelector(\"tbody tr\").clientHeight;\n        const tbodySize = tooltip.querySelector(\"tbody\").clientHeight;\n        const toKeep = Math.max(\n            0,\n            Math.floor((maxTooltipHeight - (tooltip.clientHeight - tbodySize)) / sizeOneLine) - 1\n        );\n        const lines = tooltip.querySelectorAll(\"tbody tr\");\n        const toRemove = lines.length - toKeep;\n        if (toRemove > 0) {\n            for (let index = toKeep; index < lines.length; ++index) {\n                lines[index].remove();\n            }\n            const tr = document.createElement(\"tr\");\n            const td = document.createElement(\"td\");\n            tr.classList.add(\"o_show_more\", \"text-center\", \"fw-bold\");\n            td.setAttribute(\"colspan\", \"2\");\n            td.innerText = _t(\"...\");\n            tr.appendChild(td);\n            tooltip.querySelector(\"tbody\").appendChild(tr);\n        }\n    }\n\n    /**\n     * Creates a custom HTML tooltip.\n     * @param {Object} data\n     * @param {Object} metaData\n     * @param {Object} context see chartjs documentation\n     */\n    customTooltip(data, metaData, context) {\n        const tooltipModel = context.tooltip;\n        const { measure, measures, disableLinking, mode } = metaData;\n        this.containerRef.el.style.cursor = \"\";\n        this.removeTooltips();\n        if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {\n            return;\n        }\n        if (!disableLinking && mode !== \"line\") {\n            this.containerRef.el.style.cursor = \"pointer\";\n        }\n        const chartAreaTop = this.chart.chartArea.top;\n        const viewContentTop = this.containerRef.el.getBoundingClientRect().top;\n        const innerHTML = renderToString(\"web.GraphRenderer.CustomTooltip\", {\n            maxWidth: getMaxWidth(this.chart.chartArea),\n            measure: measures[measure].string,\n            mode: this.model.metaData.mode,\n            tooltipItems: this.getTooltipItems(data, metaData, tooltipModel),\n        });\n        const template = Object.assign(document.createElement(\"template\"), { innerHTML });\n        const tooltip = template.content.firstChild;\n        this.containerRef.el.prepend(tooltip);\n\n        let top;\n        const tooltipHeight = tooltip.clientHeight;\n        const minTopAllowed = Math.floor(chartAreaTop);\n        const maxTopAllowed = Math.floor(window.innerHeight - (viewContentTop + tooltipHeight)) - 2;\n        const y = Math.floor(tooltipModel.y);\n        if (minTopAllowed <= maxTopAllowed) {\n            // Here we know that the full tooltip can fit in the screen.\n            // We put it in the position where Chart.js would put it\n            // if two conditions are respected:\n            //  1: the tooltip is not cut (because we know it is possible to not cut it)\n            //  2: the tooltip does not hide the legend.\n            // If it is not possible to use the Chart.js proposition (y)\n            // we use the best approximated value.\n            if (y <= maxTopAllowed) {\n                if (y >= minTopAllowed) {\n                    top = y;\n                } else {\n                    top = minTopAllowed;\n                }\n            } else {\n                top = maxTopAllowed;\n            }\n        } else {\n            // Here we know that we cannot satisfy condition 1 above,\n            // so we position the tooltip at the minimal position and\n            // cut it the minimum possible.\n            top = minTopAllowed;\n            const maxTooltipHeight = window.innerHeight - (viewContentTop + chartAreaTop) - 2;\n            this.adjustTooltipHeight(tooltip, maxTooltipHeight);\n        }\n        this.fixTooltipLeftPosition(tooltip, tooltipModel.x);\n        tooltip.style.top = Math.floor(top) + \"px\";\n\n        this.tooltip = tooltip;\n    }\n\n    /**\n     * Sets best left position of a tooltip approaching the proposal x.\n     * @param {HTMLElement} tooltip\n     * @param {number} x\n     */\n    fixTooltipLeftPosition(tooltip, x) {\n        let left;\n        const tooltipWidth = tooltip.clientWidth;\n        const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);\n        const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);\n        x = Math.floor(x);\n        if (x < minLeftAllowed) {\n            left = minLeftAllowed;\n        } else if (x > maxLeftAllowed) {\n            left = maxLeftAllowed;\n        } else {\n            left = x;\n        }\n        tooltip.style.left = `${left}px`;\n    }\n\n    /**\n     * Used to format correctly the values in tooltip and y.\n     * @param {number} value\n     * @param {boolean} [allIntegers=true]\n     * @returns {string}\n     */\n    formatValue(value, allIntegers = true, formatType = \"\") {\n        const largeNumber = Math.abs(value) >= 1000;\n        if (formatType) {\n            return formatters.get(formatType)(value);\n        }\n        if (allIntegers && !largeNumber) {\n            return String(value);\n        }\n        if (largeNumber) {\n            return formatFloat(value, { humanReadable: true, decimals: 2, minDigits: 1 });\n        }\n        return formatFloat(value);\n    }\n\n    /**\n     * Returns the bar chart data\n     * @returns {Object}\n     */\n    getBarChartData() {\n        // style data\n        const { domains, stacked } = this.model.metaData;\n        const { data, lineOverlayDataset } = this.model;\n        for (let index = 0; index < data.datasets.length; ++index) {\n            const dataset = data.datasets[index];\n            const itemColor = getColor(index, colorScheme, data.datasets.length);\n            // used when stacked\n            if (stacked) {\n                dataset.stack = domains[dataset.originIndex].description || \"\";\n            }\n            // set dataset color\n            dataset.backgroundColor = itemColor;\n            dataset.borderRadius = 4;\n        }\n        if (lineOverlayDataset) {\n            // Mutate the lineOverlayDataset to include the config on how it will be displayed.\n            Object.assign(lineOverlayDataset, {\n                type: \"line\",\n                order: -1,\n                tension: 0,\n                fill: false,\n                pointHitRadius: 20,\n                pointRadius: 5,\n                pointHoverRadius: 10,\n                backgroundColor: getCustomColor(colorScheme, \"#343a40\", \"#e9ecef\"),\n                borderColor: getCustomColor(colorScheme, \"rgba(0,0,0,.3)\", \"rgba(255,255,255,.5)\"),\n                borderWidth: 2,\n                lineWidth: 3,\n            });\n            // We're not mutating the original datasets (`this.model.data.datasets`)\n            // because some part of the code depends on it.\n            return {\n                ...data,\n                datasets: [...data.datasets, lineOverlayDataset],\n            };\n        }\n\n        return data;\n    }\n\n    /**\n     * Returns the chart config.\n     * @returns {Object}\n     */\n    getChartConfig() {\n        const { mode } = this.model.metaData;\n        let data;\n        switch (mode) {\n            case \"bar\":\n                data = this.getBarChartData();\n                break;\n            case \"line\":\n                data = this.getLineChartData();\n                break;\n            case \"pie\":\n                data = this.getPieChartData();\n        }\n        const options = this.prepareOptions();\n        const config = { data, options, type: mode };\n        if (mode === \"line\") {\n            config.plugins = [gridOnTop];\n        }\n        return config;\n    }\n\n    /**\n     * Returns the animation options.\n     * 1. This adds progressive animation for Bar & Line charts.\n     * 2. Reduce animation duration for Pie chart.\n     * @returns {Object}\n     */\n    getAnimationOptions() {\n        let delayed;\n        const { mode } = this.model.metaData;\n        const labelsCount = this.model.data.labels.length;\n        const gap = 350;\n        const animationOptions = {};\n        if (mode === \"pie\") {\n            animationOptions.offset = { duration: 200 };\n        } else {\n            animationOptions.duration = 600;\n            animationOptions.onComplete = () => {\n                delayed = true;\n            };\n            animationOptions.delay = (context) => {\n                let delay = 0;\n                if ((mode === \"bar\" || mode === \"line\") && !delayed) {\n                    delay = context.dataIndex * (gap / labelsCount);\n                }\n                return delay;\n            };\n        }\n        return animationOptions;\n    }\n\n    /**\n     * Returns an object used to style chart elements independently from\n     * the datasets.\n     * @returns {Object}\n     */\n    getElementOptions() {\n        const { mode, stacked } = this.model.metaData;\n        const elementOptions = {};\n        if (mode === \"bar\") {\n            elementOptions.bar = { borderWidth: 1 };\n        } else if (mode === \"line\") {\n            elementOptions.line = { fill: stacked, tension: 0 };\n        }\n        return elementOptions;\n    }\n\n    /**\n     * @returns {Object}\n     */\n    getLegendOptions() {\n        const { mode } = this.model.metaData;\n        const legendOptions = {\n            onHover: this.onLegendHover.bind(this),\n            onLeave: this.onLegendLeave.bind(this),\n        };\n        if (mode === \"line\") {\n            legendOptions.onClick = this.onLegendClick.bind(this);\n        }\n        if (mode === \"pie\") {\n            legendOptions.labels = {\n                generateLabels: (chart) => {\n                    return chart.data.labels.map((label, index) => {\n                        const hidden = !chart.getDataVisibility(index);\n                        const fullText = label;\n                        const text = shortenLabel(fullText);\n                        const fillStyle =\n                            label === NO_DATA\n                                ? NO_DATA_COLOR\n                                : getColor(index, colorScheme, chart.data.labels.length);\n                        return {\n                            text,\n                            fullText,\n                            fillStyle,\n                            hidden,\n                            index,\n                            fontColor: GRAPH_LEGEND_COLOR,\n                            lineWidth: 0,\n                        };\n                    });\n                },\n            };\n        } else {\n            legendOptions.position = \"top\";\n            legendOptions.align = \"end\";\n            const referenceColor = mode === \"bar\" ? \"backgroundColor\" : \"borderColor\";\n            legendOptions.labels = {\n                generateLabels: (chart) => {\n                    const { data } = chart;\n                    const labels = data.datasets.map((dataset, index) => {\n                        return {\n                            text: shortenLabel(dataset.label),\n                            fullText: dataset.label,\n                            fillStyle: dataset[referenceColor],\n                            hidden: !chart.isDatasetVisible(index),\n                            lineCap: dataset.borderCapStyle,\n                            lineDash: dataset.borderDash,\n                            lineDashOffset: dataset.borderDashOffset,\n                            lineJoin: dataset.borderJoinStyle,\n                            lineWidth: dataset.borderWidth,\n                            strokeStyle: dataset[referenceColor],\n                            pointStyle: dataset.pointStyle,\n                            datasetIndex: index,\n                            fontColor: GRAPH_LEGEND_COLOR,\n                        };\n                    });\n                    return labels;\n                },\n            };\n        }\n        return legendOptions;\n    }\n\n    /**\n     * Returns line chart data.\n     * @returns {Object}\n     */\n    getLineChartData() {\n        const { cumulated } = this.model.metaData;\n        const data = this.model.data;\n        for (let index = 0; index < data.datasets.length; ++index) {\n            const dataset = data.datasets[index];\n            const itemColor = getColor(index, colorScheme, data.datasets.length);\n            dataset.backgroundColor = getCustomColor(\n                colorScheme,\n                lightenColor(itemColor, 0.5),\n                darkenColor(itemColor, 0.5)\n            );\n            dataset.cubicInterpolationMode = \"monotone\";\n            dataset.borderColor = itemColor;\n            dataset.borderWidth = 2;\n            dataset.hoverBackgroundColor = dataset.borderColor;\n            dataset.pointRadius = 3;\n            dataset.pointHoverRadius = 6;\n            if (cumulated) {\n                let accumulator = dataset.cumulatedStart;\n                dataset.data = dataset.data.map((value) => {\n                    accumulator += value;\n                    return accumulator;\n                });\n            }\n            if (data.labels.length === 1) {\n                // shift of the real value to right. This is done to\n                // center the points in the chart. See data.labels below in\n                // Chart parameters\n                dataset.data.unshift(undefined);\n                dataset.trueLabels.unshift(undefined);\n                dataset.domains.unshift(undefined);\n            }\n            dataset.pointBackgroundColor = dataset.borderColor;\n        }\n        // center the points in the chart (without that code they are put\n        // on the left and the graph seems empty)\n        data.labels = data.labels.length > 1 ? data.labels : [\"\", ...data.labels, \"\"];\n        return data;\n    }\n\n    /**\n     * Returns pie chart data.\n     * @returns {Object}\n     */\n    getPieChartData() {\n        const { domains } = this.model.metaData;\n        const data = this.model.data;\n        // style/complete data\n        // give same color to same groups from different origins\n        const colors = data.labels.map((_, index) =>\n            getColor(index, colorScheme, data.labels.length)\n        );\n        const borderColor = getBorderWhite(colorScheme);\n        for (const dataset of data.datasets) {\n            dataset.backgroundColor = colors;\n            dataset.hoverBackgroundColor = colors;\n            dataset.borderColor = borderColor;\n            dataset.hoverOffset = 60;\n        }\n        // make sure there is a zone associated with every origin\n        const representedOriginIndexes = new Set(\n            data.datasets.map((dataset) => dataset.originIndex)\n        );\n        let addNoDataToLegend = false;\n        const fakeData = new Array(data.labels.length + 1);\n        fakeData[data.labels.length] = 1;\n        const fakeTrueLabels = new Array(data.labels.length + 1);\n        fakeTrueLabels[data.labels.length] = NO_DATA;\n        for (let index = 0; index < domains.length; ++index) {\n            if (!representedOriginIndexes.has(index)) {\n                data.datasets.push({\n                    label: domains[index].description,\n                    data: fakeData,\n                    trueLabels: fakeTrueLabels,\n                    backgroundColor: [...colors, NO_DATA_COLOR],\n                    borderColor,\n                });\n                addNoDataToLegend = true;\n            }\n        }\n        if (addNoDataToLegend) {\n            data.labels.push(NO_DATA);\n        }\n\n        return data;\n    }\n\n    /**\n     * Returns the options used to generate the chart axes.\n     * @returns {Object}\n     */\n    getScaleOptions() {\n        const { labels } = this.model.data;\n        const { fieldAttrs, measure, measures, mode, stacked } = this.model.metaData;\n        if (mode === \"pie\") {\n            return {};\n        }\n        const xAxe = {\n            type: \"category\",\n            ticks: {\n                callback: (val, index) => {\n                    const value = labels[index];\n                    return shortenLabel(value);\n                },\n                color: GRAPH_LABEL_COLOR,\n            },\n            grid: {\n                color: \"transparent\",\n            },\n            border: {\n                display: false,\n            },\n        };\n        const yAxe = {\n            beginAtZero: true,\n            type: \"linear\",\n            title: {\n                text: measures[measure].string,\n                color:\n                    cookie.get(\"color_scheme\") === \"dark\"\n                        ? getColor(15, cookie.get(\"color_scheme\"))\n                        : null,\n            },\n            ticks: {\n                callback: (value) => this.formatValue(value, false, fieldAttrs[measure]?.widget),\n                color: GRAPH_LABEL_COLOR,\n            },\n            stacked: mode === \"line\" && stacked ? stacked : undefined,\n            grid: {\n                display: mode === \"line\" ? false : true,\n                color: GRAPH_GRID_COLOR,\n            },\n            border: {\n                display: false,\n            },\n            suggestedMax: 0,\n            suggestedMin: 0,\n        };\n        return { x: xAxe, y: yAxe };\n    }\n\n    /**\n     * This function extracts the information from the data points in\n     * tooltipModel.dataPoints (corresponding to datapoints over a given\n     * label determined by the mouse position) that will be displayed in a\n     * custom tooltip.\n     * @param {Object} data\n     * @param {Object} metaData\n     * @param {Object} tooltipModel see chartjs documentation\n     * @returns {Object[]}\n     */\n    getTooltipItems(data, metaData, tooltipModel) {\n        const { allIntegers, domains, mode, groupBy, measure } = metaData;\n        const sortedDataPoints = sortBy(tooltipModel.dataPoints, \"raw\", \"desc\");\n        const items = [];\n        for (const item of sortedDataPoints) {\n            const index = item.dataIndex;\n            // If `datasetIndex` is not found in the `datasets`, then it refers to the `lineOverlayDataset`.\n            const dataset = data.datasets[item.datasetIndex] || this.model.lineOverlayDataset;\n            let label = dataset.trueLabels[index];\n            let value = dataset.data[index];\n            const measureWidget = metaData.fieldAttrs[measure]?.widget;\n            value = this.formatValue(value, allIntegers, measureWidget);\n            let boxColor;\n            let percentage;\n            if (mode === \"pie\") {\n                if (label === NO_DATA) {\n                    value = this.formatValue(0, allIntegers, measureWidget);\n                }\n                if (domains.length > 1) {\n                    label = `${dataset.label} / ${label}`;\n                }\n                boxColor = dataset.backgroundColor[index];\n                const totalData = dataset.data.reduce((a, b) => a + b, 0);\n                percentage = totalData && ((dataset.data[index] * 100) / totalData).toFixed(2);\n            } else {\n                if (groupBy.length > 1 || domains.length > 1) {\n                    label = `${label} / ${dataset.label}`;\n                }\n                boxColor = mode === \"bar\" ? dataset.backgroundColor : dataset.borderColor;\n            }\n            items.push({ label, value, boxColor, percentage });\n        }\n        return items;\n    }\n\n    /**\n     * Returns the options used to generate chart tooltips.\n     * @returns {Object}\n     */\n    getTooltipOptions() {\n        const { data, metaData } = this.model;\n        const { mode } = metaData;\n        const tooltipOptions = {\n            enabled: false,\n            external: this.customTooltip.bind(this, data, metaData),\n        };\n        if (mode === \"line\") {\n            tooltipOptions.mode = \"index\";\n            tooltipOptions.intersect = false;\n            tooltipOptions.position = \"average\";\n        }\n        if (mode === \"bar\") {\n            tooltipOptions.xAlign = \"center\";\n            tooltipOptions.yAlign = \"bottom\";\n        }\n        if (mode === \"pie\") {\n            tooltipOptions.xAlign = \"center\";\n            tooltipOptions.yAlign = \"center\";\n        }\n        return tooltipOptions;\n    }\n\n    /**\n     * If a group has been clicked on, display a view of its records.\n     * @param {MouseEvent} ev\n     */\n    onGraphClicked(ev) {\n        const [activeElement] = this.chart.getElementsAtEventForMode(\n            ev,\n            \"nearest\",\n            { intersect: true },\n            false\n        );\n        if (!activeElement) {\n            return;\n        }\n        const { datasetIndex, index } = activeElement;\n        const { domains } = this.chart.data.datasets[datasetIndex];\n        if (domains) {\n            this.onGraphClickedFinal(domains[index]);\n        }\n    }\n\n    /**\n     * Overrides the default legend 'onClick' behaviour. This is done to\n     * remove all existing tooltips right before updating the chart.\n     * @param {Event} ev\n     * @param {Object} legendItem\n     */\n    onLegendClick(ev, legendItem) {\n        this.removeTooltips();\n        // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138\n        const index = legendItem.datasetIndex;\n        const meta = this.chart.getDatasetMeta(index);\n        meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;\n        this.chart.update();\n    }\n\n    /**\n     * If the text of a legend item has been shortened and the user mouse\n     * hovers that item (actually the event type is mousemove), a tooltip\n     * with the item full text is displayed.\n     * @param {Event} ev\n     * @param {Object} legendItem\n     */\n    onLegendHover(ev, legendItem) {\n        ev = ev.native;\n        this.canvasRef.el.style.cursor = \"pointer\";\n        /**\n         * The string legendItem.text is an initial segment of legendItem.fullText.\n         * If the two coincide, no need to generate a tooltip. If a tooltip\n         * for the legend already exists, it is already good and does not\n         * need to be recreated.\n         */\n        const { fullText, text } = legendItem;\n        if (this.legendTooltip || text === fullText) {\n            return;\n        }\n        const viewContentTop = this.canvasRef.el.getBoundingClientRect().top;\n        const legendTooltip = Object.assign(document.createElement(\"div\"), {\n            className: \"o_tooltip_legend popover p-3 pe-none position-absolute\",\n            innerText: fullText,\n        });\n        legendTooltip.style.top = `${ev.clientY - viewContentTop}px`;\n        legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);\n        this.containerRef.el.appendChild(legendTooltip);\n        this.fixTooltipLeftPosition(legendTooltip, ev.clientX);\n        this.legendTooltip = legendTooltip;\n    }\n\n    /**\n     * If there's a legend tooltip and the user mouse out of the\n     * corresponding legend item, the tooltip is removed.\n     */\n    onLegendLeave() {\n        this.canvasRef.el.style.cursor = \"\";\n        this.removeLegendTooltip();\n    }\n\n    /**\n     * Prepares options for the chart according to the current mode\n     * (= chart type). This function returns the parameter options used to\n     * instantiate the chart.\n     */\n    prepareOptions() {\n        const { disableLinking, mode } = this.model.metaData;\n        const options = {\n            maintainAspectRatio: false,\n            scales: this.getScaleOptions(),\n            plugins: {\n                legend: this.getLegendOptions(),\n                tooltip: this.getTooltipOptions(),\n            },\n            elements: this.getElementOptions(),\n            onResize: () => {\n                this.resizeChart(options);\n            },\n            animation: this.getAnimationOptions(),\n        };\n        if (!disableLinking && mode !== \"line\") {\n            options.onClick = this.onGraphClicked.bind(this);\n        }\n        if (mode === \"line\") {\n            options.interaction = {\n                mode: \"index\",\n                intersect: false,\n            };\n        }\n        if (mode === \"pie\") {\n            options.radius = \"90%\";\n        }\n        return options;\n    }\n\n    /**\n     * Adapt Pie chart layout on mobile\n     * @param {Object} context\n     */\n    resizeChart(context) {\n        const { mode } = this.model.metaData;\n        if (mode === \"pie\") {\n            if (this.env.isSmall) {\n                context.plugins.legend.position = \"bottom\";\n                context.plugins.legend.align = \"center\";\n            } else {\n                context.plugins.legend.position = \"right\";\n                context.plugins.legend.align = \"start\";\n            }\n        }\n    }\n\n    /**\n     * Removes the legend tooltip (if any).\n     */\n    removeLegendTooltip() {\n        if (this.legendTooltip) {\n            this.legendTooltip.remove();\n            this.legendTooltip = null;\n        }\n    }\n\n    /**\n     * Removes all existing tooltips (if any).\n     */\n    removeTooltips() {\n        if (this.tooltip) {\n            this.tooltip.remove();\n            this.tooltip = null;\n        }\n        this.removeLegendTooltip();\n    }\n\n    /**\n     * Instantiates a Chart (Chart.js lib) to render the graph according to\n     * the current config.\n     */\n    renderChart() {\n        if (this.chart) {\n            this.chart.destroy();\n        }\n        if (this.canvasRef.el) {\n            const config = this.getChartConfig();\n            this.chart = new Chart(this.canvasRef.el, config);\n        }\n    }\n\n    /**\n     * Execute the action to open the view on the current model.\n     *\n     * @param {Array} domain\n     * @param {Array} views\n     * @param {Object} context\n     */\n    openView(domain, views, context) {\n        this.actionService.doAction(\n            {\n                context,\n                domain,\n                name: this.model.metaData.title,\n                res_model: this.model.metaData.resModel,\n                target: \"current\",\n                type: \"ir.actions.act_window\",\n                views,\n            },\n            {\n                viewType: \"list\",\n            }\n        );\n    }\n    /**\n     * @param {string} domain the domain of the clicked area\n     */\n    onGraphClickedFinal(domain) {\n        const { context } = this.model.metaData;\n\n        Object.keys(context).forEach((x) => {\n            if (x === \"group_by\" || x.startsWith(\"search_default_\")) {\n                delete context[x];\n            }\n        });\n\n        const views = {};\n        for (const [viewId, viewType] of this.env.config.views || []) {\n            views[viewType] = viewId;\n        }\n        function getView(viewType) {\n            return [views[viewType] || false, viewType];\n        }\n        const actionViews = [getView(\"list\"), getView(\"form\")];\n        this.openView(domain, actionViews, context);\n    }\n\n    /**\n     * @param {Object} param0\n     * @param {string} param0.measure\n     */\n    onMeasureSelected({ measure }) {\n        this.model.updateMetaData({ measure });\n    }\n\n    /**\n     * @param {\"bar\"|\"line\"|\"pie\"} mode\n     */\n    onModeSelected(mode) {\n        if (this.model.metaData.mode != mode) {\n            this.model.updateMetaData({ mode });\n        }\n    }\n\n    /**\n     * @param {\"ASC\"|\"DESC\"} order\n     */\n    toggleOrder(order) {\n        const { order: currentOrder } = this.model.metaData;\n        const nextOrder = currentOrder === order ? null : order;\n        this.model.updateMetaData({ order: nextOrder });\n    }\n\n    toggleStacked() {\n        const { stacked } = this.model.metaData;\n        this.model.updateMetaData({ stacked: !stacked });\n    }\n\n    toggleCumulated() {\n        const { cumulated } = this.model.metaData;\n        this.model.updateMetaData({ cumulated: !cumulated });\n    }\n}\n", "import { SearchModel } from \"@web/search/search_model\";\n\nexport class GraphSearchModel extends SearchModel {\n    _getIrFilterDescription() {\n        this.preparingIrFilterDescription = true;\n        const result = super._getIrFilterDescription(...arguments);\n        this.preparingIrFilterDescription = false;\n        return result;\n    }\n\n    _getSearchItemGroupBys(activeItem) {\n        const { searchItemId } = activeItem;\n        const { context, type } = this.searchItems[searchItemId];\n        if (!this.preparingIrFilterDescription && type === \"favorite\" && context.graph_groupbys) {\n            return context.graph_groupbys;\n        }\n        return super._getSearchItemGroupBys(...arguments);\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport { registry } from \"@web/core/registry\";\nimport { GraphArchParser } from \"./graph_arch_parser\";\nimport { GraphModel } from \"./graph_model\";\nimport { GraphController } from \"./graph_controller\";\nimport { GraphRenderer } from \"./graph_renderer\";\nimport { GraphSearchModel } from \"./graph_search_model\";\n\nconst viewRegistry = registry.category(\"views\");\n\nexport const graphView = {\n    type: \"graph\",\n    Controller: GraphController,\n    Renderer: GraphRenderer,\n    Model: GraphModel,\n    ArchParser: GraphArchParser,\n    SearchModel: GraphSearchModel,\n    searchMenuTypes: [\"filter\", \"groupBy\", \"comparison\", \"favorite\"],\n    buttonTemplate: \"web.GraphView.Buttons\",\n\n    props: (genericProps, view) => {\n        let modelParams;\n        if (genericProps.state) {\n            modelParams = genericProps.state.metaData;\n        } else {\n            const { arch, fields, resModel } = genericProps;\n            const parser = new view.ArchParser();\n            const archInfo = parser.parse(arch, fields);\n            modelParams = {\n                disableLinking: Boolean(archInfo.disableLinking),\n                fieldAttrs: archInfo.fieldAttrs,\n                fields: fields,\n                groupBy: archInfo.groupBy,\n                measure: archInfo.measure || \"__count\",\n                viewMeasures: archInfo.measures,\n                mode: archInfo.mode || \"bar\",\n                order: archInfo.order || null,\n                resModel: resModel,\n                stacked: \"stacked\" in archInfo ? archInfo.stacked : true,\n                cumulated: archInfo.cumulated || false,\n                cumulatedStart: archInfo.cumulatedStart || false,\n                title: archInfo.title || _t(\"Untitled\"),\n            };\n        }\n\n        return {\n            ...genericProps,\n            modelParams,\n            Model: view.Model,\n            Renderer: view.Renderer,\n            buttonTemplate: view.buttonTemplate,\n        };\n    },\n};\n\nviewRegistry.add(\"graph\", graphView);\n", "import { exprToBoolean } from \"@web/core/utils/strings\";\nimport { visitXML } from \"@web/core/utils/xml\";\n\nexport class PivotArchParser {\n    parse(arch) {\n        const archInfo = {\n            activeMeasures: [], // store the defined active measures\n            colGroupBys: [], // store the defined group_by used on cols\n            defaultOrder: null,\n            fieldAttrs: {},\n            rowGroupBys: [], // store the defined group_by used on rows\n            widgets: {}, // wigdets defined in the arch\n        };\n\n        visitXML(arch, (node) => {\n            switch (node.tagName) {\n                case \"pivot\": {\n                    if (node.hasAttribute(\"disable_linking\")) {\n                        archInfo.disableLinking = exprToBoolean(\n                            node.getAttribute(\"disable_linking\")\n                        );\n                    }\n                    if (node.hasAttribute(\"default_order\")) {\n                        archInfo.defaultOrder = node.getAttribute(\"default_order\");\n                    }\n                    if (node.hasAttribute(\"string\")) {\n                        archInfo.title = node.getAttribute(\"string\");\n                    }\n                    if (node.hasAttribute(\"display_quantity\")) {\n                        archInfo.displayQuantity = exprToBoolean(\n                            node.getAttribute(\"display_quantity\")\n                        );\n                    }\n                    break;\n                }\n                case \"field\": {\n                    let fieldName = node.getAttribute(\"name\"); // exists (rng validation)\n\n                    archInfo.fieldAttrs[fieldName] = {};\n                    if (node.hasAttribute(\"string\")) {\n                        archInfo.fieldAttrs[fieldName].string = node.getAttribute(\"string\");\n                    }\n                    if (\n                        node.getAttribute(\"invisible\") === \"True\" ||\n                        node.getAttribute(\"invisible\") === \"1\"\n                    ) {\n                        archInfo.fieldAttrs[fieldName].isInvisible = true;\n                        break;\n                    }\n\n                    if (node.hasAttribute(\"interval\")) {\n                        fieldName += \":\" + node.getAttribute(\"interval\");\n                    }\n                    if (node.hasAttribute(\"widget\")) {\n                        archInfo.widgets[fieldName] = node.getAttribute(\"widget\");\n                    }\n                    if (node.getAttribute(\"type\") === \"measure\" || node.hasAttribute(\"operator\")) {\n                        archInfo.activeMeasures.push(fieldName);\n                    }\n                    if (node.getAttribute(\"type\") === \"col\") {\n                        archInfo.colGroupBys.push(fieldName);\n                    }\n                    if (node.getAttribute(\"type\") === \"row\") {\n                        archInfo.rowGroupBys.push(fieldName);\n                    }\n                    break;\n                }\n            }\n        });\n\n        return archInfo;\n    }\n}\n", "import { Layout } from \"@web/search/layout\";\nimport { useModelWithSampleData } from \"@web/model/model\";\nimport { standardViewProps } from \"@web/views/standard_view_props\";\nimport { useSetupAction } from \"@web/search/action_hook\";\nimport { SearchBar } from \"@web/search/search_bar/search_bar\";\nimport { useSearchBarToggler } from \"@web/search/search_bar/search_bar_toggler\";\nimport { CogMenu } from \"@web/search/cog_menu/cog_menu\";\n\nimport { Component, useRef } from \"@odoo/owl\";\n\nexport class PivotController extends Component {\n    static template = \"web.PivotView\";\n    static components = { Layout, SearchBar, CogMenu };\n    static props = {\n        ...standardViewProps,\n        Model: Function,\n        modelParams: Object,\n        Renderer: Function,\n        buttonTemplate: String,\n    };\n\n    setup() {\n        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);\n\n        useSetupAction({\n            rootRef: useRef(\"root\"),\n            getLocalState: () => {\n                const { data, metaData } = this.model;\n                return { data, metaData };\n            },\n            getContext: () => this.getContext(),\n        });\n        this.searchBarToggler = useSearchBarToggler();\n    }\n    /**\n     * @returns {Object}\n     */\n    getContext() {\n        return {\n            pivot_measures: this.model.metaData.activeMeasures,\n            pivot_column_groupby: this.model.metaData.fullColGroupBys,\n            pivot_row_groupby: this.model.metaData.fullRowGroupBys,\n        };\n    }\n}\n", "import { Component } from \"@odoo/owl\";\nimport { CheckboxItem } from \"@web/core/dropdown/checkbox_item\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { useDropdownState } from \"@web/core/dropdown/dropdown_hooks\";\nimport { localization } from \"@web/core/l10n/localization\";\nimport { sortBy } from \"@web/core/utils/arrays\";\nimport { useBus } from \"@web/core/utils/hooks\";\nimport { CustomGroupByItem } from \"@web/search/custom_group_by_item/custom_group_by_item\";\nimport { PropertiesGroupByItem } from \"@web/search/properties_group_by_item/properties_group_by_item\";\nimport { getIntervalOptions } from \"@web/search/utils/dates\";\nimport { FACET_ICONS, GROUPABLE_TYPES } from \"@web/search/utils/misc\";\n\nexport class PivotHeader extends Component {\n    static template = \"web.PivotHeader\";\n    static components = {\n        CustomGroupByItem,\n        Dropdown,\n        CheckboxItem,\n        PropertiesGroupByItem,\n    };\n    static defaultProps = {\n        isInHead: false,\n        isXAxis: false,\n        showCaretDown: false,\n    };\n    static props = {\n        cell: Object,\n        isInHead: { type: Boolean, optional: true },\n        isXAxis: { type: Boolean, optional: true },\n        customGroupBys: Object,\n        onAddCustomGroupBy: Function,\n        onItemSelected: Function,\n        onClick: Function,\n        slots: { optional: true },\n    };\n\n    setup() {\n        this.icon = FACET_ICONS.groupBy;\n        const fields = [];\n        for (const [fieldName, field] of Object.entries(this.env.searchModel.searchViewFields)) {\n            if (this.validateField(fieldName, field)) {\n                fields.push(Object.assign({ name: fieldName }, field));\n            }\n        }\n        this.fields = sortBy(fields, \"string\");\n        this.l10n = localization;\n        this.dropdownState = useDropdownState();\n\n        useBus(this.env.searchModel, \"update\", this.render);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get hideCustomGroupBy() {\n        return this.env.searchModel.hideCustomGroupBy || false;\n    }\n\n    /**\n     * @returns {Object[]}\n     */\n    get items() {\n        let items = this.env.searchModel.getSearchItems(\n            (searchItem) =>\n                [\"groupBy\", \"dateGroupBy\"].includes(searchItem.type) && !searchItem.custom\n        );\n        if (items.length === 0) {\n            items = this.fields;\n        }\n\n        // Add custom groupbys\n        let groupNumber = 1 + Math.max(0, ...items.map(({ groupNumber: n }) => n));\n        for (const [fieldName, customGroupBy] of this.props.customGroupBys.entries()) {\n            items.push({ ...customGroupBy, name: fieldName, groupNumber: groupNumber++ });\n        }\n\n        return items.map((item) => ({\n            ...item,\n            id: item.id || item.name,\n            fieldName: item.fieldName || item.name,\n            description: item.description || item.string,\n            isActive: false,\n            options:\n                item.options ||\n                ([\"date\", \"datetime\"].includes(item.type) ? getIntervalOptions() : undefined),\n        }));\n    }\n\n    get cell() {\n        return this.props.cell;\n    }\n\n    /**\n     * Retrieve the padding of a left header.\n     * @returns {Number} Padding\n     */\n    get padding() {\n        return 5 + this.cell.indent * 30;\n    }\n\n    /**\n     * @param {string} fieldName\n     * @param {Object} field\n     * @returns {boolean}\n     */\n    validateField(fieldName, field) {\n        const { groupable, type } = field;\n        return groupable && fieldName !== \"id\" && GROUPABLE_TYPES.includes(type);\n    }\n\n    /**\n     * @override\n     * @param {Object} param0\n     * @param {number} param0.itemId\n     * @param {number} [param0.optionId]\n     */\n    onGroupBySelected({ itemId, optionId }) {\n        // Here, we purposely do not call super.onGroupBySelected as we don't want\n        // to change the group-by on the model, only inside the pivot\n        const item = this.items.find(({ id }) => id === itemId);\n        this.props.onItemSelected({\n            itemId,\n            optionId,\n            fieldName: item.fieldName,\n            interval: optionId,\n            groupId: this.cell.groupId,\n        });\n    }\n\n    /**\n     * @param {string} fieldName\n     */\n    onAddCustomGroup(fieldName) {\n        this.props.onAddCustomGroupBy(fieldName);\n    }\n\n    /**\n     * @param {Event} event\n     */\n    onClick(event) {\n        if (this.cell.isLeaf && !this.cell.isFolded) {\n            this.dropdownState.open();\n        }\n        this.props.onClick();\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport { Domain } from \"@web/core/domain\";\nimport { cartesian, sections, sortBy, symmetricalDifference } from \"@web/core/utils/arrays\";\nimport { KeepLast, Race } from \"@web/core/utils/concurrency\";\nimport { DEFAULT_INTERVAL } from \"@web/search/utils/dates\";\nimport { addPropertyFieldDefs, Model } from \"@web/model/model\";\nimport { computeReportMeasures, processMeasure } from \"@web/views/utils\";\n\n/**\n * @param {number} value\n * @param {number} comparisonValue\n * @returns {number}\n */\nfunction computeVariation(value, comparisonValue) {\n    if (isNaN(value) || isNaN(comparisonValue)) {\n        return NaN;\n    }\n    if (comparisonValue === 0) {\n        if (value === 0) {\n            return 0;\n        } else if (value > 0) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n    return (value - comparisonValue) / Math.abs(comparisonValue);\n}\n\n/**\n * Pivot Model\n *\n * The pivot model keeps an in-memory representation of the pivot table that is\n * displayed on the screen.  The exact layout of this representation is not so\n * simple, because a pivot table is at its core a 2-dimensional object, but\n * with a 'list' component: some rows/cols can be expanded so we zoom into the\n * structure.\n *\n * However, we need to be able to manipulate the data in a somewhat efficient\n * way, and to transform it into a list of lines to be displayed by the renderer.\n *\n * Basicaly the pivot table presents aggregated values for various groups of records\n * in one domain. If a comparison is asked for, two domains are considered.\n *\n * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):\n * ___________________________________________________________________________________________________________________________________________\n * |                    |   Total                                                                                                             |\n * |                    |_____________________________________________________________________________________________________________________|\n * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   Sales total                         |  Sales total                         |  Sales total                         |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |\n * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |\n * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |\n * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |\n * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n *\n *\n * META DATA:\n *\n * In the above pivot table, the records have been grouped using the fields\n *\n *      continent_id, city_id\n *\n * for rows and\n *\n *      sale_team_id\n *\n * for columns.\n *\n * The measure is the field 'sales_total'.\n *\n * Two domains are considered: 'May 2020' and 'June 2020'.\n *\n * In the model,\n *\n *      - rowGroupBys is the list [continent_id, city_id]\n *      - colGroupBys is the list [sale_team_id]\n *      - measures is the list [sales_total]\n *      - domains is the list [d1, d2] with d1 and d2 domain expressions\n *          for say sale_date in May 2020 and June 2020, for instance\n *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]\n *      - origins is the list ['May 2020', 'June 2020']\n *\n * DATA:\n *\n * Recall that a group is constituted by records (in a given domain)\n * that have the same (raw) values for a list of fields.\n * Thus the group itself is identified by this list and the domain.\n * In comparison mode, the same group (forgetting the domain part or 'originIndex')\n * can be eventually found in the two domains.\n * This defines the way in which the groups are identified or not.\n *\n * In the above table, (forgetting the domain) the following groups are found:\n *\n *      the 'row groups'\n *      - Total\n *      - Europe\n *      - America\n *      - Europe, Brussels\n *      - Europe, Paris\n *      - America, Washington\n *\n *      the 'col groups'\n *\n *      - Total\n *      - Sale Team 1\n *      - Sale Team 2\n *\n *      and all non trivial combinations of row groups and col groups\n *\n *      - Europe, Sale Team 1\n *      - Europe, Brussels, Sale Team 2\n *      - America, Washington, Sale Team 1\n *      - ...\n *\n * The list of fields is created from the concatenation of two lists of fields, the first in\n *\n * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys\n * (called rowGroupBys) used to create row groups\n *\n * In the example: [], [continent_id], [continent_id, city_id].\n *\n * and the second in\n * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys\n * (called colGroupBys) used to create col groups.\n *\n * In the example: [], [sale_team_id].\n *\n * Thus there are (n+1)*(m+1) lists of fields possible.\n *\n * In the example: 6 lists possible, namely [],\n *                                          [continent_id], [sale_team_id],\n *                                          [continent_id, sale_team_id], [continent_id, city_id],\n *                                          [continent_id, city_id, sale_team_id]\n *\n * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]\n *\n * For each list of fields possible and each domain considered, one read_group is done\n * and gives results of the form (an exception for list [])\n *\n * g = {\n *  f1: v1, ..., fi: vi,\n *  g1: w1, ..., gj: wj,\n *  m1: x1, ..., mk: xk,\n *  __count: c,\n *  __domain: d\n * }\n *\n * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and\n * m1,...,mk are the fields selected as measures.\n *\n * For example, g = {\n *      continent_id: [1, 'Europe']\n *      sale_team_id: [1, 'Sale Team 1']\n *      sales_count: 25,\n *      __count: 4\n *      __domain: [\n *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],\n *                  ['continent_id', '=', 1],\n *                  ['sale_team_id', '=', 1]\n *                ]\n * }\n *\n * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain\n * or the corresponding 'originIndex'.\n *\n * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]\n * (not forgetting the list [v1,...vi] comes from left).\n * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].\n *\n * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]\n * and [[], [w1,...,wj]].\n *\n * Here is a description of the data structure manipulated by the pivot model.\n *\n * Five objects contain all the data from the read_groups\n *\n *      - rowGroupTree: contains information on row headers\n *             the nodes correspond to the groups of the form [[v1,...,vi], []]\n *             The root is [[], []].\n *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],\n *             this means that a direct child is obtained by grouping records using the single field fi+1\n *\n *             The structure at each level is of the form\n *\n *             {\n *                  root: {\n *                      values: [v1,...,vl],\n *                      labels: [la1,...,lal]\n *                  },\n *                  directSubTrees: {\n *                      v => {\n *                              root: {\n *                                  values: [v1,...,vl,v]\n *                                  labels: [label1,...,labell,label]\n *                              },\n *                              directSubTrees: {...}\n *                          },\n *                      v' => {...},\n *                      ...\n *                  }\n *             }\n *\n *             (directSubTrees is a Map instance)\n *\n *             In the example, the rowGroupTree is:\n *\n *             {\n *                  root: {\n *                      values: [],\n *                      labels: []\n *                  },\n *                  directSubTrees: {\n *                      1 => {\n *                              root: {\n *                                  values: [1],\n *                                  labels: ['Europe'],\n *                              },\n *                              directSubTrees: {\n *                                  1 => {\n *                                          root: {\n *                                              values: [1, 1],\n *                                              labels: ['Europe', 'Brussels'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                                  2 => {\n *                                          root: {\n *                                              values: [1, 2],\n *                                              labels: ['Europe', 'Paris'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                          },\n *                      2 => {\n *                              root: {\n *                                  values: [2],\n *                                  labels: ['America'],\n *                              },\n *                              directSubTrees: {\n *                                  3 => {\n *                                          root: {\n *                                              values: [2, 3],\n *                                              labels: ['America', 'Washington'],\n *                                          }\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                      },\n *                  },\n *             }\n *\n *      - colGroupTree: contains information on col headers\n *              The same as above with right instead of left\n *\n *      - measurements: contains information on measure values for all the groups\n *\n *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])\n *              and values are arrays of length equal to number of origins containing objects of the form\n *                  {m1: x1,...,mk: xk}\n *              The structure looks like\n *\n *              {\n *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]\n *                  ....\n *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],\n *                  ....\n *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],\n *              }\n *              Thus the structure contains all information for all groups and all origins on measure values.\n *\n *\n *              this.measurments[\"[[], []]\"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the\n *              first domain (origin).\n *\n *              In the example:\n *                  {\n *                      \"[[], []]\": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)\n *                      ...\n *                      \"[[1, 2], [2]]\": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)\n *                      ...\n *                  }\n *\n *      - counts: contains information on the number of records in each groups\n *              The structure is similar to the above but the arrays contains numbers (counts)\n *      - groupDomains:\n *              The structure is similar to the above but the arrays contains domains\n *\n *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.\n *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the getTable function.\n */\n\n/**\n * @typedef Meta\n * @property {string[]} activeMeasures\n * @property {string[]} colGroupBys\n * @property {boolean} disableLinking\n * @property {Object} fields\n * @property {Object} measures\n * @property {string} resModel\n * @property {string[]} rowGroupBys\n * @property {string} title\n * @property {boolean} useSampleModel\n * @property {Object} widgets\n * @property {Map} customGroupBys\n * @property {string[]} expandedRowGroupBys\n * @property {string[]} expandedColGroupBys\n * @property {Object} sortedColumn\n * @property {Array[]} domains\n * @property {string[]} origins\n */\n\n/**\n * @typedef Data\n * @property {Object} colGroupTree\n * @property {Object} rowGroupTree\n * @property {Object} groupDomains\n * @property {Object} measurements\n * @property {Object} counts\n * @property {Object} numbering\n */\n\n/**\n * @typedef {import(\"@web/search/search_model\").SearchParams} SearchParams\n */\n\n/**\n * @typedef Config\n * @property {MetaData} metaData\n * @property {Data} data\n */\n\nexport class PivotModel extends Model {\n    /**\n     * @override\n     * @param {Object} params.metaData\n     * @param {string[]} params.metaData.activeMeasures\n     * @param {string[]} params.metaData.colGroupBys\n     * @param {Object} params.metaData.fields\n     * @param {Object[]} params.metaData.measures\n     * @param {string} params.metaData.resModel\n     * @param {string[]} params.metaData.rowGroupBys\n     * @param {string|null} params.metaData.defaultOrder\n     * @param {boolean} params.metaData.disableLinking\n     * @param {boolean} params.metaData.useSampleModel\n     * @param {Map} [params.metaData.customGroupBys={}]\n     * @param {string[]} [params.metaData.expandedColGroupBys=[]]\n     * @param {string[]} [params.metaData.expandedRowGroupBys=[]]\n     * @param {Object|null} [params.metaData.sortedColumn=null]\n     * @param {Object} [params.data] previously exported data\n     */\n    setup(params) {\n        // concurrency management\n        this.keepLast = new KeepLast();\n        this.race = new Race();\n        const _loadData = this._loadData.bind(this);\n        this._loadData = (...args) => {\n            return this.race.add(_loadData(...args));\n        };\n\n        let sortedColumn = params.metaData.sortedColumn || null;\n        if (!sortedColumn && params.metaData.defaultOrder) {\n            const defaultOrder = params.metaData.defaultOrder.split(\" \");\n            sortedColumn = {\n                groupId: [[], []],\n                measure: defaultOrder[0],\n                order: defaultOrder[1] ? defaultOrder[1] : \"asc\",\n            };\n        }\n\n        this.searchParams = {\n            context: {},\n            domain: [],\n            domains: [],\n            groupBy: [],\n        };\n        this.data = params.data || {\n            colGroupTree: null,\n            rowGroupTree: null,\n            groupDomains: {},\n            measurements: {},\n            counts: {},\n            numbering: {},\n        };\n        const metaData = Object.assign({}, params.metaData, {\n            customGroupBys: params.metaData.customGroupBys || new Map(),\n            expandedRowGroupBys: params.metaData.expandedRowGroupBys || [],\n            expandedColGroupBys: params.metaData.expandedColGroupBys || [],\n            sortedColumn,\n        });\n        this.metaData = this._buildMetaData(metaData);\n\n        this.reload = false; // used to discriminate between the first load and subsequent reloads\n        this.nextActiveMeasures = null; // allows to toggle several measures consecutively\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.\n     *\n     * @param {Object} params\n     * @param {Array[]} params.groupId\n     * @param {string} params.fieldName\n     * @param {'row'|'col'} params.type\n     * @param {boolean} [params.custom=false]\n     * @param {string} [params.interval]\n     */\n    async addGroupBy(params) {\n        if (this.race.getCurrentProm()) {\n            return; // we are currently reloaded the table\n        }\n\n        const { groupId, fieldName, type, custom } = params;\n        let { interval } = params;\n        const metaData = this._buildMetaData();\n        if (custom && !metaData.customGroupBys.has(fieldName)) {\n            const field = metaData.fields[fieldName];\n            if (!interval && [\"date\", \"datetime\"].includes(field.type)) {\n                interval = DEFAULT_INTERVAL;\n            }\n            metaData.customGroupBys.set(fieldName, {\n                ...field,\n                id: fieldName,\n            });\n        }\n\n        let groupBy = fieldName;\n        if (interval) {\n            groupBy = `${groupBy}:${interval}`;\n        }\n        if (type === \"row\") {\n            metaData.expandedRowGroupBys.push(groupBy);\n        } else {\n            metaData.expandedColGroupBys.push(groupBy);\n        }\n        const config = { metaData, data: this.data };\n        await this._expandGroup(groupId, type, config);\n        this.metaData = metaData;\n        this.notify();\n    }\n    /**\n     * Close the group with id given by groupId. A type must be specified\n     * in case groupId is [[], []] (the id of the group 'Total') because this\n     * group is present in both colGroupTree and rowGroupTree.\n     *\n     * @param {Array[]} groupId\n     * @param {'row'|'col'} type\n     */\n    closeGroup(groupId, type) {\n        if (this.race.getCurrentProm()) {\n            return; // we are currently reloading the table\n        }\n\n        let groupBys;\n        let expandedGroupBys;\n        let keyPart;\n        let group;\n        let tree;\n        if (type === \"row\") {\n            groupBys = this.metaData.rowGroupBys;\n            expandedGroupBys = this.metaData.expandedRowGroupBys;\n            tree = this.data.rowGroupTree;\n            group = this._findGroup(this.data.rowGroupTree, groupId[0]);\n            keyPart = 0;\n        } else {\n            groupBys = this.metaData.colGroupBys;\n            expandedGroupBys = this.metaData.expandedColGroupBys;\n            tree = this.data.colGroupTree;\n            group = this._findGroup(this.data.colGroupTree, groupId[1]);\n            keyPart = 1;\n        }\n\n        const groupIdPart = groupId[keyPart];\n        const range = groupIdPart.map((_, index) => index);\n        function keep(key) {\n            const idPart = JSON.parse(key)[keyPart];\n            return (\n                range.some((index) => groupIdPart[index] !== idPart[index]) ||\n                idPart.length === groupIdPart.length\n            );\n        }\n        function omitKeys(object) {\n            const newObject = {};\n            for (const key in object) {\n                if (keep(key)) {\n                    newObject[key] = object[key];\n                }\n            }\n            return newObject;\n        }\n        this.data.measurements = omitKeys(this.data.measurements);\n        this.data.counts = omitKeys(this.data.counts);\n        this.data.groupDomains = omitKeys(this.data.groupDomains);\n\n        group.directSubTrees.clear();\n        delete group.sortedKeys;\n        var newGroupBysLength = this._getTreeHeight(tree) - 1;\n        if (newGroupBysLength <= groupBys.length) {\n            expandedGroupBys.splice(0);\n            groupBys.splice(newGroupBysLength);\n        } else {\n            expandedGroupBys.splice(newGroupBysLength - groupBys.length);\n        }\n        this.notify();\n    }\n    /**\n     * Reload the view with the current rowGroupBys and colGroupBys\n     * This is the easiest way to expand all the groups that are not expanded\n     */\n    async expandAll() {\n        const config = { metaData: this.metaData, data: this.data };\n        await this._loadData(config, false);\n        this.notify();\n    }\n    /**\n     * Expand a group by using groupBy to split it and trigger a re-rendering.\n     *\n     * @param {Object} group\n     * @param {'row'|'col'} type\n     */\n    async expandGroup(groupId, type) {\n        if (this.race.getCurrentProm()) {\n            return; // we are currently reloaded the table\n        }\n\n        const config = { metaData: this.metaData, data: this.data };\n        await this._expandGroup(groupId, type, config);\n        this.notify();\n    }\n    /**\n     * Export model data in a form suitable for an easy encoding of the pivot\n     * table in excell.\n     *\n     * @returns {Object}\n     */\n    exportData() {\n        const measureCount = this.metaData.activeMeasures.length;\n        const originCount = this.metaData.origins.length;\n\n        const table = this.getTable();\n\n        // process headers\n        const headers = table.headers;\n        let colGroupHeaderRows;\n        let measureRow = [];\n        let originRow = [];\n\n        function processHeader(header) {\n            const inTotalColumn = header.groupId[1].length === 0;\n            return {\n                title: header.title,\n                width: header.width,\n                height: header.height,\n                is_bold: !!header.measure && inTotalColumn,\n            };\n        }\n\n        if (originCount > 1) {\n            colGroupHeaderRows = headers.slice(0, headers.length - 2);\n            measureRow = headers[headers.length - 2].map(processHeader);\n            originRow = headers[headers.length - 1].map(processHeader);\n        } else {\n            colGroupHeaderRows = headers.slice(0, headers.length - 1);\n            measureRow = headers[headers.length - 1].map(processHeader);\n        }\n\n        // remove the empty headers on left side\n        colGroupHeaderRows[0].splice(0, 1);\n\n        colGroupHeaderRows = colGroupHeaderRows.map((headerRow) => {\n            return headerRow.map(processHeader);\n        });\n\n        // process rows\n        const tableRows = table.rows.map((row) => {\n            return {\n                title: row.title,\n                indent: row.indent,\n                values: row.subGroupMeasurements.map((measurement) => {\n                    let value = measurement.value;\n                    if (value === undefined) {\n                        value = \"\";\n                    } else if (measurement.originIndexes.length > 1) {\n                        // in that case the value is a variation and a\n                        // number between 0 and 1\n                        value = value * 100;\n                    }\n                    return {\n                        is_bold: measurement.isBold,\n                        value: value,\n                    };\n                }),\n            };\n        });\n\n        return {\n            model: this.metaData.resModel,\n            title: this.metaData.title,\n            col_group_headers: colGroupHeaderRows,\n            measure_headers: measureRow,\n            origin_headers: originRow,\n            rows: tableRows,\n            measure_count: measureCount,\n            origin_count: originCount,\n        };\n    }\n    /**\n     * Swap the pivot columns and the rows. The flip operation is synchronous.\n     * However, we must wait for a potential pending reload to complete before\n     * flipping the axes. This method is thus async.\n     */\n    async flip() {\n        await this.race.getCurrentProm();\n\n        // swap the data: the main column and the main row\n        let temp = this.data.rowGroupTree;\n        this.data.rowGroupTree = this.data.colGroupTree;\n        this.data.colGroupTree = temp;\n\n        // we need to update the record metaData: (expanded) row and col groupBys\n        temp = this.metaData.rowGroupBys;\n        this.metaData.rowGroupBys = this.metaData.colGroupBys;\n        this.metaData.colGroupBys = temp;\n        temp = this.metaData.expandedColGroupBys;\n        this.metaData.expandedColGroupBys = this.metaData.expandedRowGroupBys;\n        this.metaData.expandedRowGroupBys = temp;\n\n        function twistKey(key) {\n            return JSON.stringify(JSON.parse(key).reverse());\n        }\n\n        function twist(object) {\n            const newObject = {};\n            Object.keys(object).forEach((key) => {\n                const value = object[key];\n                newObject[twistKey(key)] = value;\n            });\n            return newObject;\n        }\n\n        this.data.measurements = twist(this.data.measurements);\n        this.data.counts = twist(this.data.counts);\n        this.data.groupDomains = twist(this.data.groupDomains);\n\n        this.notify();\n    }\n    /**\n     * Returns a domain representation of a group\n     *\n     * @param {Object} group\n     * @param {Array} group.colValues\n     * @param {Array} group.rowValues\n     * @param {number} group.originIndex\n     * @returns {Array[]}\n     */\n    getGroupDomain(group) {\n        const config = { metaData: this.metaData, data: this.data };\n        return this._getGroupDomain(group, config);\n    }\n    /**\n     * Returns a description of the pivot table.\n     *\n     * @returns {Object}\n     */\n    getTable() {\n        const headers = this._getTableHeaders();\n        return {\n            headers: headers,\n            rows: this._getTableRows(this.data.rowGroupTree, headers[headers.length - 1]),\n        };\n    }\n    /**\n     * Returns the total number of columns of the pivot table.\n     *\n     * @returns {integer}\n     */\n    getTableWidth() {\n        var leafCounts = this._getLeafCounts(this.data.colGroupTree);\n        return leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] + 2;\n    }\n    /**\n     * @returns {boolean} true iff there's no data in the table\n     */\n    hasData() {\n        return this._hasData(this.data);\n    }\n    /**\n     * @override\n     * @param {SearchParams} searchParams\n     */\n    async load(searchParams) {\n        this.searchParams = searchParams;\n        const processedMeasures = processMeasure(searchParams.context.pivot_measures);\n        const activeMeasures = processedMeasures || this.metaData.activeMeasures;\n        const metaData = this._buildMetaData({ activeMeasures });\n        if (!this.reload) {\n            metaData.rowGroupBys =\n                searchParams.context.pivot_row_groupby ||\n                (searchParams.groupBy.length ? searchParams.groupBy : metaData.rowGroupBys);\n            this.reload = true;\n        } else {\n            metaData.rowGroupBys = searchParams.groupBy.length\n                ? searchParams.groupBy\n                : searchParams.context.pivot_row_groupby || metaData.rowGroupBys;\n        }\n        metaData.colGroupBys =\n            searchParams.context.pivot_column_groupby || this.metaData.colGroupBys;\n\n        if (JSON.stringify(metaData.rowGroupBys) !== JSON.stringify(this.metaData.rowGroupBys)) {\n            metaData.expandedRowGroupBys = [];\n        }\n        if (JSON.stringify(metaData.colGroupBys) !== JSON.stringify(this.metaData.colGroupBys)) {\n            metaData.expandedColGroupBys = [];\n        }\n\n        const allActivesMeasures = new Set(this.metaData.activeMeasures);\n        if (processedMeasures) {\n            processedMeasures.forEach((e) => allActivesMeasures.add(e));\n        }\n\n        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [\n            ...allActivesMeasures,\n        ]);\n        const config = { metaData, data: this.data };\n        await addPropertyFieldDefs(\n            this.orm,\n            metaData.resModel,\n            searchParams.context,\n            metaData.fields,\n            new Set([...metaData.rowGroupBys, ...metaData.colGroupBys])\n        );\n        return this._loadData(config);\n    }\n    /**\n     * Sort the rows, depending on the values of a given column.  This is an\n     * in-memory sort.\n     *\n     * @param {Object} sortedColumn\n     * @param {number[]} sortedColumn.groupId\n     */\n    sortRows(sortedColumn) {\n        if (this.race.getCurrentProm()) {\n            return; // we are currently reloaded the table\n        }\n\n        const config = { metaData: this.metaData, data: this.data };\n        this._sortRows(sortedColumn, config);\n\n        this.notify();\n    }\n    /**\n     * Toggle the active state for a given measure, then reload the data\n     * if this turns out to be necessary.\n     *\n     * @param {string} fieldName\n     * @returns {Promise}\n     */\n    async toggleMeasure(fieldName) {\n        const metaData = this._buildMetaData();\n        this.nextActiveMeasures = this.nextActiveMeasures || metaData.activeMeasures;\n        metaData.activeMeasures = this.nextActiveMeasures;\n        const index = metaData.activeMeasures.indexOf(fieldName);\n        if (index !== -1) {\n            // in this case, we already have all data in memory, no need to\n            // actually reload a lesser amount of information (but still, we need\n            // to wait in case there is a pending load)\n            metaData.activeMeasures.splice(index, 1);\n            await Promise.resolve(this.race.getCurrentProm());\n            this.metaData = metaData;\n        } else {\n            metaData.activeMeasures.push(fieldName);\n            const config = { metaData, data: this.data };\n            await this._loadData(config);\n            this.useSampleModel = false;\n        }\n        this.nextActiveMeasures = null;\n        this.notify();\n    }\n\n    //--------------------------------------------------------------------------\n    // Protected\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add labels/values in the provided groupTree. A new leaf is created in\n     * the groupTree with a root object corresponding to the group with given\n     * labels/values.\n     *\n     * @protected\n     * @param {Object} groupTree, either this.data.rowGroupTree or this.data.colGroupTree\n     * @param {string[]} labels\n     * @param {Array} values\n     */\n    _addGroup(groupTree, labels, values) {\n        let tree = groupTree;\n        // we assume here that the group with value value.slice(value.length - 2) has already been added.\n        values.slice(0, values.length - 1).forEach(function (value) {\n            tree = tree.directSubTrees.get(value);\n        });\n        const value = values[values.length - 1];\n        if (tree.directSubTrees.has(value)) {\n            return;\n        }\n        tree.directSubTrees.set(value, {\n            root: {\n                labels: labels,\n                values: values,\n            },\n            directSubTrees: new Map(),\n        });\n    }\n    /**\n     * Return a copy of this.metaData, extended with optional params. This is useful\n     * for async methods that need to modify this.metaData, but it can't be done in\n     * place directly for the model to be concurrency proof (so they work on a\n     * copy and commit it at the end).\n     *\n     * @protected\n     * @param {Object} params\n     * @returns {Object}\n     */\n    _buildMetaData(params) {\n        const metaData = Object.assign({}, this.metaData, params);\n        metaData.activeMeasures = [...metaData.activeMeasures];\n        metaData.colGroupBys = [...metaData.colGroupBys];\n        metaData.rowGroupBys = [...metaData.rowGroupBys];\n        metaData.expandedColGroupBys = [...metaData.expandedColGroupBys];\n        metaData.expandedRowGroupBys = [...metaData.expandedRowGroupBys];\n        metaData.customGroupBys = new Map([...metaData.customGroupBys]);\n        // shallow copy sortedColumn because we never modify groupId in place\n        metaData.sortedColumn = metaData.sortedColumn ? { ...metaData.sortedColumn } : null;\n        if (this.searchParams.comparison) {\n            const domains = this.searchParams.comparison.domains.slice().reverse();\n            metaData.domains = domains.map((d) => d.arrayRepr);\n            metaData.origins = domains.map((d) => d.description);\n        } else {\n            metaData.domains = [this.searchParams.domain];\n            metaData.origins = [\"\"];\n        }\n        Object.defineProperty(metaData, \"fullColGroupBys\", {\n            get() {\n                return metaData.colGroupBys.concat(metaData.expandedColGroupBys);\n            },\n        });\n        Object.defineProperty(metaData, \"fullRowGroupBys\", {\n            get() {\n                return metaData.rowGroupBys.concat(metaData.expandedRowGroupBys);\n            },\n        });\n        return metaData;\n    }\n    /**\n     * Expand a group by using groupBy to split it.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {'row'|'col'} type\n     * @param {Config} config\n     */\n    async _expandGroup(groupId, type, config) {\n        const { metaData } = config;\n        const group = {\n            rowValues: groupId[0],\n            colValues: groupId[1],\n            type: type,\n        };\n        const groupValues = type === \"row\" ? groupId[0] : groupId[1];\n        const groupBys = type === \"row\" ? metaData.fullRowGroupBys : metaData.fullColGroupBys;\n        if (groupValues.length >= groupBys.length) {\n            throw new Error(\"Cannot expand group\");\n        }\n        const groupBy = groupBys[groupValues.length];\n        let leftDivisors;\n        let rightDivisors;\n        if (group.type === \"row\") {\n            leftDivisors = [[groupBy]];\n            rightDivisors = sections(metaData.fullColGroupBys);\n        } else {\n            leftDivisors = sections(metaData.fullRowGroupBys);\n            rightDivisors = [[groupBy]];\n        }\n        const divisors = cartesian(leftDivisors, rightDivisors);\n        delete group.type;\n        await this._subdivideGroup(group, divisors, config);\n    }\n    /**\n     * Find a group with given values in the provided groupTree, either\n     * this.rowGrouptree or this.data.colGroupTree.\n     *\n     * @protected\n     * @param {Object} groupTree\n     * @param {Array} values\n     * @returns {Object}\n     */\n    _findGroup(groupTree, values) {\n        let tree = groupTree;\n        values.slice(0, values.length).forEach((value) => {\n            tree = tree.directSubTrees.get(value);\n        });\n        return tree;\n    }\n    /**\n     * In case originIndex is an array of length 1, thus a single origin\n     * index, returns the given measure for a group determined by the id\n     * groupId and the origin index.\n     * If originIndexes is an array of length 2, we compute the variation\n     * of the measure values for the groups determined by groupId and the\n     * different origin indexes.\n     *\n     * @protected\n     * @param {Array[]} groupId\n     * @param {string} measure\n     * @param {number[]} originIndexes\n     * @param {Config} config\n     * @returns {number}\n     */\n    _getCellValue(groupId, measure, originIndexes, config) {\n        var key = JSON.stringify(groupId);\n        if (!config.data.measurements[key]) {\n            return;\n        }\n        var values = originIndexes.map((originIndex) => {\n            return config.data.measurements[key][originIndex][measure];\n        });\n        if (originIndexes.length > 1) {\n            return computeVariation(values[1], values[0]);\n        } else {\n            return values[0];\n        }\n    }\n    /**\n     * @protected\n     * @param {string[]} rowGroupBy\n     * @param {string[]} colGroupBy\n     * @returns {string[]}\n     */\n    _getGroupBySpecs(rowGroupBy, colGroupBy) {\n        const set = rowGroupBy.concat(colGroupBy).reduce((acc, gb) => {\n            acc.add(this._normalize(gb));\n            return acc;\n        }, new Set());\n        return [...set];\n    }\n    /**\n     * Returns a domain representation of a group\n     *\n     * @protected\n     * @param {Object} group\n     * @param {Array} group.colValues\n     * @param {Array} group.rowValues\n     * @param {number} group.originIndex\n     * @param {Config} config\n     * @returns {Array[]}\n     */\n    _getGroupDomain(group, config) {\n        const { data } = config;\n        var key = JSON.stringify([group.rowValues, group.colValues]);\n        return data.groupDomains[key][group.originIndex];\n    }\n    /**\n     * Returns the group sanitized labels.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {string[]} groupBys\n     * @param {Config} config\n     * @returns {string[]}\n     */\n    _getGroupLabels(group, groupBys, config) {\n        return groupBys.map((gb) => {\n            const groupBy = this._normalize(gb);\n            return this._sanitizeLabel(group[groupBy], groupBy, config);\n        });\n    }\n    /**\n     * Returns a promise that returns the annotated read_group results\n     * corresponding to a partition of the given group obtained using the given\n     * rowGroupBy and colGroupBy.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {string[]} rowGroupBy\n     * @param {string[]} colGroupBy\n     * @param {Object} params\n     */\n    async _getGroupSubdivision(group, rowGroupBy, colGroupBy, params) {\n        const groupBy = this._getGroupBySpecs(rowGroupBy, colGroupBy);\n        const subGroups = await this._getSubGroups(groupBy, params);\n        return {\n            group,\n            subGroups,\n            rowGroupBy: rowGroupBy,\n            colGroupBy: colGroupBy,\n        };\n    }\n\n    /**\n     * Returns the group sanitized values.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {string[]} groupBys\n     * @returns {Array}\n     */\n    _getGroupValues(group, groupBys) {\n        return groupBys.map((gb) => {\n            const groupBy = this._normalize(gb);\n            return this._sanitizeValue(group[groupBy]);\n        });\n    }\n    /**\n     * Returns the leaf counts of each group inside the given tree.\n     *\n     * @protected\n     * @param {Object} tree\n     * @returns {Object} keys are group ids\n     */\n    _getLeafCounts(tree) {\n        const leafCounts = {};\n        let leafCount;\n        if (!tree.directSubTrees.size) {\n            leafCount = 1;\n        } else {\n            leafCount = [...tree.directSubTrees.values()].reduce((acc, subTree) => {\n                const subLeafCounts = this._getLeafCounts(subTree);\n                Object.assign(leafCounts, subLeafCounts);\n                return acc + leafCounts[JSON.stringify(subTree.root.values)];\n            }, 0);\n        }\n\n        leafCounts[JSON.stringify(tree.root.values)] = leafCount;\n        return leafCounts;\n    }\n    /**\n     * Returns the group sanitized measure values for the measures in\n     * this.metaData.activeMeasures (that migth contain '__count', not really a fieldName).\n     *\n     * @protected\n     * @param {Object} group\n     * @param {Config} config\n     * @returns {Array}\n     */\n    _getMeasurements(group, config) {\n        const { metaData } = config;\n        return metaData.activeMeasures.reduce((measurements, measureName) => {\n            var measurement = group[measureName];\n            if (measurement instanceof Array) {\n                // case field is many2one and used as measure and groupBy simultaneously\n                measurement = 1;\n            }\n            if (\n                metaData.measures[measureName].type === \"boolean\" &&\n                measurement instanceof Boolean\n            ) {\n                measurement = measurement ? 1 : 0;\n            }\n            if (metaData.origins.length > 1 && !measurement) {\n                measurement = 0;\n            }\n            measurements[measureName] = measurement;\n            return measurements;\n        }, {});\n    }\n    /**\n     * Returns a description of the measures row of the pivot table\n     *\n     * @protected\n     * @param {Object[]} columns for which measure cells must be generated\n     * @returns {Object[]}\n     */\n    _getMeasuresRow(columns) {\n        const sortedColumn = this.metaData.sortedColumn || {};\n        const measureRow = [];\n\n        columns.forEach((column) => {\n            this.metaData.activeMeasures.forEach((measureName) => {\n                const measureCell = {\n                    groupId: column.groupId,\n                    height: 1,\n                    measure: measureName,\n                    title: this.metaData.measures[measureName].string,\n                    width: 2 * this.metaData.origins.length - 1,\n                };\n                if (\n                    sortedColumn.measure === measureName &&\n                    JSON.stringify(sortedColumn.groupId) === JSON.stringify(column.groupId) // FIXME\n                ) {\n                    measureCell.order = sortedColumn.order;\n                }\n                measureRow.push(measureCell);\n            });\n        });\n\n        return measureRow;\n    }\n    /**\n     * Returns the list of measure specs associated with metaData.activeMeasures, i.e.\n     * a measure 'fieldName' becomes 'fieldName:aggregator' where\n     * aggregator is the value specified on the field 'fieldName' for\n     * the key aggregator.\n     *\n     * @protected\n     * @param {Config} config\n     * @return {string[]}\n     */\n    _getMeasureSpecs(config) {\n        const { metaData } = config;\n        return metaData.activeMeasures.reduce((acc, measure) => {\n            if (measure === \"__count\") {\n                acc.push(measure);\n                return acc;\n            }\n            const field = this.metaData.fields[measure];\n            if (field.type === \"many2one\") {\n                field.aggregator = \"count_distinct\";\n            }\n            if (field.aggregator === undefined) {\n                throw new Error(\n                    \"No aggregate function has been provided for the measure '\" + measure + \"'\"\n                );\n            }\n            acc.push(measure + \":\" + field.aggregator);\n            return acc;\n        }, []);\n    }\n    /**\n     * Make sure that the labels of different many2one values are distinguished\n     * by numbering them if necessary.\n     *\n     * @protected\n     * @param {Array} label\n     * @param {string} fieldName\n     * @param {Config} config\n     * @returns {string}\n     */\n    _getNumberedLabel(label, fieldName, config) {\n        const { data } = config;\n        const id = label[0];\n        const name = label[1];\n        data.numbering[fieldName] = data.numbering[fieldName] || {};\n        data.numbering[fieldName][name] = data.numbering[fieldName][name] || {};\n        const numbers = data.numbering[fieldName][name];\n        numbers[id] = numbers[id] || Object.keys(numbers).length + 1;\n        return name + (numbers[id] > 1 ? \"  (\" + numbers[id] + \")\" : \"\");\n    }\n    /**\n     * Returns a description of the origins row of the pivot table\n     *\n     * @protected\n     * @param {Object[]} columns for which origin cells must be generated\n     * @returns {Object[]}\n     */\n    _getOriginsRow(columns) {\n        const sortedColumn = this.metaData.sortedColumn || {};\n        const originRow = [];\n\n        columns.forEach((column) => {\n            const groupId = column.groupId;\n            const measure = column.measure;\n            const isSorted =\n                sortedColumn.measure === measure &&\n                JSON.stringify(sortedColumn.groupId) === JSON.stringify(groupId); // FIXME\n            const isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];\n            const isSortedByVariation = isSorted && sortedColumn.originIndexes[1];\n\n            this.metaData.origins.forEach((origin, originIndex) => {\n                const originCell = {\n                    groupId: groupId,\n                    height: 1,\n                    measure: measure,\n                    originIndexes: [originIndex],\n                    title: origin,\n                    width: 1,\n                };\n                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {\n                    originCell.order = sortedColumn.order;\n                }\n                originRow.push(originCell);\n\n                if (originIndex > 0) {\n                    const variationCell = {\n                        groupId: groupId,\n                        height: 1,\n                        measure: measure,\n                        originIndexes: [originIndex - 1, originIndex],\n                        title: _t(\"Variation\"),\n                        width: 1,\n                    };\n                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {\n                        variationCell.order = sortedColumn.order;\n                    }\n                    originRow.push(variationCell);\n                }\n            });\n        });\n\n        return originRow;\n    }\n    /**\n     * @protected\n     * @param {string[]} groupBy\n     * @param {Object} params\n     * @returns {Promise<Object[]>}\n     */\n    async _getSubGroups(groupBy, params) {\n        const { resModel, groupDomain, measureSpecs, kwargs, mapping } = params;\n        const key = JSON.stringify(groupBy);\n        if (!mapping[key]) {\n            mapping[key] = this.orm.readGroup(resModel, groupDomain, measureSpecs, groupBy, kwargs);\n        }\n        return mapping[key];\n    }\n    /**\n     * Returns the list of header rows of the pivot table: the col group rows\n     * (depending on the col groupbys), the measures row and optionnaly the\n     * origins row (if there are more than one origins).\n     *\n     * @protected\n     * @returns {Object[]}\n     */\n    _getTableHeaders() {\n        const colGroupBys = this.metaData.fullColGroupBys;\n        const height = colGroupBys.length + 1;\n        const measureCount = this.metaData.activeMeasures.length;\n        const originCount = this.metaData.origins.length;\n        const leafCounts = this._getLeafCounts(this.data.colGroupTree);\n        let headers = [];\n        const measureColumns = []; // used to generate the measure cells\n\n        // 1) generate col group rows (total row + one row for each col groupby)\n        const colGroupRows = new Array(height).fill(0).map(() => []);\n        // blank top left cell\n        colGroupRows[0].push({\n            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]\n            title: \"\",\n            width: 1,\n        });\n\n        // col groupby cells with group values\n        /**\n         * Recursive function that generates the header cells corresponding to\n         * the groups of a given tree.\n         *\n         * @param {Object} tree\n         */\n        function generateTreeHeaders(tree, fields) {\n            const group = tree.root;\n            const rowIndex = group.values.length;\n            const row = colGroupRows[rowIndex];\n            const groupId = [[], group.values];\n            const isLeaf = !tree.directSubTrees.size;\n            const leafCount = leafCounts[JSON.stringify(tree.root.values)];\n            const cell = {\n                groupId: groupId,\n                height: isLeaf ? colGroupBys.length + 1 - rowIndex : 1,\n                isLeaf: isLeaf,\n                isFolded: isLeaf && colGroupBys.length > group.values.length,\n                label:\n                    rowIndex === 0\n                        ? undefined\n                        : fields[colGroupBys[rowIndex - 1].split(\":\")[0]].string,\n                title: group.labels.length ? group.labels[group.labels.length - 1] : _t(\"Total\"),\n                width: leafCount * measureCount * (2 * originCount - 1),\n            };\n            row.push(cell);\n            if (isLeaf) {\n                measureColumns.push(cell);\n            }\n\n            [...tree.directSubTrees.values()].forEach((subTree) => {\n                generateTreeHeaders(subTree, fields);\n            });\n        }\n\n        generateTreeHeaders(this.data.colGroupTree, this.metaData.fields);\n        // blank top right cell for 'Total' group (if there is more that one leaf)\n        if (leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] > 1) {\n            var groupId = [[], []];\n            var totalTopRightCell = {\n                groupId: groupId,\n                height: height,\n                title: \"\",\n                width: measureCount * (2 * originCount - 1),\n            };\n            colGroupRows[0].push(totalTopRightCell);\n            measureColumns.push(totalTopRightCell);\n        }\n        headers = headers.concat(colGroupRows);\n\n        // 2) generate measures row\n        var measuresRow = this._getMeasuresRow(measureColumns);\n        headers.push(measuresRow);\n\n        // 3) generate origins row if more than one origin\n        if (originCount > 1) {\n            headers.push(this._getOriginsRow(measuresRow));\n        }\n\n        return headers;\n    }\n    /**\n     * Returns the list of body rows of the pivot table for a given tree.\n     *\n     * @protected\n     * @param {Object} tree\n     * @param {Object[]} columns\n     * @returns {Object[]}\n     */\n    _getTableRows(tree, columns) {\n        let rows = [];\n        const group = tree.root;\n        const rowGroupId = [group.values, []];\n        const title = group.labels.length ? group.labels[group.labels.length - 1] : _t(\"Total\");\n        const indent = group.labels.length;\n        const isLeaf = !tree.directSubTrees.size;\n        const rowGroupBys = this.metaData.fullRowGroupBys;\n\n        const subGroupMeasurements = columns.map((column) => {\n            const colGroupId = column.groupId;\n            const groupIntersectionId = [rowGroupId[0], colGroupId[1]];\n            const measure = column.measure;\n            const originIndexes = column.originIndexes || [0];\n\n            const value = this._getCellValue(groupIntersectionId, measure, originIndexes, {\n                data: this.data,\n            });\n\n            const measurement = {\n                groupId: groupIntersectionId,\n                originIndexes: originIndexes,\n                measure: measure,\n                value: value,\n                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,\n            };\n            return measurement;\n        });\n\n        rows.push({\n            title: title,\n            label:\n                indent === 0\n                    ? undefined\n                    : this.metaData.fields[rowGroupBys[indent - 1].split(\":\")[0]].string,\n            groupId: rowGroupId,\n            indent: indent,\n            isLeaf: isLeaf,\n            isFolded: isLeaf && rowGroupBys.length > group.values.length,\n            subGroupMeasurements: subGroupMeasurements,\n        });\n\n        const subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];\n        subTreeKeys.forEach((subTreeKey) => {\n            const subTree = tree.directSubTrees.get(subTreeKey);\n            rows = rows.concat(this._getTableRows(subTree, columns));\n        });\n\n        return rows;\n    }\n    /**\n     * returns the height of a given groupTree\n     *\n     * @protected\n     * @param {Object} tree, a groupTree\n     * @returns {number}\n     */\n    _getTreeHeight(tree) {\n        const subTreeHeights = [...tree.directSubTrees.values()].map(\n            this._getTreeHeight.bind(this)\n        );\n        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;\n    }\n    /**\n     * @protected\n     * @param {Data} data\n     * @returns {boolean} true iff there's no data in the table\n     */\n    _hasData(data) {\n        return (data.counts[JSON.stringify([[], []])] || []).some((count) => {\n            return count > 0;\n        });\n    }\n    /**\n     * Initialize/Reinitialize data.rowGroupTree, colGroupTree, measurements,\n     * counts and subdivide the group 'Total' as many times it is necessary.\n     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in\n     * order to see if there is data in the intersection of the group 'Total'\n     * and the various origins. In case there is none, non supplementary rpc\n     * will be done (see the code of subdivideGroup).\n     *\n     * @protected\n     * @param {Config} config\n     */\n    async _loadData(config, prune = true) {\n        config.data = {}; // data will be completely recomputed\n        const { data, metaData } = config;\n        data.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        data.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        data.measurements = {};\n        data.counts = {};\n        data.groupDomains = {};\n        data.numbering = {};\n        const key = JSON.stringify([[], []]);\n        data.groupDomains[key] = metaData.domains.slice(0);\n\n        const group = { rowValues: [], colValues: [] };\n        const leftDivisors = sections(metaData.fullRowGroupBys);\n        const rightDivisors = sections(metaData.fullColGroupBys);\n        const divisors = cartesian(leftDivisors, rightDivisors);\n\n        await this._subdivideGroup(group, divisors.slice(0, 1), config);\n        await this._subdivideGroup(group, divisors.slice(1), config);\n\n        // keep folded groups folded after the reload if the structure of the table is the same\n        if (prune && this._hasData(data) && this._hasData(this.data)) {\n            if (\n                symmetricalDifference(metaData.rowGroupBys, this.metaData.rowGroupBys).length === 0\n            ) {\n                this._pruneTree(data.rowGroupTree, this.data.rowGroupTree);\n            }\n            if (\n                symmetricalDifference(metaData.colGroupBys, this.metaData.colGroupBys).length === 0\n            ) {\n                this._pruneTree(data.colGroupTree, this.data.colGroupTree);\n            }\n        }\n\n        this.data = config.data;\n        this.metaData = config.metaData;\n    }\n    /**\n     * @protected\n     * @param {string} gb\n     * @returns {string}\n     */\n    _normalize(gb) {\n        const [fieldName, interval] = gb.split(\":\");\n        const field = this.metaData.fields[fieldName];\n        if ([\"date\", \"datetime\"].includes(field.type)) {\n            return `${fieldName}:${interval || \"month\"}`;\n        } else {\n            return fieldName;\n        }\n    }\n    /**\n     * Extract the information in the read_group results (groupSubdivisions)\n     * and develop this.data.rowGroupTree, colGroupTree, measurements, counts, and\n     * groupDomains.\n     * If a column needs to be sorted, the rowGroupTree corresponding to the\n     * group is sorted.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {Object[]} groupSubdivisions\n     * @param {Config} config\n     */\n    _prepareData(group, groupSubdivisions, config) {\n        const { data, metaData } = config;\n        const groupRowValues = group.rowValues;\n        let groupRowLabels = [];\n        let rowSubTree = data.rowGroupTree;\n        let root;\n        if (groupRowValues.length) {\n            // we should have labels information on hand! regretful!\n            rowSubTree = this._findGroup(data.rowGroupTree, groupRowValues);\n            root = rowSubTree.root;\n            groupRowLabels = root.labels;\n        }\n\n        const groupColValues = group.colValues;\n        let groupColLabels = [];\n        if (groupColValues.length) {\n            root = this._findGroup(data.colGroupTree, groupColValues).root;\n            groupColLabels = root.labels;\n        }\n\n        groupSubdivisions.forEach((groupSubdivision) => {\n            groupSubdivision.subGroups.forEach((subGroup) => {\n                const rowValues = groupRowValues.concat(\n                    this._getGroupValues(subGroup, groupSubdivision.rowGroupBy)\n                );\n                const rowLabels = groupRowLabels.concat(\n                    this._getGroupLabels(subGroup, groupSubdivision.rowGroupBy, config)\n                );\n\n                const colValues = groupColValues.concat(\n                    this._getGroupValues(subGroup, groupSubdivision.colGroupBy)\n                );\n                const colLabels = groupColLabels.concat(\n                    this._getGroupLabels(subGroup, groupSubdivision.colGroupBy, config)\n                );\n\n                if (!colValues.length && rowValues.length) {\n                    this._addGroup(data.rowGroupTree, rowLabels, rowValues);\n                }\n                if (colValues.length && !rowValues.length) {\n                    this._addGroup(data.colGroupTree, colLabels, colValues);\n                }\n\n                const key = JSON.stringify([rowValues, colValues]);\n                const originIndex = groupSubdivision.group.originIndex;\n\n                if (!(key in data.measurements)) {\n                    data.measurements[key] = metaData.origins.map(() => {\n                        return this._getMeasurements({}, config);\n                    });\n                }\n                data.measurements[key][originIndex] = this._getMeasurements(subGroup, config);\n\n                if (!(key in data.counts)) {\n                    data.counts[key] = metaData.origins.map(function () {\n                        return 0;\n                    });\n                }\n                data.counts[key][originIndex] = subGroup.__count;\n\n                if (!(key in data.groupDomains)) {\n                    data.groupDomains[key] = metaData.origins.map(function () {\n                        return Domain.FALSE.toList();\n                    });\n                }\n                // if __domain is not defined this means that we are in the\n                // case where\n                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []\n                if (subGroup.__domain) {\n                    data.groupDomains[key][originIndex] = subGroup.__domain;\n                }\n            });\n        });\n\n        if (metaData.sortedColumn) {\n            this._sortRows(metaData.sortedColumn, config);\n        }\n    }\n    /**\n     * Make any group in tree a leaf if it was a leaf in oldTree.\n     *\n     * @protected\n     * @param {Object} tree\n     * @param {Object} oldTree\n     */\n    _pruneTree(tree, oldTree) {\n        if (!oldTree.directSubTrees.size) {\n            tree.directSubTrees.clear();\n            delete tree.sortedKeys;\n            return;\n        }\n        [...tree.directSubTrees.keys()].forEach((subTreeKey) => {\n            const subTree = tree.directSubTrees.get(subTreeKey);\n            if (!oldTree.directSubTrees.has(subTreeKey)) {\n                subTree.directSubTrees.clear();\n                delete subTree.sortedKeys;\n            } else {\n                const oldSubTree = oldTree.directSubTrees.get(subTreeKey);\n                this._pruneTree(subTree, oldSubTree);\n            }\n        });\n    }\n\n    _getEmptyGroupLabel(fieldName) {\n        return _t(\"None\");\n    }\n\n    /**\n     * Extract from a groupBy value a label.\n     *\n     * @protected\n     * @param {any} value\n     * @param {string} groupBy\n     * @param {Config} config\n     * @returns {string}\n     */\n    _sanitizeLabel(value, groupBy, config) {\n        const { metaData } = config;\n        const fieldName = groupBy.split(\":\")[0];\n        if (\n            fieldName &&\n            metaData.fields[fieldName] &&\n            metaData.fields[fieldName].type === \"boolean\"\n        ) {\n            return value === undefined ? _t(\"None\") : value ? _t(\"Yes\") : _t(\"No\");\n        }\n        if (value === false) {\n            return this._getEmptyGroupLabel(fieldName);\n        }\n        if (value instanceof Array) {\n            return this._getNumberedLabel(value, fieldName, config);\n        }\n        if (\n            fieldName &&\n            metaData.fields[fieldName] &&\n            metaData.fields[fieldName].type === \"selection\"\n        ) {\n            const selected = metaData.fields[fieldName].selection.find((o) => o[0] === value);\n            return selected ? selected[1] : value; // selected should be truthy normally ?!\n        }\n        return value;\n    }\n    /**\n     * Extract from a groupBy value the raw value of that groupBy (discarding\n     * a label if any)\n     *\n     * @protected\n     * @param {any} value\n     * @returns {any}\n     */\n    _sanitizeValue(value) {\n        if (value instanceof Array) {\n            return value[0];\n        }\n        return value;\n    }\n    /**\n     * Get all partitions of a given group using the provided list of divisors\n     * and enrich the objects of this.data.rowGroupTree, colGroupTree,\n     * measurements, counts.\n     *\n     * @protected\n     * @param {Object} group\n     * @param {Array[]} divisors\n     * @param {Config} config\n     */\n    async _subdivideGroup(group, divisors, config) {\n        const { data, metaData } = config;\n        const key = JSON.stringify([group.rowValues, group.colValues]);\n\n        const proms = metaData.origins.reduce((acc, origin, originIndex) => {\n            // if no information on group content is available, we fetch data.\n            // if group is known to be empty for the given origin,\n            // we don't need to fetch data for that origin.\n            if (!data.counts[key] || data.counts[key][originIndex] > 0) {\n                const subGroup = {\n                    rowValues: group.rowValues,\n                    colValues: group.colValues,\n                    originIndex: originIndex,\n                };\n                const groupDomain = this._getGroupDomain(subGroup, config);\n                const measureSpecs = this._getMeasureSpecs(config);\n                const resModel = config.metaData.resModel;\n                const kwargs = { lazy: false, context: this.searchParams.context };\n                const mapping = {};\n                divisors.forEach((divisor) => {\n                    acc.push(\n                        this._getGroupSubdivision(subGroup, divisor[0], divisor[1], {\n                            resModel,\n                            groupDomain,\n                            measureSpecs,\n                            kwargs,\n                            mapping,\n                        })\n                    );\n                });\n            }\n            return acc;\n        }, []);\n        const groupSubdivisions = await this.keepLast.add(Promise.all(proms));\n        if (groupSubdivisions.length) {\n            this._prepareData(group, groupSubdivisions, config);\n        }\n    }\n    /**\n     * Sort the rows, depending on the values of a given column.  This is an\n     * in-memory sort.\n     *\n     * @protected\n     * @param {Object} sortedColumn\n     * @param {number[]} sortedColumn.groupId\n     * @param {Config} config\n     */\n    _sortRows(sortedColumn, config) {\n        const metaData = config.metaData || this.metaData;\n        const data = config.data || this.data;\n        const colGroupValues = sortedColumn.groupId[1];\n        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];\n        metaData.sortedColumn = sortedColumn;\n\n        const sortFunction = (tree) => {\n            return (subTreeKey) => {\n                const subTree = tree.directSubTrees.get(subTreeKey);\n                const groupIntersectionId = [subTree.root.values, colGroupValues];\n                const value =\n                    this._getCellValue(\n                        groupIntersectionId,\n                        sortedColumn.measure,\n                        sortedColumn.originIndexes,\n                        { data }\n                    ) || 0;\n                return sortedColumn.order === \"asc\" ? value : -value;\n            };\n        };\n\n        this._sortTree(sortFunction, data.rowGroupTree);\n    }\n    /**\n     * Sort recursively the subTrees of tree using sortFunction.\n     * In the end each node of the tree has its direct children sorted\n     * according to the criterion reprensented by sortFunction.\n     *\n     * @protected\n     * @param {Function} sortFunction\n     * @param {Object} tree\n     */\n    _sortTree(sortFunction, tree) {\n        tree.sortedKeys = sortBy([...tree.directSubTrees.keys()], sortFunction(tree));\n        [...tree.directSubTrees.values()].forEach((subTree) => {\n            this._sortTree(sortFunction, subTree);\n        });\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport { CheckBox } from \"@web/core/checkbox/checkbox\";\nimport { localization } from \"@web/core/l10n/localization\";\nimport { registry } from \"@web/core/registry\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { formatPercentage } from \"@web/views/fields/formatters\";\nimport { PivotHeader } from \"@web/views/pivot/pivot_header\";\n\nimport { Component, onWillUpdateProps, useRef } from \"@odoo/owl\";\nimport { download } from \"@web/core/network/download\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { ReportViewMeasures } from \"@web/views/view_components/report_view_measures\";\n\nconst formatters = registry.category(\"formatters\");\n\nexport class PivotRenderer extends Component {\n    static template = \"web.PivotRenderer\";\n    static components = { Dropdown, DropdownItem, CheckBox, PivotHeader, ReportViewMeasures };\n    static props = [\"model\", \"buttonTemplate\"];\n\n    setup() {\n        this.actionService = useService(\"action\");\n        this.model = this.props.model;\n        this.table = this.model.getTable();\n        this.l10n = localization;\n        this.tableRef = useRef(\"table\");\n\n        onWillUpdateProps(this.onWillUpdateProps);\n    }\n    onWillUpdateProps() {\n        this.table = this.model.getTable();\n    }\n    /**\n     * Get the formatted value of the cell.\n     *\n     * @private\n     * @param {Object} cell\n     * @returns {string} Formatted value\n     */\n    getFormattedValue(cell) {\n        const field = this.model.metaData.measures[cell.measure];\n        let formatType = this.model.metaData.widgets[cell.measure];\n        if (!formatType) {\n            const fieldType = field.type;\n            formatType = [\"many2one\", \"reference\"].includes(fieldType) ? \"integer\" : fieldType;\n        }\n        const formatter = formatters.get(formatType);\n        return formatter(cell.value, field);\n    }\n    /**\n     * Get the formatted variation of a cell.\n     *\n     * @private\n     * @param {Object} cell\n     * @returns {string} Formatted variation\n     */\n    getFormattedVariation(cell) {\n        if (isNaN(cell.value)) {\n            return \"-\";\n        }\n        return formatPercentage(cell.value, this.model.metaData.fields[cell.measure]);\n    }\n\n    getHeaderProps({ cell, isXAxis = false, isInHead = false }) {\n        const type = isXAxis ? \"col\" : \"row\";\n        return {\n            cell,\n            isXAxis,\n            isInHead,\n            customGroupBys: this.model.metaData.customGroupBys,\n            onItemSelected: (payload) => this.onGroupBySelected(type, payload),\n            onAddCustomGroupBy: (fieldName) =>\n                this.onAddCustomGroupBy(type, cell.groupId, fieldName),\n            onClick: () => this.onHeaderClick(cell, type),\n        };\n    }\n\n    //----------------------------------------------------------------------\n    // Handlers\n    //----------------------------------------------------------------------\n\n    /**\n     * Handle the adding of a custom groupby (inside the view, not the searchview).\n     *\n     * @param {\"col\"|\"row\"} type\n     * @param {Array[]} groupId\n     * @param {string} fieldName\n     */\n    onAddCustomGroupBy(type, groupId, fieldName) {\n        this.model.addGroupBy({ groupId, fieldName, custom: true, type });\n    }\n\n    /**\n     * Handle the selection of a groupby dropdown item.\n     *\n     * @param {\"col\"|\"row\"} type\n     * @param {Object} payload\n     */\n    onGroupBySelected(type, payload) {\n        this.model.addGroupBy({ ...payload, type });\n    }\n    /**\n     * Handle a click on a header cell.\n     *\n     * @param {Object} cell\n     * @param {string} type col or row\n     */\n    onHeaderClick(cell, type) {\n        if (cell.isLeaf && cell.isFolded) {\n            this.model.expandGroup(cell.groupId, type);\n        } else if (!cell.isLeaf) {\n            this.model.closeGroup(cell.groupId, type);\n        }\n    }\n    /**\n     * Handle a click on a measure cell.\n     *\n     * @param {Object} cell\n     */\n    onMeasureClick(cell) {\n        this.model.sortRows({\n            groupId: cell.groupId,\n            measure: cell.measure,\n            order: (cell.order || \"desc\") === \"asc\" ? \"desc\" : \"asc\",\n            originIndexes: cell.originIndexes,\n        });\n    }\n    /**\n     * Hover the column in which the mouse is.\n     *\n     * @param {MouseEvent} ev\n     */\n    onMouseEnter(ev) {\n        var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);\n        if (ev.currentTarget.tagName === \"TH\") {\n            if (\n                !ev.currentTarget.classList.contains(\"o_pivot_origin_row\") &&\n                this.model.metaData.origins.length === 2\n            ) {\n                index = 3 * index; // two origins + comparison column\n            }\n            index += 1; // row groupbys column\n        }\n        this.tableRef.el\n            .querySelectorAll(\"td:nth-child(\" + (index + 1) + \")\")\n            .forEach((elt) => elt.classList.add(\"o_cell_hover\"));\n    }\n    /**\n     * Remove the hover on the columns.\n     */\n    onMouseLeave() {\n        this.tableRef.el\n            .querySelectorAll(\".o_cell_hover\")\n            .forEach((elt) => elt.classList.remove(\"o_cell_hover\"));\n    }\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Exports the current pivot table data in a xls file. For this, we have to\n     * serialize the current state, then call the server /web/pivot/export_xlsx.\n     * Force a reload before exporting to ensure to export up-to-date data.\n     */\n    onDownloadButtonClicked() {\n        if (this.model.getTableWidth() > 16384) {\n            throw new Error(\n                _t(\n                    \"For Excel compatibility, data cannot be exported if there are more than 16384 columns.\\n\\nTip: try to flip axis, filter further or reduce the number of measures.\"\n                )\n            );\n        }\n        const table = this.model.exportData();\n        download({\n            url: \"/web/pivot/export_xlsx\",\n            data: { data: new Blob([JSON.stringify(table)], { type: \"application/json\" }) },\n        });\n    }\n    /**\n     * Expands all groups\n     */\n    onExpandButtonClicked() {\n        this.model.expandAll();\n    }\n    /**\n     * Flips axis\n     */\n    onFlipButtonClicked() {\n        this.model.flip();\n    }\n    /**\n     * Toggles the given measure\n     *\n     * @param {Object} param0\n     * @param {string} param0.measure\n     */\n    onMeasureSelected({ measure }) {\n        this.model.toggleMeasure(measure);\n    }\n    /**\n     * Execute the action to open the view on the current model.\n     *\n     * @param {Array} domain\n     * @param {Array} views\n     * @param {Object} context\n     */\n    openView(domain, views, context) {\n        this.actionService.doAction({\n            type: \"ir.actions.act_window\",\n            name: this.model.metaData.title,\n            res_model: this.model.metaData.resModel,\n            views: views,\n            view_mode: \"list\",\n            target: \"current\",\n            context,\n            domain,\n        });\n    }\n    /**\n     * @param {CustomEvent} ev\n     */\n    onOpenView(cell) {\n        if (cell.value === undefined || this.model.metaData.disableLinking) {\n            return;\n        }\n\n        const context = Object.assign({}, this.model.searchParams.context);\n        Object.keys(context).forEach((x) => {\n            if (x === \"group_by\" || x.startsWith(\"search_default_\")) {\n                delete context[x];\n            }\n        });\n\n        // retrieve form and list view ids from the action\n        const { views = [] } = this.env.config;\n        this.views = [\"list\", \"form\"].map((viewType) => {\n            const view = views.find((view) => view[1] === viewType);\n            return [view ? view[0] : false, viewType];\n        });\n\n        const group = {\n            rowValues: cell.groupId[0],\n            colValues: cell.groupId[1],\n            originIndex: cell.originIndexes[0],\n        };\n        this.openView(this.model.getGroupDomain(group), this.views, context);\n    }\n}\n", "import { SearchModel } from \"@web/search/search_model\";\n\nexport class PivotSearchModel extends SearchModel {\n    _getIrFilterDescription() {\n        this.preparingIrFilterDescription = true;\n        const result = super._getIrFilterDescription(...arguments);\n        this.preparingIrFilterDescription = false;\n        return result;\n    }\n\n    _getSearchItemGroupBys(activeItem) {\n        const { searchItemId } = activeItem;\n        const { context, type } = this.searchItems[searchItemId];\n        if (\n            !this.preparingIrFilterDescription &&\n            type === \"favorite\" &&\n            context.pivot_row_groupby\n        ) {\n            return context.pivot_row_groupby;\n        }\n        return super._getSearchItemGroupBys(...arguments);\n    }\n}\n", "import { _t } from \"@web/core/l10n/translation\";\nimport { registry } from \"@web/core/registry\";\nimport { PivotArchParser } from \"@web/views/pivot/pivot_arch_parser\";\nimport { PivotController } from \"./pivot_controller\";\nimport { PivotModel } from \"@web/views/pivot/pivot_model\";\nimport { PivotRenderer } from \"@web/views/pivot/pivot_renderer\";\nimport { PivotSearchModel } from \"./pivot_search_model\";\n\nconst viewRegistry = registry.category(\"views\");\n\nexport const pivotView = {\n    type: \"pivot\",\n    Controller: PivotController,\n    Renderer: PivotRenderer,\n    Model: PivotModel,\n    ArchParser: PivotArchParser,\n    SearchModel: PivotSearchModel,\n    searchMenuTypes: [\"filter\", \"groupBy\", \"comparison\", \"favorite\"],\n    buttonTemplate: \"web.PivotView.Buttons\",\n\n    props: (genericProps, view) => {\n        const modelParams = {};\n        if (genericProps.state) {\n            modelParams.data = genericProps.state.data;\n            modelParams.metaData = genericProps.state.metaData;\n        } else {\n            const { arch, fields, resModel } = genericProps;\n\n            // parse arch\n            const archInfo = new view.ArchParser().parse(arch);\n\n            if (!archInfo.activeMeasures.length || archInfo.displayQuantity) {\n                archInfo.activeMeasures.unshift(\"__count\");\n            }\n\n            modelParams.metaData = {\n                activeMeasures: archInfo.activeMeasures,\n                colGroupBys: archInfo.colGroupBys,\n                defaultOrder: archInfo.defaultOrder,\n                disableLinking: Boolean(archInfo.disableLinking),\n                fields: fields,\n                fieldAttrs: archInfo.fieldAttrs,\n                resModel: resModel,\n                rowGroupBys: archInfo.rowGroupBys,\n                title: archInfo.title || _t(\"Untitled\"),\n                widgets: archInfo.widgets,\n            };\n        }\n\n        return {\n            ...genericProps,\n            Model: view.Model,\n            modelParams,\n            Renderer: view.Renderer,\n            buttonTemplate: view.buttonTemplate,\n        };\n    },\n};\n\nviewRegistry.add(\"pivot\", pivotView);\n", "import { visitXML } from \"@web/core/utils/xml\";\nimport { Field } from \"@web/views/fields/field\";\n\nexport class ActivityArchParser {\n    parse(xmlDoc, models, modelName) {\n        const jsClass = xmlDoc.getAttribute(\"js_class\");\n        const title = xmlDoc.getAttribute(\"string\");\n\n        const fieldNodes = {};\n        const templateDocs = {};\n        const fieldNextIds = {};\n\n        visitXML(xmlDoc, (node) => {\n            if (node.hasAttribute(\"t-name\")) {\n                templateDocs[node.getAttribute(\"t-name\")] = node;\n                return;\n            }\n\n            if (node.tagName === \"field\") {\n                const fieldInfo = Field.parseFieldNode(\n                    node,\n                    models,\n                    modelName,\n                    \"activity\",\n                    jsClass\n                );\n                if (!(fieldInfo.name in fieldNextIds)) {\n                    fieldNextIds[fieldInfo.name] = 0;\n                }\n                const fieldId = `${fieldInfo.name}_${fieldNextIds[fieldInfo.name]++}`;\n                fieldNodes[fieldId] = fieldInfo;\n                node.setAttribute(\"field_id\", fieldId);\n            }\n\n            // Keep track of last update so images can be reloaded when they may have changed.\n            if (node.tagName === \"img\") {\n                const attSrc = node.getAttribute(\"t-att-src\");\n                if (\n                    attSrc &&\n                    /\\bactivity_image\\b/.test(attSrc) &&\n                    !Object.values(fieldNodes).some((f) => f.name === \"write_date\")\n                ) {\n                    fieldNodes.write_date_0 = { name: \"write_date\", type: \"datetime\" };\n                }\n            }\n        });\n        return {\n            fieldNodes,\n            templateDocs,\n            title,\n        };\n    }\n}\n", "import { ActivityListPopover } from \"@mail/core/web/activity_list_popover\";\nimport { Avatar } from \"@mail/views/web/fields/avatar/avatar\";\n\nimport { Component, useRef } from \"@odoo/owl\";\n\nimport { usePopover } from \"@web/core/popover/popover_hook\";\n\nimport { formatDate } from \"@web/core/l10n/dates\";\n\nexport class ActivityCell extends Component {\n    static components = {\n        Avatar,\n    };\n    static props = {\n        activityIds: {\n            type: Array,\n            elements: Number,\n        },\n        attachmentsInfo: {\n            optional: true,\n            type: Object,\n        },\n        activityTypeId: Number,\n        reportingDate: String,\n        countByState: Object,\n        reloadFunc: Function,\n        resId: Number,\n        resModel: String,\n        userAssignedIds: Array,\n    };\n    static template = \"mail.ActivityCell\";\n\n    setup() {\n        this.popover = usePopover(ActivityListPopover, { position: \"bottom-start\" });\n        this.contentRef = useRef(\"content\");\n    }\n\n    get reportingDateFormatted() {\n        return formatDate(luxon.DateTime.fromISO(this.props.reportingDate));\n    }\n\n    get ongoingActivityCount() {\n        return (\n            (this.props.countByState?.planned ?? 0) +\n            (this.props.countByState?.today ?? 0) +\n            (this.props.countByState?.overdue ?? 0)\n        );\n    }\n\n    get totalActivityCount() {\n        return this.ongoingActivityCount + (this.props.countByState?.done ?? 0);\n    }\n\n    onClick() {\n        if (this.popover.isOpen) {\n            this.popover.close();\n        } else {\n            this.popover.open(this.contentRef.el, {\n                activityIds: this.props.activityIds,\n                defaultActivityTypeId: this.props.activityTypeId,\n                onActivityChanged: () => {\n                    this.props.reloadFunc();\n                    this.popover.close();\n                },\n                resId: this.props.resId,\n                resModel: this.props.resModel,\n            });\n        }\n    }\n}\n", "import { createElement, extractAttributes } from \"@web/core/utils/xml\";\nimport { toInterpolatedStringExpression, ViewCompiler } from \"@web/views/view_compiler\";\nimport { toStringExpression } from \"@web/views/utils\";\n\nexport class ActivityCompiler extends ViewCompiler {\n    /**\n     * @override\n     */\n    compileField(el, params) {\n        let compiled;\n        if (el.hasAttribute(\"widget\")) {\n            compiled = super.compileField(el, params);\n        } else {\n            // fields without a specified widget are rendered as simple spans in activity records\n            compiled = createElement(\"div\", {\n                \"t-out\": `record[\"${el.getAttribute(\"name\")}\"].value`,\n            });\n        }\n        const classNames = [];\n        const { bold, display, muted } = extractAttributes(el, [\"bold\", \"display\", \"muted\"]);\n        if (display === \"right\") {\n            classNames.push(\"float-end\");\n        }\n        if (display === \"full\") {\n            classNames.push(\"d-block\", \"text-truncate\");\n        } else {\n            classNames.push(\"d-inline-block\");\n        }\n        if (bold) {\n            classNames.push(\"fw-bold\");\n        }\n        if (muted) {\n            classNames.push(\"text-muted\");\n        }\n        if (classNames.length > 0) {\n            const clsFormatted = el.hasAttribute(\"widget\")\n                ? toStringExpression(classNames.join(\" \"))\n                : classNames.join(\" \");\n            compiled.setAttribute(\"class\", clsFormatted);\n        }\n\n        const attrs = {};\n        for (const attr of el.attributes) {\n            attrs[attr.name] = attr.value;\n        }\n\n        if (el.hasAttribute(\"widget\")) {\n            const attrsParts = Object.entries(attrs).map(([key, value]) => {\n                if (key.startsWith(\"t-attf-\")) {\n                    key = key.slice(7);\n                    value = toInterpolatedStringExpression(value);\n                } else if (key.startsWith(\"t-att-\")) {\n                    key = key.slice(6);\n                    value = `\"\" + (${value})`;\n                } else if (key.startsWith(\"t-att\")) {\n                    throw new Error(\"t-att on <field> nodes is not supported\");\n                } else if (!key.startsWith(\"t-\")) {\n                    value = toStringExpression(value);\n                }\n                return `'${key}':${value}`;\n            });\n            compiled.setAttribute(\"attrs\", `{${attrsParts.join(\",\")}}`);\n        }\n\n        for (const attr in attrs) {\n            if (attr.startsWith(\"t-\") && !attr.startsWith(\"t-att\")) {\n                compiled.setAttribute(attr, attrs[attr]);\n            }\n        }\n\n        return compiled;\n    }\n}\n\nActivityCompiler.OWL_DIRECTIVE_WHITELIST = [\n    ...ViewCompiler.OWL_DIRECTIVE_WHITELIST,\n    \"t-name\",\n    \"t-esc\",\n    \"t-out\",\n    \"t-set\",\n    \"t-value\",\n    \"t-if\",\n    \"t-else\",\n    \"t-elif\",\n    \"t-foreach\",\n    \"t-as\",\n    \"t-key\",\n    \"t-att.*\",\n    \"t-call\",\n    \"t-translation\",\n];\n", "import { _t } from \"@web/core/l10n/translation\";\n\nimport { Component, useState } from \"@odoo/owl\";\n\nimport { useService } from \"@web/core/utils/hooks\";\nimport { useModel } from \"@web/model/model\";\nimport { extractFieldsFromArchInfo } from \"@web/model/relational_model/utils\";\nimport { CogMenu } from \"@web/search/cog_menu/cog_menu\";\nimport { Layout } from \"@web/search/layout\";\nimport { SearchBar } from \"@web/search/search_bar/search_bar\";\nimport { usePager } from \"@web/search/pager_hook\";\nimport { standardViewProps } from \"@web/views/standard_view_props\";\nimport { SelectCreateDialog } from \"@web/views/view_dialogs/select_create_dialog\";\n\nexport class ActivityController extends Component {\n    static components = { Layout, SearchBar, CogMenu };\n    static props = {\n        ...standardViewProps,\n        Model: Function,\n        Renderer: Function,\n        archInfo: Object,\n    };\n    static template = \"mail.ActivityController\";\n\n    setup() {\n        this.model = useState(useModel(this.props.Model, this.modelParams));\n\n        this.dialog = useService(\"dialog\");\n        this.action = useService(\"action\");\n        this.store = useService(\"mail.store\");\n        this.ui = useState(useService(\"ui\"));\n        usePager(() => {\n            const { count, hasLimitedCount, limit, offset } = this.model.root;\n            return {\n                offset: offset,\n                limit: limit,\n                total: count,\n                onUpdate: async (params) => {\n                    // Ensure that only (active) records with at least one activity, \"done\" (archived) or not, are fetched.\n                    // We don't use active_test=false in the context because otherwise we would also get archived records.\n                    params.domain = [...(this.model.originalDomain || []), [\"activity_ids.active\", \"in\", [true, false]]];\n                    await Promise.all([\n                        this.model.root.load(params),\n                        this.model.fetchActivityData(params),\n                    ]);\n                },\n                updateTotal: hasLimitedCount ? () => this.model.root.fetchCount() : undefined,\n            };\n        });\n    }\n\n    get modelParams() {\n        const { archInfo, resModel } = this.props;\n        const { activeFields, fields } = extractFieldsFromArchInfo(archInfo, this.props.fields);\n        return {\n            config: {\n                activeFields,\n                resModel,\n                fields,\n            },\n        };\n    }\n\n    getSearchProps() {\n        const { comparision, context, domain, groupBy, orderBy } = this.env.searchModel;\n        return { comparision, context, domain, groupBy, orderBy };\n    }\n\n    scheduleActivity() {\n        this.dialog.add(SelectCreateDialog, {\n            resModel: this.props.resModel,\n            searchViewId: this.env.searchModel.searchViewId,\n            domain: this.model.originalDomain,\n            title: _t(\"Search: %s\", this.props.archInfo.title),\n            multiSelect: false,\n            context: this.props.context,\n            noCreate: this.props.context?.create === false,\n            onSelected: async (resIds) => {\n                await this.store.scheduleActivity(this.props.resModel, resIds);\n            },\n        }, {\n            onClose: () => this.model.load(this.getSearchProps())\n        });\n    }\n\n    openActivityFormView(resId, activityTypeId) {\n        this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                res_model: \"mail.activity\",\n                views: [[false, \"form\"]],\n                view_mode: \"form\",\n                view_type: \"form\",\n                res_id: false,\n                target: \"new\",\n                context: {\n                    default_res_id: resId,\n                    default_res_model: this.props.resModel,\n                    default_activity_type_id: activityTypeId,\n                },\n            },\n            {\n                onClose: () => this.model.load(this.getSearchProps()),\n            }\n        );\n    }\n\n    sendMailTemplate(templateID, activityTypeID) {\n        const groupedActivities = this.model.activityData.grouped_activities;\n        const resIds = [];\n        for (const resId in groupedActivities) {\n            const activityByType = groupedActivities[resId];\n            const activity = activityByType[activityTypeID];\n            if (activity) {\n                resIds.push(parseInt(resId));\n            }\n        }\n        this.model.orm.call(this.props.resModel, \"activity_send_mail\", [resIds, templateID], {});\n    }\n\n    async openRecord(record, mode) {\n        const activeIds = this.model.root.records.map((datapoint) => datapoint.resId);\n        this.props.selectRecord(record.resId, { activeIds, mode });\n    }\n\n    get rendererProps() {\n        return {\n            activityTypes: this.model.activityData.activity_types,\n            activityResIds: this.model.activityData.activity_res_ids,\n            fields: this.model.root.fields,\n            records: this.model.root.records,\n            resModel: this.props.resModel,\n            archInfo: this.props.archInfo,\n            groupedActivities: this.model.activityData.grouped_activities,\n            scheduleActivity: this.scheduleActivity.bind(this),\n            onReloadData: () => this.model.load(this.getSearchProps()),\n            onEmptyCell: this.openActivityFormView.bind(this),\n            onSendMailTemplate: this.sendMailTemplate.bind(this),\n            openRecord: this.openRecord.bind(this),\n        };\n    }\n}\n", "import { RelationalModel } from \"@web/model/relational_model/relational_model\";\n\nexport class ActivityModel extends RelationalModel {\n    static DEFAULT_LIMIT = 100;\n\n    async load(params = {}) {\n        this.originalDomain = params.domain ? [...params.domain] : [];\n        // Ensure that only (active) records with at least one activity, \"done\" (archived) or not, are fetched.\n        // We don't use active_test=false in the context because otherwise we would also get archived records.\n        params.domain = [...(params.domain || []), [\"activity_ids.active\", \"in\", [true, false]]];\n        if (params && \"groupBy\" in params) {\n            params.groupBy = [];\n        }\n        await Promise.all([this.fetchActivityData(params), super.load(params)]);\n    }\n\n    async fetchActivityData(params) {\n        this.activityData = await this.orm.call(\"mail.activity\", \"get_activity_data\", [], {\n            res_model: this.config.resModel,\n            domain: params.domain || this.env.searchModel._domain,\n            limit: params.limit || this.initialLimit,\n            offset: params.offset || 0,\n            fetch_done: true,\n        });\n    }\n}\n", "import { ActivityCompiler } from \"@mail/views/web/activity/activity_compiler\";\n\nimport { Component } from \"@odoo/owl\";\n\nimport { evaluateBooleanExpr } from \"@web/core/py_js/py\";\nimport { user } from \"@web/core/user\";\nimport { isHtmlEmpty } from \"@web/core/utils/html\";\nimport { Field } from \"@web/views/fields/field\";\nimport { getFormattedRecord, getImageSrcFromRecordInfo } from \"@web/views/kanban/kanban_record\";\nimport { useViewCompiler } from \"@web/views/view_compiler\";\n\nexport class ActivityRecord extends Component {\n    static components = {\n        Field,\n    };\n    static props = {\n        archInfo: { type: Object },\n        openRecord: { type: Function },\n        record: { type: Object },\n    };\n    static template = \"mail.ActivityRecord\";\n\n    setup() {\n        this.evaluateBooleanExpr = evaluateBooleanExpr;\n        this.widget = {\n            deletable: false,\n            editable: false,\n            isHtmlEmpty,\n        };\n        const { templateDocs } = this.props.archInfo;\n        const templates = useViewCompiler(ActivityCompiler, templateDocs);\n        this.recordTemplate = templates[\"activity-box\"];\n    }\n\n    getRenderingContext() {\n        const { record } = this.props;\n        return {\n            record: getFormattedRecord(record),\n            activity_image: (...args) => getImageSrcFromRecordInfo(record, ...args),\n            user_context: user.context,\n            widget: this.widget,\n            luxon,\n            __comp__: Object.assign(Object.create(this), { this: this }),\n        };\n    }\n}\n", "import { MailColumnProgress } from \"@mail/core/web/mail_column_progress\";\nimport { ActivityCell } from \"@mail/views/web/activity/activity_cell\";\nimport { ActivityRecord } from \"@mail/views/web/activity/activity_record\";\n\nimport { Component, useState } from \"@odoo/owl\";\n\nimport { browser } from \"@web/core/browser/browser\";\nimport { CheckBox } from \"@web/core/checkbox/checkbox\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nexport class ActivityRenderer extends Component {\n    static components = {\n        ActivityCell,\n        ActivityRecord,\n        ColumnProgress: MailColumnProgress,\n        Dropdown,\n        DropdownItem,\n        CheckBox,\n    };\n    static props = {\n        activityTypes: { type: Object },\n        activityResIds: { type: Array },\n        fields: { type: Object },\n        resModel: { type: String },\n        records: { type: Array },\n        archInfo: { type: Object },\n        groupedActivities: { type: Object },\n        scheduleActivity: { type: Function },\n        onReloadData: { type: Function },\n        onEmptyCell: { type: Function },\n        onSendMailTemplate: { type: Function },\n        openRecord: { type: Function },\n    };\n    static template = \"mail.ActivityRenderer\";\n\n    setup() {\n        this.activeFilter = useState({\n            progressValue: {\n                active: null,\n            },\n            activityTypeId: null,\n            resIds: new Set(Object.keys(this.props.groupedActivities)),\n        });\n\n        this.storageKey = [\"activity_columns\", this.props.resModel, this.env.config.viewId];\n        this.setupStorageActiveColumns();\n    }\n\n    getGroupInfo(activityType) {\n        const types = {\n            done: {\n                color: \"secondary\",\n                inProgressBar: false,\n                label: _t(\"done\"), // activity_mixin.activity_state has no done state, so we add it manually here\n                value: 0,\n            },\n            planned: {\n                color: \"success\",\n                inProgressBar: true,\n                value: 0,\n            },\n            today: {\n                color: \"warning\",\n                inProgressBar: true,\n                value: 0,\n            },\n            overdue: {\n                color: \"danger\",\n                inProgressBar: true,\n                value: 0,\n            },\n        };\n        for (const [type, label] of this.props.fields.activity_state.selection) {\n            types[type].label = label;\n        }\n        const typeId = activityType.id;\n        const isColumnFiltered = this.activeFilter.activityTypeId === activityType.id;\n        const progressValue = isColumnFiltered ? this.activeFilter.progressValue : { active: null };\n\n        let totalCountWithoutDone = 0;\n        for (const activities of Object.values(this.props.groupedActivities)) {\n            if (typeId in activities) {\n                for (const [state, stateCount] of Object.entries(\n                    activities[typeId].count_by_state\n                )) {\n                    types[state].value += stateCount;\n                    if (state !== \"done\") {\n                        totalCountWithoutDone += stateCount;\n                    }\n                }\n            }\n        }\n\n        const progressBar = {\n            bars: [],\n            activeBar: isColumnFiltered ? this.activeFilter.progressValue.active : null,\n        };\n        for (const [value, count] of Object.entries(types)) {\n            if (count.inProgressBar) {\n                progressBar.bars.push({\n                    count: count.value,\n                    value,\n                    string: types[value].label,\n                    color: count.color,\n                });\n            }\n        }\n\n        const ongoingActivityCount = types.overdue.value + types.today.value + types.planned.value;\n        const ongoingAndDoneCount = ongoingActivityCount + types.done.value;\n        const labelAggregate = `${types.overdue.label} + ${types.today.label} + ${types.planned.label}`;\n        const aggregateOn =\n            ongoingAndDoneCount && this.isTypeDisplayDone(typeId)\n                ? {\n                      title: `${types.done.label} + ${labelAggregate}`,\n                      value: ongoingAndDoneCount,\n                  }\n                : undefined;\n        return {\n            aggregate: {\n                title: labelAggregate,\n                value: isColumnFiltered ? types[progressValue.active].value : ongoingActivityCount,\n            },\n            aggregateOn: aggregateOn,\n            data: {\n                count: totalCountWithoutDone,\n                filterProgressValue: (name) => this.onSetProgressBarState(typeId, name),\n                progressBar,\n                progressValue,\n            },\n        };\n    }\n\n    getRecord(resId) {\n        return this.props.records.find((r) => r.resId === resId);\n    }\n\n    isTypeDisplayDone(typeId) {\n        return this.props.activityTypes.find((a) => a.id === typeId).keep_done;\n    }\n\n    onSetProgressBarState(typeId, bar) {\n        const name = bar.value;\n        if (this.activeFilter.progressValue.active === name) {\n            this.activeFilter.progressValue.active = null;\n            this.activeFilter.activityTypeId = null;\n            this.activeFilter.resIds = new Set(Object.keys(this.props.groupedActivities));\n        } else {\n            this.activeFilter.progressValue.active = name;\n            this.activeFilter.activityTypeId = typeId;\n            this.activeFilter.resIds = new Set(\n                Object.entries(this.props.groupedActivities)\n                    .filter(\n                        ([, resIds]) => typeId in resIds && name in resIds[typeId].count_by_state\n                    )\n                    .map(([key]) => parseInt(key))\n            );\n        }\n    }\n\n    get activeColumns() {\n        return this.props.activityTypes.filter(\n            (activityType) => this.storageActiveColumns[activityType.id]\n        );\n    }\n\n    setupStorageActiveColumns() {\n        const storageActiveColumnsList = browser.localStorage.getItem(this.storageKey)?.split(\",\");\n\n        this.storageActiveColumns = useState({});\n        for (const activityType of this.props.activityTypes) {\n            if (storageActiveColumnsList) {\n                this.storageActiveColumns[activityType.id] = storageActiveColumnsList.includes(\n                    activityType.id.toString()\n                );\n            } else {\n                this.storageActiveColumns[activityType.id] = true;\n            }\n        }\n    }\n\n    toggleDisplayColumn(typeId) {\n        this.storageActiveColumns[typeId] = !this.storageActiveColumns[typeId];\n        browser.localStorage.setItem(\n            this.storageKey.join(\",\"),\n            Object.keys(this.storageActiveColumns).filter(\n                (activityType) => this.storageActiveColumns[activityType]\n            )\n        );\n    }\n}\n", "import { ActivityArchParser } from \"@mail/views/web/activity/activity_arch_parser\";\nimport { ActivityController } from \"@mail/views/web/activity/activity_controller\";\nimport { ActivityModel } from \"@mail/views/web/activity/activity_model\";\nimport { ActivityRenderer } from \"@mail/views/web/activity/activity_renderer\";\n\nimport { registry } from \"@web/core/registry\";\n\nexport const activityView = {\n    type: \"activity\",\n    searchMenuTypes: [\"filter\", \"favorite\"],\n    Controller: ActivityController,\n    Renderer: ActivityRenderer,\n    ArchParser: ActivityArchParser,\n    Model: ActivityModel,\n    props: (genericProps, view) => {\n        const { arch, relatedModels, resModel } = genericProps;\n        const archInfo = new view.ArchParser().parse(arch, relatedModels, resModel);\n        return {\n            ...genericProps,\n            archInfo,\n            Model: view.Model,\n            Renderer: view.Renderer,\n        };\n    },\n};\nregistry.category(\"views\").add(\"activity\", activityView);\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { graphView } from \"@web/views/graph/graph_view\";\nimport { ForecastSearchModel } from \"@crm/views/forecast_search_model\";\n\nexport const forecastGraphView = {\n    ...graphView,\n    SearchModel: ForecastSearchModel,\n};\n\nregistry.category(\"views\").add(\"forecast_graph\", forecastGraphView);\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { pivotView } from \"@web/views/pivot/pivot_view\";\nimport { ForecastSearchModel } from \"@crm/views/forecast_search_model\";\n\nexport const forecastPivotView = {\n    ...pivotView,\n    SearchModel: ForecastSearchModel,\n};\n\nregistry.category(\"views\").add(\"forecast_pivot\", forecastPivotView);\n", "import { registry } from \"@web/core/registry\";\nimport { graphView } from \"@web/views/graph/graph_view\";\nimport { AnalyticSearchModel } from \"@analytic/views/analytic_search_model\";\n\nexport const analyticGraphView = {\n    ...graphView,\n    SearchModel: AnalyticSearchModel,\n};\n\nregistry.category(\"views\").add(\"analytic_graph\", analyticGraphView);\n", "import { PivotRenderer } from \"@web/views/pivot/pivot_renderer\";\n\n\nexport class AnalyticPivotRenderer extends PivotRenderer {\n\n    /*\n     * Override to avoid using incomplete groupByItems\n     */\n    onGroupBySelected(type, payload) {\n        if (typeof(payload.optionId) === \"number\") {\n            let searchItems = this.env.searchModel.getSearchItems(\n                (searchItem) =>\n                    [\"groupBy\", \"dateGroupBy\"].includes(searchItem.type) && !searchItem.custom\n            )\n            searchItems = [...searchItems, ...searchItems.flatMap((f) => f.options).filter((f) => typeof(f?.id) === \"number\")]\n            const { fieldName } = searchItems.find(({ id }) => id === payload.optionId);\n            payload.fieldName = fieldName;\n        }\n        super.onGroupBySelected(type, payload);\n    }\n}\n", "import { registry } from \"@web/core/registry\";\nimport { pivotView } from \"@web/views/pivot/pivot_view\";\nimport { AnalyticSearchModel } from \"@analytic/views/analytic_search_model\";\nimport { AnalyticPivotRenderer } from \"@analytic/views/pivot/pivot_renderer\";\n\nexport const analyticPivotView = {\n    ...pivotView,\n    Renderer: AnalyticPivotRenderer,\n    SearchModel: AnalyticSearchModel,\n};\n\nregistry.category(\"views\").add(\"analytic_pivot\", analyticPivotView);\n", "/** @odoo-module **/\n\nimport { GraphModel } from \"@web/views/graph/graph_model\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nexport class ProjectTaskGraphModel extends GraphModel {\n    _getDefaultFilterLabel(field) {\n        if (field.fieldName === \"project_id\") {\n            return _t(\"\ud83d\udd12 Private\");\n        }\n        return super._getDefaultFilterLabel(field);\n    }\n}\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { graphView } from \"@web/views/graph/graph_view\";\nimport { ProjectTaskGraphModel } from \"./project_task_graph_model\";\n\nconst viewRegistry = registry.category(\"views\");\n\nexport const projectTaskGraphView = {\n    ...graphView,\n    Model: ProjectTaskGraphModel,\n};\n\nviewRegistry.add(\"project_task_graph\", projectTaskGraphView);\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { PivotModel } from \"@web/views/pivot/pivot_model\";\n\nexport class ProjectTaskPivotModel extends PivotModel {\n    /**\n     * @override\n     */\n    _getEmptyGroupLabel(fieldName) {\n        if (fieldName === \"project_id\") {\n            return _t(\"Private\");\n        } else if (fieldName === \"user_ids\") {\n            return _t(\"Unassigned\");\n        } else {\n            return super._getEmptyGroupLabel(fieldName);\n        }\n    }\n}\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { pivotView } from \"@web/views/pivot/pivot_view\";\nimport { ProjectTaskPivotModel } from \"./project_pivot_model\";\n\nexport const projectPivotView = {\n    ...pivotView,\n    Model: ProjectTaskPivotModel,\n};\n\nregistry.category(\"views\").add(\"project_pivot\", projectPivotView);\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { GraphModel } from \"@web/views/graph/graph_model\";\nimport { sortBy } from \"@web/core/utils/arrays\";\n\nexport class BurndownChartModel extends GraphModel {\n    /**\n     * @override\n     */\n    setup(params) {\n        super.setup(params);\n        this.stageSeqAndNamePerId = {};\n    }\n\n    /**\n     * Fetch the sequence of each stage in the project. This function alters this.stageSeqAndNamePerId\n     * @protected\n     * @param {Object} context\n     */\n    async _fetchStageInfo(context) {\n        const searchDomain =\n            !context.active_id || !context.default_project_id\n                ? []\n                : [[\"project_ids\", \"in\", context.active_id]];\n        const data = await this.orm.webSearchRead(\"project.task.type\", searchDomain, {\n            specification: {\n                name: {},\n                sequence: {},\n            },\n        });\n        const stageSeqAndNamePerId = {};\n        for (const { id, name, sequence } of data.records) {\n            stageSeqAndNamePerId[id] = { name, sequence };\n        }\n        return stageSeqAndNamePerId;\n    }\n\n    /**\n     * @param {SearchParams} searchParams\n     */\n    async load(searchParams) {\n        const { context, groupBy } = searchParams;\n\n        if (groupBy.includes(\"stage_id\")) {\n            if (context.stage_name_and_sequence_per_id && context.default_project_id) {\n                this.stageSeqAndNamePerId = context.stage_name_and_sequence_per_id;\n            } else {\n                // if the stage_name_and_sequence_per_id wasn't given by the action (for example if the page is simply reloaded)\n                this.stageSeqAndNamePerId = await this._fetchStageInfo(context);\n            }\n        } else {\n            this.stageSeqAndNamePerId = {};\n        }\n        await super.load(searchParams);\n    }\n\n    /**\n     * @override\n     */\n    _prepareData() {\n        super._prepareData();\n        const { groupBy } = this.searchParams;\n        const { mode } = this.metaData;\n        if (mode === \"line\" && groupBy.includes(\"stage_id\")) {\n            this.data.datasets = sortBy(this.data.datasets, (dataSet) => {\n                const firstIdentifier = [...dataSet.identifiers][0];\n                const group = Object.assign(...JSON.parse(firstIdentifier));\n                const val = group.stage_id;\n                if (Array.isArray(val)) {\n                    return this.stageSeqAndNamePerId[val[0]]?.sequence || -1;\n                }\n                return -1;\n            });\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    async _loadDataPoints(metaData) {\n        metaData.measures.__count.string = _t(\"# of Tasks\");\n        return super._loadDataPoints(metaData);\n    }\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { SearchModel } from \"@web/search/search_model\";\n\n\nexport class BurndownChartSearchModel extends SearchModel {\n\n    /**\n     * @override\n     */\n    setup(services) {\n        this.notificationService = useService(\"notification\");\n        super.setup(...arguments);\n    }\n\n    /**\n     * @override\n     */\n    async load(config) {\n        await super.load(...arguments);\n        // Store date and stage_id searchItemId in the SearchModel for reuse in other functions.\n        for (const searchItem of Object.values(this.searchItems)) {\n            if (['dateGroupBy', 'groupBy'].includes(searchItem.type)) {\n                if (this.stageIdSearchItemId && this.dateSearchItemId && this.isClosedSearchItemId) {\n                    return;\n                }\n                switch (searchItem.fieldName) {\n                    case 'date':\n                        this.dateSearchItemId = searchItem.id;\n                        break;\n                    case 'stage_id':\n                        this.stageIdSearchItemId = searchItem.id;\n                        break;\n                    case 'is_closed':\n                        this.isClosedSearchItemId = searchItem.id;\n                        break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @override\n     */\n    deactivateGroup(groupId) {\n        // Prevent removing 'Date & Stage' and 'Date & is closed' group by from the search\n        if (this.searchItems[this.dateSearchItemId].groupId == groupId) {\n            if (this.query.some(queryElem => [this.stageIdSearchItemId, this.isClosedSearchItemId].includes(queryElem.searchItemId))){\n                this._addGroupByNotification(_t(\"The report should be grouped either by \\\"Stage\\\" to represent a Burndown Chart or by \\\"Is Closed\\\" to represent a Burn-up chart. Without one of these groupings applied, the report will not provide relevant information.\"));\n            }\n            return;\n        }\n        super.deactivateGroup(groupId);\n    }\n\n    /**\n     * @override\n     */\n    toggleDateGroupBy(searchItemId, intervalId) {\n        // Ensure that there is always one and only one date group by selected.\n        if (searchItemId === this.dateSearchItemId) {\n            let filtered_query = [];\n            let triggerNotification = false;\n            for (const queryElem of this.query) {\n                if (queryElem.searchItemId !== searchItemId) {\n                    filtered_query.push(queryElem);\n                } else if (queryElem.intervalId === intervalId) {\n                    triggerNotification = true;\n                }\n            }\n            if (filtered_query.length !== this.query.length) {\n                this.query = filtered_query;\n                if (triggerNotification) {\n                    this._addGroupByNotification(_t(\"The Burndown Chart must be grouped by Date\"));\n                }\n            }\n        }\n        super.toggleDateGroupBy(...arguments);\n    }\n\n    /**\n     * @override\n     * Ensure here that there is always either the 'stage' or the 'is_closed' searchItemId inside the query.\n     */\n    toggleSearchItem(searchItemId) {\n        // if the current searchItem stage/is_closed, the counterpart is added before removing the current searchItem\n        if (searchItemId === this.isClosedSearchItemId){\n            super.toggleSearchItem(this.stageIdSearchItemId);\n        } else if (searchItemId === this.stageIdSearchItemId){\n            super.toggleSearchItem(this.isClosedSearchItemId);\n        }\n        super.toggleSearchItem(...arguments);\n    }\n\n    /**\n     * Adds a notification related to the group by constraint of the Burndown Chart.\n     * @param body The message to display in the notification.\n     * @private\n     */\n    _addGroupByNotification(body) {\n        this.notificationService.add(\n            body,\n            { type: \"danger\" }\n        );\n    }\n\n    /**\n     * @override\n     */\n    async _notify() {\n        // Ensure that we always group by date first and by stage_id/is_closed second\n        let stageIdIndex = -1;\n        let dateIndex = -1;\n        let isClosedIndex = -1;\n        for (const [index, queryElem] of this.query.entries()) {\n            if (dateIndex !== -1 && (stageIdIndex !== -1 || isClosedIndex !== -1)) {\n                break;\n            }\n            switch (queryElem.searchItemId) {\n                case this.dateSearchItemId:\n                    dateIndex = index;\n                    break;\n                case this.stageIdSearchItemId:\n                    stageIdIndex = index;\n                    break;\n                case this.isClosedSearchItemId:\n                    isClosedIndex = index;\n                    break;\n            }\n        }\n        if (isClosedIndex > 0) {\n            if (isClosedIndex > dateIndex) {\n                dateIndex += 1;\n            }\n            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);\n        } else if (stageIdIndex > 0) {\n            if (stageIdIndex > dateIndex) {\n                dateIndex += 1;\n            }\n            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);\n        }\n        if (dateIndex > 0) {\n            this.query.splice(0, 0, this.query.splice(dateIndex, 1)[0]);\n        }\n        await super._notify(...arguments);\n    }\n\n}\n", "/** @odoo-module **/\n\nimport { BurndownChartModel } from \"./burndown_chart_model\";\nimport { graphView } from \"@web/views/graph/graph_view\";\nimport { registry } from \"@web/core/registry\";\nimport { BurndownChartSearchModel } from \"./burndown_chart_search_model\";\n\nconst viewRegistry = registry.category(\"views\");\n\nconst burndownChartGraphView = {\n  ...graphView,\n  buttonTemplate: \"project.BurndownChartView.Buttons\",\n  hideCustomGroupBy: true,\n  Model: BurndownChartModel,\n  searchMenuTypes: graphView.searchMenuTypes.filter(menuType => menuType !== \"comparison\"),\n  SearchModel: BurndownChartSearchModel,\n};\n\nviewRegistry.add(\"burndown_chart\", burndownChartGraphView);\n", "import { registry } from \"@web/core/registry\";\nimport { graphView } from \"@web/views/graph/graph_view\";\nimport { GraphController } from \"@web/views/graph/graph_controller\";\nimport { HrActionHelper } from \"@hr/views/hr_action_helper\";\n\nexport class HrGraphController extends GraphController {\n    static template = \"hr.GraphView\";\n    static components = { ...GraphController.components, HrActionHelper };\n}\nexport const HrGraphView = {\n    ...graphView,\n    Controller: HrGraphController,\n};\n\nregistry.category(\"views\").add(\"hr_graph_view\", HrGraphView);\n", "import { registry } from \"@web/core/registry\";\nimport { pivotView } from \"@web/views/pivot/pivot_view\";\nimport { PivotController } from \"@web/views/pivot/pivot_controller\";\nimport { HrActionHelper } from \"@hr/views/hr_action_helper\";\n\nexport class HrPivotController extends PivotController {\n    static template = \"hr.PivotView\";\n    static components = { ...PivotController.components, HrActionHelper };\n}\nexport const HrPivotView = {\n    ...pivotView,\n    Controller: HrPivotController,\n};\n\nregistry.category(\"views\").add(\"hr_pivot_view\", HrPivotView);\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { GraphRenderer } from \"@web/views/graph/graph_renderer\";\nimport { graphView } from \"@web/views/graph/graph_view\";\n\nexport class SkillsGraphRenderer extends GraphRenderer {\n    getScaleOptions() {\n        const scaleOptions = super.getScaleOptions();\n\n        if ('y' in scaleOptions) {\n            scaleOptions.y.suggestedMax = 100;\n        }\n\n        return scaleOptions;\n    }\n}\n\nexport const skillsGraphView = {\n    ...graphView,\n    Renderer: SkillsGraphRenderer,\n};\n\nregistry.category(\"views\").add(\"skills_graph\", skillsGraphView);\n", "/** @odoo-module **/\n\nimport { ProjectTaskGraphModel } from \"@project/views/project_task_graph/project_task_graph_model\";\n\nconst FIELDS = [\n    'unit_amount', 'effective_hours', 'allocated_hours', 'remaining_hours', 'total_hours_spent', 'subtask_effective_hours',\n    'overtime', 'number_hours', 'difference', 'timesheet_unit_amount'\n];\n\nexport class hrTimesheetGraphModel extends ProjectTaskGraphModel {\n    /**\n     * @override\n     */\n    setup(params, services) {\n        super.setup(...arguments);\n        this.companyService = services.company;\n    }\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Override processDataPoints to take into account the analytic line uom.\n     * @override\n     */\n    _getProcessedDataPoints() {\n        const currentCompany = this.companyService.currentCompany;\n        const factor = currentCompany.timesheet_uom_factor || 1;\n        if (factor !== 1 && FIELDS.includes(this.metaData.measure)) {\n            // recalculate the Duration values according to the timesheet_uom_factor\n            for (const dataPt of this.dataPoints) {\n                dataPt.value *= factor;\n            }\n        }\n        return super._getProcessedDataPoints(...arguments);\n    }\n}\nhrTimesheetGraphModel.services = [...ProjectTaskGraphModel.services, \"company\"];\n", "/** @odoo-module **/\n\nimport { projectTaskGraphView } from \"@project/views/project_task_graph/project_task_graph_view\";\nimport { hrTimesheetGraphModel } from \"./timesheet_graph_model\";\nimport { registry } from \"@web/core/registry\";\n\nconst viewRegistry = registry.category(\"views\");\n\nexport const hrTimesheetGraphView = {\n  ...projectTaskGraphView,\n  Model: hrTimesheetGraphModel,\n};\n\nviewRegistry.add(\"hr_timesheet_graphview\", hrTimesheetGraphView);\n", "/** @odoo-module */\n\nimport { visitXML } from \"@web/core/utils/xml\";\nimport { stringToOrderBy } from \"@web/search/utils/order_by\";\nimport { Field } from \"@web/views/fields/field\";\nimport { getActiveActions } from \"@web/views/utils\";\nimport { exprToBoolean } from \"@web/core/utils/strings\";\n\nexport class HierarchyArchParser {\n    parse(xmlDoc, models, modelName) {\n        const archInfo = {\n            activeActions: getActiveActions(xmlDoc),\n            defaultOrder: stringToOrderBy(xmlDoc.getAttribute(\"default_order\") || null),\n            draggable: false,\n            icon: \"fa-share-alt fa-rotate-90 align-text-top\",\n            parentFieldName: \"parent_id\",\n            fieldNodes: {},\n            templateDocs: {},\n            xmlDoc,\n        };\n        const fieldNextIds = {};\n        const fields = models[modelName].fields;\n\n        visitXML(xmlDoc, (node) => {\n            if (node.hasAttribute(\"t-name\")) {\n                archInfo.templateDocs[node.getAttribute(\"t-name\")] = node;\n                return;\n            }\n            if (node.tagName === \"hierarchy\") {\n                if (node.hasAttribute(\"parent_field\")) {\n                    const parentFieldName = node.getAttribute(\"parent_field\");\n                    if (!(parentFieldName in fields)) {\n                        throw new Error(`The parent field set (${parentFieldName}) is not defined in the model (${modelName}).`);\n                    } else if (fields[parentFieldName].type !== \"many2one\") {\n                        throw new Error(`Invalid parent field, it should be a Many2One field.`);\n                    } else if (fields[parentFieldName].relation !== modelName) {\n                        throw new Error(`Invalid parent field, the co-model should be same model than the current one (expected: ${modelName}).`);\n                    }\n                    archInfo.parentFieldName = parentFieldName;\n                }\n                if (node.hasAttribute(\"child_field\")) {\n                    const childFieldName = node.getAttribute(\"child_field\");\n                    if (!(childFieldName in fields)) {\n                        throw new Error(`The child field set (${childFieldName}) is not defined in the model (${modelName}).`);\n                    } else if (fields[childFieldName].type !== \"one2many\") {\n                        throw new Error(`Invalid child field, it should be a One2Many field.`);\n                    } else if (fields[childFieldName].relation !== modelName) {\n                        throw new Error(`Invalid child field, the co-model should be same model than the current one (expected: ${modelName}).`);\n                    }\n                    archInfo.childFieldName = childFieldName;\n                }\n                if (node.hasAttribute(\"draggable\")) {\n                    archInfo.draggable = exprToBoolean(node.getAttribute(\"draggable\"));\n                }\n                if (node.hasAttribute(\"icon\")) {\n                    archInfo.icon = node.getAttribute(\"icon\");\n                }\n            } else if (node.tagName === \"field\") {\n                const fieldInfo = Field.parseFieldNode(node, models, modelName, \"hierarchy\");\n                const name = fieldInfo.name;\n                if (!(name in fieldNextIds)) {\n                    fieldNextIds[name] = 0;\n                }\n                const fieldId = `${name}_${fieldNextIds[name]++}`;\n                archInfo.fieldNodes[fieldId] = fieldInfo;\n                node.setAttribute(\"field_id\", fieldId);\n            }\n        });\n\n        const cardDoc = archInfo.templateDocs[\"hierarchy-box\"];\n        if (!cardDoc) {\n            throw new Error(\"Missing 'hierarchy-box' template.\");\n        }\n\n        return archInfo;\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\n\nimport { evaluateBooleanExpr } from \"@web/core/py_js/py\";\nimport { Field } from \"@web/views/fields/field\";\nimport { Record } from \"@web/model/record\";\nimport { ViewButton } from \"@web/views/view_button/view_button\";\nimport { useViewCompiler } from \"@web/views/view_compiler\";\n\nimport { HierarchyCompiler } from \"./hierarchy_compiler\";\nimport { getFormattedRecord } from \"@web/views/kanban/kanban_record\";\n\nexport class HierarchyCard extends Component {\n    static components = {\n        Record,\n        Field,\n        ViewButton,\n    };\n    static props = {\n        node: Object,\n        openRecord: Function,\n        archInfo: Object,\n        templates: Object,\n        classNames: { type: String, optional: true },\n    };\n    static defaultProps = {\n        classNames: \"\",\n    };\n    static template = \"web_hierarchy.HierarchyCard\";\n    static Compiler = HierarchyCompiler;\n\n    setup() {\n        const { templates } = this.props;\n        this.templates = useViewCompiler(this.constructor.Compiler, templates);\n        this.evaluateBooleanExpr = evaluateBooleanExpr;\n    }\n\n    get classNames() {\n        const classNames = [this.props.classNames];\n        if (this.props.node.nodes.length) {\n            classNames.push(\"o_hierarchy_node_unfolded\");\n        }\n        return classNames.join(\" \");\n    }\n\n    getRenderingContext(data) {\n        const record = getFormattedRecord(data.record);\n        return {\n            context: this.props.node.context,\n            JSON,\n            luxon,\n            record,\n            __comp__: Object.assign(Object.create(this), { this: this }),\n            __record__: data.record,\n        };\n    }\n\n    onGlobalClick(ev) {\n        if (ev.target.closest(\"button\")) {\n            return;\n        }\n        this.props.openRecord(this.props.node);\n    }\n\n    onClickArrowUp(ev) {\n        this.props.node.fetchParentNode();\n    }\n\n    onClickArrowDown(ev) {\n        if (this.props.node.nodes.length) {\n            this.props.node.collapseChildNodes();\n        } else {\n            this.props.node.showChildNodes();\n        }\n    }\n}\n", "/** @odoo-module **/\n\nimport { KanbanCompiler } from \"@web/views/kanban/kanban_compiler\";\n\nexport class HierarchyCompiler extends KanbanCompiler {\n    /**\n     * @override\n     * @param {Element} el\n     * @param {Object} params\n     * @returns {Element}\n     */\n    compileField(el, params) {\n        const fieldName = el.getAttribute(\"name\");\n        return super.compileField(el, {\n            ...(params || {}),\n            recordExpr: \"__record__\",\n            dataPointIdExpr: \"__comp__.props.node.id\",\n            formattedValueExpr: `record['${fieldName}'].value`,\n        });\n    }\n\n    compileButton(el, params) {\n        return super.compileButton(el, {\n            ...(params || {}),\n            recordExpr: \"__record__\",\n        });\n    }\n\n    /**\n     * Allow access to the record during compilation, to properly evaluate\n     * invisible on any hierarchy card nodes declared in the view.\n     *\n     * @override\n     */\n    compileNode(node, params = {}, evalInvisible = true) {\n        return super.compileNode(\n            node,\n            {\n                ...params,\n                recordExpr: \"__record__\",\n            },\n            evalInvisible\n        );\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, useRef } from \"@odoo/owl\";\n\nimport { useBus } from \"@web/core/utils/hooks\";\nimport { useModel } from \"@web/model/model\";\nimport { addFieldDependencies, extractFieldsFromArchInfo } from \"@web/model/relational_model/utils\";\nimport { CogMenu } from \"@web/search/cog_menu/cog_menu\";\nimport { Layout } from \"@web/search/layout\";\nimport { SearchBar } from \"@web/search/search_bar/search_bar\";\nimport { useSearchBarToggler } from \"@web/search/search_bar/search_bar_toggler\";\nimport { standardViewProps } from \"@web/views/standard_view_props\";\nimport { useViewButtons } from \"@web/views/view_button/view_button_hook\";\n\nexport class HierarchyController extends Component {\n    static components = {\n        Layout,\n        CogMenu,\n        SearchBar,\n    };\n    static props = {\n        ...standardViewProps,\n        Model: Function,\n        Renderer: Function,\n        buttonTemplate: String,\n        archInfo: Object,\n    };\n    static template = \"web_hierarchy.HierarchyView\";\n\n    setup() {\n        this.rootRef = useRef(\"root\");\n        const { parentFieldName, childFieldName } = this.props.archInfo;\n        const { activeFields, fields } = extractFieldsFromArchInfo(this.props.archInfo, this.props.fields);\n        addFieldDependencies(activeFields, fields, [{ name: parentFieldName }]);\n        this.model = useModel(this.props.Model, {\n            resModel: this.props.resModel,\n            activeFields,\n            defaultOrderBy: this.props.archInfo.defaultOrder,\n            fields,\n            parentFieldName,\n            childFieldName,\n        });\n        useBus(\n            this.model.bus,\n            \"update\",\n            () => {\n                this.render(true);\n            }\n        );\n        useViewButtons(this.rootRef, {\n            beforeExecuteAction: this.beforeExecuteActionButton.bind(this),\n            afterExecuteAction: this.afterExecuteActionButton.bind(this),\n            reload: this.model.reload.bind(this.model),\n        });\n        this.searchBarToggler = useSearchBarToggler();\n    }\n    get displayNoContent() {\n        return this.model.resIds.length === 0;\n    }\n\n    async openRecord(node, mode) {\n        const activeIds = this.model.root.resIds;\n        this.props.selectRecord(node.resId, { activeIds, mode });\n    }\n\n    async beforeExecuteActionButton(clickParams) {}\n\n    async afterExecuteActionButton(clickParams) {}\n}\n", "/** @odoo-module */\n\nimport { Domain } from \"@web/core/domain\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { KeepLast, Mutex } from \"@web/core/utils/concurrency\";\nimport { Model } from \"@web/model/model\";\nimport { orderByToString } from \"@web/search/utils/order_by\";\n\nlet nodeId = 0;\nlet forestId = 0;\nlet treeId = 0;\n\n/**\n * Get the id of the given many2one field value\n *\n * @param {false | [Number, string]} value many2one value\n * @returns {false | Number} id of the many2one\n */\nfunction getIdOfMany2oneField(value) {\n    return value && value[0];\n}\n\nexport class HierarchyNode {\n    /**\n     * Constructor of hierarchy node stored in hierarchy tree\n     *\n     * @param {HierarchyModel} model\n     * @param {Object} config\n     * @param {Object} data\n     * @param {HierarchyTree} tree\n     * @param {HierarchyNode} parentNode\n     * @param {Boolean} populateChildNodes\n     */\n    constructor(model, config, data, tree, parentNode = null, populateChildNodes = true) {\n        this.id = nodeId++;\n        this.data = data;\n        this.parentNode = parentNode;\n        this.tree = tree;\n        this.model = model;\n        this._config = config;\n        this.hidden = false;\n        tree.addNode(this);\n        if (populateChildNodes) {\n            this.populateChildNodes();\n        }\n    }\n\n    /**\n     * Get ancestor node\n     *\n     * @returns {HierarchyNode} ancestor node\n     */\n    get ancestorNode() {\n        return this.parentNode ? this.ancestorNode : this;\n    }\n\n    /**\n     * Is leaf?\n     *\n     * @returns {Boolean} False if the current node has node as child nodes, otherwise True.\n     */\n    get isLeaf() {\n        return !this.nodes.length;\n    }\n\n    /**\n     * Get forest of the current node\n     *\n     * @returns {HierarchyForest}\n     */\n    get forest() {\n        return this.tree.forest;\n    }\n\n    /**\n     * Get the resId of current node\n     *\n     * @returns {Number}\n     */\n    get resId() {\n        return this.data.id;\n    }\n\n    /**\n     * Get parent field name\n     *\n     * @returns {String}\n     */\n    get parentFieldName() {\n        return this.model.parentFieldName;\n    }\n\n    /**\n     * Get parent res id\n     *\n     * @returns {Number}\n     */\n    get parentResId() {\n        return this.parentNode?.resId || getIdOfMany2oneField(this.data[this.parentFieldName]);\n    }\n\n    /**\n     * Get child node res ids\n     *\n     * @returns {Number[]}\n     */\n    get childResIds() {\n        return this.nodes.length ? this.nodes.map((node) => node.resId) : this.data[this.childFieldName]?.map((d) => typeof d === \"number\" ? d : d.id) || [];\n    }\n\n    /**\n     * Get child field name\n     *\n     * @returns {String}\n     */\n    get childFieldName() {\n        return this.model.childFieldName || this.model.defaultChildFieldName;\n    }\n\n    /**\n     * Has child nodes?\n     *\n     * @returns {Boolean}\n     */\n    get hasChildren() {\n        return this.nodes.length > 0 || this.data[this.childFieldName]?.length > 0;\n    }\n\n    /**\n     * Can show parent node\n     *\n     * Knows if the parent node can be fetched and displayed inside the view\n     *\n     * @returns {Boolean} True if the current node has a parent node but it is not yet displayed and the data of the\n     *                    current node is not already displayed in another node.\n     */\n    get canShowParentNode() {\n        return Boolean(this.parentResId)\n            && !this.parentNode\n            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1;\n    }\n\n\n    /**\n     * Can show child nodes\n     *\n     * Knows if the child nodes can be fetched and displayed inside the view\n     *\n     * @returns {Boolean} True if the current node has child nodes but they are not yet displayed and the data of the\n     *                    current node is not already displayed in another node.\n     */\n    get canShowChildNodes() {\n        return this.hasChildren\n            && this.nodes.length === 0\n            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1;\n    }\n\n    get descendantNodes() {\n        const subNodes = [];\n        if (!this.isLeaf) {\n            subNodes.push(...this.nodes);\n            for (const node of this.nodes) {\n                if (node.descendantNodes.length) {\n                    subNodes.push(...node.descendantNodes);\n                }\n            }\n        }\n        return subNodes;\n    }\n\n    /**\n     * Get all descendants nodes parents. If the current node has descendants,\n     * it is also included in the result.\n     *\n     * @returns {Array} contains descendants parents in order of depth (closest\n     *          to root first).\n     */\n    get descendantsParentNodes() {\n        const descendantsParentNodes = [];\n        if (!this.isLeaf) {\n            descendantsParentNodes.push(this);\n            this.nodes.reduce((parents, node) => {\n                if (!node.isLeaf) {\n                    parents.push(...node.descendantsParentNodes);\n                }\n                return parents;\n            }, descendantsParentNodes);\n        }\n        return descendantsParentNodes;\n    }\n\n    /**\n     * Get all descendants nodes resIds\n     *\n     * @returns {Number[]}\n     */\n    get allSubsidiaryResIds() {\n        return this.descendantNodes.map((n) => n.resId);\n    }\n\n    /**\n     * Populate child nodes\n     *\n     * Uses to create child nodes of the current one according to its data.\n     */\n    populateChildNodes() {\n        this.nodes = [];\n        const children = this.data[this.childFieldName] || [];\n        if (\n            children.length\n            && children[0] instanceof Object\n            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1\n        ) {\n            this.createChildNodes(children);\n        }\n    }\n\n    /**\n     * create child nodes\n     *\n     * @param {Object[]} childNodesData data of child nodes to generate\n     */\n    createChildNodes(childNodesData) {\n        this.nodes = (childNodesData || this.data[this.childFieldName]).map(\n            (childData) =>\n                new HierarchyNode(\n                    this.model,\n                    this._config,\n                    childData,\n                    this.tree,\n                    this\n                )\n        );\n    }\n\n    removeParentNode() {\n        this.parentNode?.removeChildNode(this);\n        this.parentNode = null;\n        this.data[this.parentFieldName] = false;\n    }\n\n    /**\n     * Fetch parent node\n     */\n    async fetchParentNode() {\n        await this.model.fetchManager(this);\n    }\n\n    /**\n     * Fetch child nodes\n     */\n    async showChildNodes() {\n        await this.model.fetchSubordinates(this);\n    }\n\n    /**\n     * Collapse child nodes\n     *\n     * Removes the descendant nodes of the current one and stores\n     * the resIds of the child nodes in the data of the current one\n     * to know it has child nodes to be able to show them again\n     * when it is needed.\n     */\n    collapseChildNodes() {\n        const childrenData = [];\n        for (const childNode of this.nodes) {\n            childNode.data[this.childFieldName] = childNode.childResIds;\n            childrenData.push(childNode.data);\n        }\n        this.data[this.childFieldName] = childrenData;\n        this.removeChildNodes();\n        this.model.notify();\n    }\n\n    removeChildNode(node) {\n        node.removeChildNodes();\n        this.tree.removeNodes([node]);\n        this.nodes = this.nodes.filter((n) => n.id !== node.id);\n        this.data[this.childFieldName] = this.nodes.map((n) => n.data);\n    }\n\n    /**\n     * Remove descendant nodes of the current one\n     */\n    removeChildNodes() {\n        for (const childNode of this.nodes) {\n            if (!childNode.isLeaf) {\n                childNode.removeChildNodes();\n            }\n        }\n        this.tree.removeNodes(this.nodes);\n        this.nodes = [];\n    }\n\n    /**\n     * Set parent node to the current node\n     *\n     * @param {HierarchyNode} node parent node to set\n     */\n    setParentNode(node) {\n        this.parentNode = node;\n        node.addChildNode(this);\n        const tree = node.tree;\n        if (tree.root === this) {\n            tree.root = node;\n        } else if (this.tree.root === this) {\n            this.tree.removeRoot();\n            this.setTree(node.tree);\n        }\n    }\n\n    setTree(tree) {\n        this.tree = tree;\n        for (const childNode of this.nodes) {\n            childNode.setTree(tree);\n        }\n    }\n\n    /**\n     * Adds child node to the current node\n     *\n     * @param {HierarchyNode} node child node to add\n     */\n    addChildNode(node) {\n        this.nodes.push(node);\n        this.data[this.childFieldName].push(node.data);\n        this.tree.addNode(node);\n    }\n}\n\nexport class HierarchyTree {\n    /**\n     * Constructor\n     *\n     * @param {HierarchyModel} model\n     * @param {Object} config config of the model\n     * @param {Object} data root node data of the tree to create\n     * @param {HierarchyForest} forest hierarchy forest containing the tree to create\n     */\n    constructor(model, config, data, forest) {\n        this.id = treeId++;\n        this.nodePerNodeId = {};\n        this.forest = forest;\n        if (data) {\n            this.root = new HierarchyNode(model, config, data, this);\n            this.forest.nodePerNodeId = {\n                ...this.forest.nodePerNodeId,\n                ...this.nodePerNodeId,\n            };\n        }\n        this.model = model;\n        this._config = config;\n    }\n\n    /**\n     * Get node res ids inside the current tree\n     *\n     * @returns {Number}\n     */\n    get resIds() {\n        return Object.values(this.nodePerNodeId).map((node) => node.resId);\n    }\n\n    /**\n     * Add node inside the current tree\n     *\n     * @param {HierarchyNode} node node to add inside the current tree\n     */\n    addNode(node) {\n        this.nodePerNodeId[node.id] = node;\n        this.forest.addNode(node);\n    }\n\n    /**\n     * Remove nodes inside the current tree\n     *\n     * @param {HierarchyNode} nodes nodes to remove\n     */\n    removeNodes(nodes) {\n        const nodeIds = nodes.map((node) => node.id);\n        this.nodePerNodeId = Object.fromEntries(\n            Object.entries(this.nodePerNodeId)\n                .filter(\n                    ([nodeId,]) => !nodeIds.includes(Number(nodeId))\n                )\n            );\n        this.forest.removeNodes(nodes);\n    }\n\n    removeRoot() {\n        this.forest.removeTree(this);\n    }\n}\n\nexport class HierarchyForest {\n    /**\n     *\n     * @param {HierarchyModel} model\n     * @param {Object} config model config\n     * @param {Object[]} data list of tree root nodes data\n     */\n    constructor(model, config, data) {\n        this.id = forestId++;\n        this.nodePerNodeId = {};\n        this.trees = data.map((d) => new HierarchyTree(model, config, d, this));\n        this.model = model;\n        this._config = config;\n    }\n\n    /**\n     * Get node res ids containing inside the current forest\n     *\n     * @returns {Number}\n     */\n    get resIds() {\n        return Object.values(this.nodePerNodeId).map((node) => node.resId);\n    }\n\n    /**\n     * Get root node of all trees inside the current forest\n     *\n     * @returns {HierarchyNode[]} root nodes\n     */\n    get rootNodes() {\n        return this.trees.map((t) => t.root);\n    }\n\n    /**\n     * Add a node inside the current forest\n     *\n     * @param {HierarchyNode} node node to add inside the current forest\n     */\n    addNode(node) {\n        this.nodePerNodeId[node.id] = node;\n    }\n\n    /**\n     * Removes nodes inside the current forest\n     *\n     * @param {HierarchyNode} nodes nodes to remove inside the current forest\n     */\n    removeNodes(nodes) {\n        const nodeIds = nodes.map((node) => node.id);\n        this.nodePerNodeId = Object.fromEntries(\n            Object.entries(this.nodePerNodeId)\n                .filter(\n                    ([nodeId,]) => !nodeIds.includes(Number(nodeId))\n                )\n        );\n    }\n\n    addNewRootNode(node) {\n        const tree = new HierarchyTree(this.model, this._config, null, this);\n        tree.root = node;\n        node.tree = tree;\n        tree.addNode(node);\n        for (const subNode of node.descendantNodes) {\n            tree.addNode(subNode);\n        }\n        this.trees.push(tree);\n    }\n\n    removeTree(tree) {\n        this.nodePerNodeId = Object.fromEntries(\n            Object.entries(this.nodePerNodeId)\n                .filter(\n                    ([nodeId, ]) => !(nodeId in tree.nodePerNodeId)\n                )\n        );\n        this.trees = this.trees.filter((t) => t.id !== tree.id);\n    }\n}\n\nexport class HierarchyModel extends Model {\n    static services = [\"notification\"];\n\n    setup(params, { notification }) {\n        this.keepLast = new KeepLast();\n        this.mutex = new Mutex();\n        this.resModel = params.resModel;\n        this.fields = params.fields;\n        this.parentFieldName = params.parentFieldName;\n        this.childFieldName = params.childFieldName;\n        this.activeFields = params.activeFields;\n        this.defaultOrderBy = params.defaultOrderBy;\n        this.notification = notification;\n        this.config = {\n            domain: [],\n            isRoot: true,\n        };\n    }\n\n    /**\n     * Get parent field info\n     *\n     * @returns {Object} parent field info\n     */\n    get parentField() {\n        return this.fields[this.parentFieldName];\n    }\n\n    /**\n     * Get res ids of all nodes displayed in the view\n     *\n     * @returns {Number[]} resIds of all nodes displayed in the view\n     */\n    get resIds() {\n        return this.root?.resIds || [];\n    }\n\n    /**\n     * Get default child field name when no child field name is given to the view\n     *\n     * @returns {String} default child field name to use\n     */\n    get defaultChildFieldName() {\n        return \"__child_ids__\";\n    }\n\n    /**\n     * Get default domain to use, when no domain is given in the config\n     *\n     * @returns {import(\"@web/src/core/domain\").DomainListRepr} default domain\n     */\n    get defaultDomain() {\n        return [[this.parentFieldName, \"=\", false]];\n    }\n\n    /**\n     * Get the global domain of the view (which is the domain defined on the\n     * view without applying filters).\n     *\n     * @returns {import(\"@web/src/core/domain\").DomainListRepr} global domain\n     */\n    get globalDomain() {\n        if (!this.env.searchModel?.globalDomain.length) {\n            return [];\n        }\n        return new Domain(this.env.searchModel.globalDomain).toList(\n            this.env.searchModel.domainEvalContext\n        );\n    }\n\n    /**\n     * Get active fields name\n     *\n     * @returns {String[]} active fields name\n     */\n    get activeFieldNames() {\n        return Object.keys(this.activeFields);\n    }\n\n    /**\n     * Get fields to fetch\n     * @returns {String[]} fields to fetch\n     */\n    get fieldsToFetch() {\n        const fieldsToFetch = [\n            ...this.activeFieldNames,\n        ];\n        if (this.childFieldName) {\n            fieldsToFetch.push(this.childFieldName);\n        }\n        return fieldsToFetch;\n    }\n\n    get context() {\n        return {\n            bin_size: true,\n            ...(this.config.context || {}),\n        };\n    }\n\n    /**\n     * Load the config and data for hierarchy view\n     *\n     * @param {Object} params params to use to load data of hierarchy view\n     */\n    async load(params = {}) {\n        nodeId = forestId = treeId = 0;\n        const config = this._getNextConfig(this.config, params);\n        const data = await this.keepLast.add(this._loadData(config));\n        this.root = this._createRoot(config, data);\n        this.config = config;\n        this.notify();\n    }\n\n    /**\n     * Reload the current view with all currently loaded records\n     */\n    async reload() {\n        nodeId = forestId = treeId = 0;\n        const data = await this.keepLast.add(this._loadData(this.config, true));\n        this.root = this._createRoot(this.config, data);\n        this.notify({ scrollTarget: \"none\" });\n    }\n\n    /**\n     * @override\n     * Each notify should specify a scroll target (default is to scroll to the\n     * bottom).\n     */\n    notify(payload = { scrollTarget: \"bottom\" }) {\n        super.notify();\n        this.bus.trigger(\"hierarchyScrollTarget\", payload);\n    }\n\n    /**\n     * Fetch parent node of given node\n     * @param {HierarchyNode} node node to fetch its parent node\n     */\n    async fetchManager(node) {\n        if (this.root.trees.length > 1) { // reset the hierarchy\n            const treeExpanded = this._findTreeExpanded();\n            const resIdsToFetch = [node.parentResId, node.resId, ...node.allSubsidiaryResIds];\n            if (treeExpanded && treeExpanded.root.id !== node.id && treeExpanded.root.parentResId === node.parentResId) {\n                resIdsToFetch.push(...treeExpanded.root.allSubsidiaryResIds);\n            }\n            const config = {\n                ...this.config,\n                domain: [\"|\", [this.parentFieldName, \"=\", node.parentResId], [\"id\", \"in\", resIdsToFetch]],\n            }\n            const data = await this._loadData(config);\n            this.root = this._createRoot(config, data);\n            this.notify();\n            return;\n        }\n        const managerData = await this.keepLast.add(this._fetchManager(node));\n        if (managerData) {\n            const parentNode = new HierarchyNode(this, this.config, managerData, node.tree, null, false);\n            parentNode.createChildNodes();\n            node.setParentNode(parentNode);\n            this.notify();\n        }\n    }\n\n    /**\n     * Fetch child nodes of given node\n     *\n     * @param {HierarchyNode} node node to fetch its child nodes\n     */\n    async fetchSubordinates(node) {\n        const childFieldName = this.childFieldName || this.defaultChildFieldName;\n        const children = node.data[childFieldName];\n        if (children.length) {\n            const nodesToUpdate = [];\n            if (!(children[0] instanceof Object)) {\n                const allNodeResIds = this.root.resIds;\n                const existingChildResIds = children.filter((childResId) => allNodeResIds.includes(childResId))\n                if (existingChildResIds.length) { // special case with result found with the search view\n                    for (const tree of this.root.trees) {\n                        if (existingChildResIds.includes(tree.root.resId)) {\n                            nodesToUpdate.push(tree.root);\n                        }\n                    }\n                }\n                const data = await this.keepLast.add(this._fetchSubordinates(node, existingChildResIds));\n                if (data && data.length) {\n                    node.data[childFieldName] = data;\n                }\n            }\n            const nodeToCollapse = this._searchNodeToCollapse(node);\n            if (nodeToCollapse && !nodesToUpdate.includes(nodeToCollapse)) {\n                nodeToCollapse.collapseChildNodes();\n            }\n            node.populateChildNodes();\n            for (const n of nodesToUpdate) {\n                n.setParentNode(node);\n            }\n            this.notify();\n        }\n    }\n\n    /**\n     * Search node to collapse to be able to show the child nodes of node given in parameter\n     *\n     * @param {HierarchyNode} node node to show its child nodes.\n     * @returns {HierarchyNode | null} node found to collapse\n     */\n    _searchNodeToCollapse(node) {\n        const parentNode = node.parentNode;\n        let nodeToCollapse = null;\n        if (parentNode) {\n            nodeToCollapse = parentNode.nodes.find((n) => n.nodes.length);\n        } else {\n            const treeExpanded = this._findTreeExpanded();\n            if (treeExpanded) {\n                nodeToCollapse = treeExpanded.root;\n            }\n        }\n        return nodeToCollapse;\n    }\n\n    _findTreeExpanded() {\n        return this.root.trees.find((t) => t.root.nodes.length);\n    }\n\n    /**\n     * Get the next model config to use\n     *\n     * @param {Object} currentConfig current model config used\n     * @param {Object} params new params\n     * @returns {Object} new model config to use\n     */\n    _getNextConfig(currentConfig, params) {\n        const config = Object.assign({}, currentConfig);\n        config.context = \"context\" in params ? params.context : config.context;\n        if (\"domain\" in params) {\n            config.domain = params.domain;\n            if (this.isSearchDefaultOrEmpty() && config.context.hierarchy_res_id) {\n                config.domain = [[\"id\", \"=\", config.context.hierarchy_res_id]];\n                const globalDomain = this.globalDomain;\n                if (globalDomain.length) {\n                    config.domain = Domain.and([config.domain, globalDomain]);\n                }\n                // Just needed for the first load.\n                delete config.context.hierarchy_res_id;\n            }\n        }\n\n        // orderBy\n        config.orderBy = \"orderBy\" in params ? params.orderBy : config.orderBy;\n        // re-apply previous orderBy if not given (or no order)\n        if (!config.orderBy.length) {\n            config.orderBy = currentConfig.orderBy || [];\n        }\n        // apply default order if no order\n        if (this.defaultOrderBy && !config.orderBy.length) {\n            config.orderBy = this.defaultOrderBy;\n        }\n        return config;\n    }\n\n    /**\n     * Evaluate if the current search query is the default one.\n     *\n     * @returns {boolean}\n     */\n    isSearchDefaultOrEmpty() {\n        if (!this.env.searchModel) {\n            return true;\n        }\n        const isDisabledOptionalSearchMenuType = (type) => {\n            return (\n                [\"filter\", \"groupBy\", \"favorite\"].includes(type) &&\n                !this.env.searchModel.searchMenuTypes.has(type)\n            );\n        };\n        const activeSearchItems = this.env.searchModel.getSearchItems(\n            (item) => item.isActive && !isDisabledOptionalSearchMenuType(item.type)\n        );\n        if (!activeSearchItems.length) {\n            return true;\n        }\n        const defaultSearchItems = this.env.searchModel.getSearchItems(\n            (item) =>\n                item.isDefault &&\n                item.type !== \"favorite\" &&\n                !isDisabledOptionalSearchMenuType(item.type)\n        );\n        return JSON.stringify(defaultSearchItems) === JSON.stringify(activeSearchItems);\n    }\n\n    /**\n     * Load data for hierarchy view\n     *\n     * @param {Object} config model config\n     * @param {boolean} reload all currently loaded resIds instead of using\n     *        the config domain\n     * @returns {Object[]} main data for hierarchy view\n     */\n    async _loadData(config, reload = false) {\n        let onlyRoots = false;\n        let domain = config.domain;\n        const resIds = this.resIds;\n        if (reload && resIds.length > 0) {\n            domain = [[\"id\", \"in\", resIds]];\n        } else if (this.isSearchDefaultOrEmpty()) {\n            // If the current SearchModel query is the default one\n            // configured for the action or there is no search query, an\n            // additional constraint is added to only display \"root\"\n            // records (without a parent).\n            onlyRoots = true;\n            domain = !domain.length\n                ? this.defaultDomain\n                : Domain.and([this.defaultDomain, domain]).toList({});\n        }\n        const hierarchyRead = async () => {\n            return await this.orm.call(\n                this.resModel,\n                \"hierarchy_read\",\n                [\n                    domain,\n                    this.fieldsToFetch,\n                    this.parentFieldName,\n                    this.childFieldName,\n                    orderByToString(config.orderBy),\n                ],\n                { context: this.context }\n            );\n        };\n        let result = await hierarchyRead();\n        if (!result.length && onlyRoots) {\n            domain = config.domain;\n            result = await hierarchyRead();\n        }\n        return this._formatData(result);\n    }\n\n    _formatData(data) {\n        const dataStringified = JSON.stringify(data);\n        const recordsPerParentId = {};\n        const recordPerId = {};\n        for (const record of data) {\n            recordPerId[record.id] = record;\n            const parentId = getIdOfMany2oneField(record[this.parentFieldName]);\n            if (!(parentId.toString() in recordsPerParentId)) {\n                recordsPerParentId[parentId] = [];\n            }\n            recordsPerParentId[parentId].push(record);\n        }\n        const formattedData = [];\n        const recordIds = []; // to check if we have only one arborescence to display otherwise we display the data as the kanban view\n        for (const [parentId, records] of Object.entries(recordsPerParentId)) {\n            if (!parentId || !(parentId in recordPerId)) {\n                formattedData.push(...records);\n            } else {\n                const parentRecord = recordPerId[parentId];\n                if (recordIds.includes(parentRecord.id)) {\n                    return JSON.parse(dataStringified);\n                }\n                const ancestorId = getIdOfMany2oneField(parentRecord[this.parentFieldName]);\n                if (ancestorId in recordsPerParentId) {\n                    recordIds.push(...recordsPerParentId[ancestorId].map((r) => r.id));\n                }\n                parentRecord[this.childFieldName || this.defaultChildFieldName] = records;\n            }\n        }\n        if (!formattedData.length && data?.length) {\n            formattedData.push(recordPerId[Object.keys(recordsPerParentId)[0]]);\n        }\n        return formattedData;\n    }\n\n    /**\n     * Create forest\n     *\n     * @param {Object} config model config to use\n     * @param {Object[]} data root data\n     * @returns {HierarchyForest} forest hierarchy\n     */\n    _createRoot(config, data) {\n        return new HierarchyForest(this, config, data);\n    }\n\n    /**\n     * Fetch parent node and its children nodes data\n     *\n     * @param {HierarchyNode} node node to fetch its parent node\n     * @returns {Object} the parent node data with children data inside childFieldName\n     */\n    async _fetchManager(node, exclude_node=true) {\n        let domain = new Domain([\n            \"|\",\n                [\"id\", \"=\", node.parentResId],\n                [this.parentFieldName, \"=\", node.parentResId],\n        ]);\n        if (exclude_node) {\n            domain = Domain.and([\n                domain,\n                [[\"id\", \"!=\", node.resId]],\n            ])\n        }\n        const result = await this.orm.searchRead(\n            this.resModel,\n            domain.toList({}),\n            this.fieldsToFetch,\n            {\n                context: this.context,\n                order: orderByToString(this.config.orderBy),\n            },\n        );\n        let managerData = {};\n        const children = [];\n        for (const data of result) {\n            if (data.id === node.parentResId) {\n                managerData = data;\n            } else {\n                children.push(data);\n            }\n        }\n        if (!this.childFieldName) {\n            if (children.length) {\n                await this._fetchDescendants(children);\n            }\n        }\n        managerData[this.childFieldName || this.defaultChildFieldName] = children;\n        return managerData;\n    }\n\n    /**\n     * Fetch children nodes data for a given node\n     *\n     * @param {HierarchyNode} node node to fetch its children nodes\n     * @param {Array<number> | null} excludeResIds list of ids to exclude (because the nodes already exist)\n     * @returns {Object[]} list of child node data\n     */\n    async _fetchSubordinates(node, excludeResIds = null) {\n        let childrenResIds = node.data[this.childFieldName || this.defaultChildFieldName];\n        if (excludeResIds) {\n            childrenResIds = childrenResIds.filter((childResId) => !excludeResIds.includes(childResId));\n        }\n        const data = await this.orm.searchRead(\n            this.resModel,\n            [[\"id\", \"in\", childrenResIds]],\n            this.fieldsToFetch,\n            {\n                context: this.context,\n                order: orderByToString(this.config.orderBy),\n            },\n        )\n        if (!this.childFieldName) {\n            await this._fetchDescendants(data);\n        }\n        return data;\n    }\n\n    /**\n     * fetch descendants nodes resIds to know if the child nodes have descendants\n     *\n     * @param {Object[]} childrenData child nodes data to fetch its descendants\n     */\n    async _fetchDescendants(childrenData) {\n        const resIds = childrenData.map((d) => d.id);\n        if (resIds.length) {\n            const fetchChildren = await this.orm.readGroup(\n                this.resModel,\n                [[this.parentFieldName, \"in\", resIds]],\n                ['id:array_agg'],\n                [this.parentFieldName],\n                {\n                    context: this.context || {},\n                    orderby: orderByToString(this.config.orderBy),\n                },\n            );\n            const childIdsPerId = Object.fromEntries(\n                fetchChildren.map((r) => [r[this.parentFieldName][0], r.id])\n            );\n            for (const d of childrenData) {\n                if (d.id.toString() in childIdsPerId) {\n                    d[this.defaultChildFieldName] = childIdsPerId[d.id.toString()];\n                }\n            }\n        }\n    }\n\n    /**\n     * ORM call to update the parentId of a record during @see updateParentNode\n     * Can be overridden to not use \"write\".\n     *\n     * @param {HierarchyNode} node node related to the record which parentId\n     *        should be changed\n     * @param {Number} parentResId id of the new parent record\n     */\n    async updateParentId(node, parentResId = false) {\n        return this.orm.write(\n            this.resModel,\n            [node.resId],\n            { [this.parentFieldName]: parentResId },\n            { context: this.context }\n        );\n    }\n\n    /**\n     * @param {Number} nodeId of the node to update\n     * @param {Object} parentInfo\n     * @param {Number} [parentInfo.parentNodeId] nodeId of the parent\n     * @param {Number | false} [parentInfo.parentResId] resId of the parent\n     * @returns {Promise}\n     */\n    async updateParentNode(nodeId, { parentNodeId, parentResId }) {\n        const node = this.root.nodePerNodeId[nodeId];\n        const resId = node.resId;\n        // Validation.\n        if (!node) {\n            return;\n        }\n        const parentNode = parentNodeId ? this.root.nodePerNodeId[parentNodeId] : null;\n        parentResId = parentResId || parentNode?.resId || false;\n        const oldParentNode = node.parentNode;\n        if (\n            (parentNode && !this.validateUpdateParentNode(node, parentNode)) ||\n            parentNode?.resId === oldParentNode?.resId\n        ) {\n            return;\n        }\n        // Hide the node while waiting for the server response.\n        node.hidden = true;\n        this.notify({ scrollTarget: \"none\" });\n        // Update the parent server side.\n        await this.mutex.exec(async () => {\n            try {\n                await this.updateParentId(node, parentResId);\n            } catch (error) {\n                // Show the node again since the operation failed, don't update the view.\n                node.hidden = false;\n                this.notify({ scrollTarget: \"none\" });\n                throw error;\n            }\n        });\n        // Reload impacted records.\n        const domain = this.computeUpdateParentNodeDomain(node, parentResId, parentNode);\n        const data = await this.orm.searchRead(this.resModel, domain, this.fieldsToFetch, {\n            context: this.context,\n            order: orderByToString(this.config.orderBy),\n        });\n        const formattedData = this._formatData(data);\n        // Validate that data coming from the server is still compatible with the current\n        // configuration of the hierarchy.\n        for (const record of formattedData) {\n            if (getIdOfMany2oneField(record[this.parentFieldName]) !== parentResId) {\n                node.hidden = false;\n                this.notify({ scrollTarget: \"none\" });\n                this.notification.add(\n                    _t(\n                        `The parent of \"%s\" was successfully updated. Reloading records to account for other changes.`,\n                        node.data.display_name || node.data.name\n                    ),\n                    { type: \"success\" }\n                );\n                return this.reload();\n            }\n        }\n        // Handle the expanded tree.\n        let nodeToCollapse;\n        const treeExpanded = this._findTreeExpanded();\n        const expandedParentNodeIds =\n            treeExpanded?.root.descendantsParentNodes.map((node) => node.id) || [];\n        if (!node.isLeaf || !expandedParentNodeIds.includes(parentNode?.id)) {\n            // Handle cases where the expanded tree will be altered.\n            // If node is not a leaf, the new expanded tree will contain its descendants.\n            // If parentNode is not a parent in the current expanded tree, it will become one\n            // in the new expanded tree.\n            // Compute the depth of the parent of parentNode. That node is guaranteed to be a\n            // parent in the current expanded tree.\n            const depth = expandedParentNodeIds.findIndex(\n                (id) => id === parentNode?.parentNode?.id\n            );\n            if (depth === -1) {\n                // Drop as root or drop as the child of a root that is not part of the current\n                // expanded tree. The current expanded tree should be fully closed.\n                nodeToCollapse = treeExpanded?.root;\n            } else {\n                // Drop anywhere else (at a position that can be related to the expanded tree with\n                // the depth of the parent of parentNode). In that case the existing hierarchy is\n                // split at the depth of the parent, and will be completed by node's remaining\n                // expanded tree.\n                const nodeIdToCollapse = expandedParentNodeIds.at(depth + 1);\n                if (nodeIdToCollapse) {\n                    nodeToCollapse = treeExpanded?.nodePerNodeId[nodeIdToCollapse];\n                }\n            }\n        } else {\n            // Handle cases where node is a leaf dropped in the current expanded tree. In that case,\n            // the tree is kept open.\n            // Descendants of parentNode will always be reloaded to account for changes caused by\n            // the drop operation.\n            nodeToCollapse = parentNode;\n        }\n        // Update the view.\n        if (oldParentNode) {\n            oldParentNode.removeChildNode(node);\n        } else {\n            node.tree.removeNodes([node]);\n        }\n        nodeToCollapse?.collapseChildNodes();\n        if (!parentNode) {\n            // Drop as root, reset the hierarchy.\n            nodeId = forestId = treeId = 0;\n            this.root = this._createRoot(this.config, formattedData);\n        } else {\n            // Update parentNode data.\n            parentNode.data[this.childFieldName || this.defaultChildFieldName] = formattedData;\n            parentNode.populateChildNodes();\n        }\n        const newNodeId = Object.keys(this.root.nodePerNodeId).find((key) => {\n            return this.root.nodePerNodeId[key].resId === resId;\n        });\n        this.notify({ scrollTarget: newNodeId });\n    }\n\n    validateUpdateParentNode(node, parentNode) {\n        if (parentNode.resId === node.resId) {\n            this.notification.add(_t(\"The parent record cannot be the record dragged.\"), {\n                type: \"danger\",\n            });\n            return false;\n        } else if (node.allSubsidiaryResIds.includes(parentNode.resId)) {\n            this.notification.add(_t(\"Cannot change the parent because it will cause a cyclic.\"), {\n                type: \"danger\",\n            });\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a domain to get a recordSet containing:\n     * - node.\n     * - all children under the new parent.\n     * - all descendants in the final expanded tree (after the operation), which\n     *   are at a depth impacted by the update @see updateParentNode (part\n     *   about the expanded tree).\n     *\n     * @param {HierarchyNode} node that is moving\n     * @param {Number | false} parentResId resId of the parent\n     * @param {HierarchyNode} [parentNode] which receives node as its child\n     *                        (undefined if node is dropped as a root).\n     * @returns {Array} domain\n     */\n    computeUpdateParentNodeDomain(node, parentResId, parentNode) {\n        const domainsOr = [[[\"id\", \"=\", node.resId]]];\n        // Include the new parent children (for ordering).\n        domainsOr.push([[this.parentFieldName, \"=\", parentResId]]);\n        if (!node.isLeaf) {\n            // Include node descendants (keep that part of the expanded tree).\n            const expandedTreeParentResIds = node.descendantsParentNodes.map((node) => node.resId);\n            domainsOr.push([[this.parentFieldName, \"in\", expandedTreeParentResIds]]);\n        } else if (!parentNode) {\n            // Keep the current expanded tree (if any) from its root if node is a leaf dropped as a\n            // root.\n            const expandedTreeParentResIds = node.tree.root.descendantsParentNodes.map(\n                (node) => node.resId\n            );\n            domainsOr.push([[this.parentFieldName, \"in\", expandedTreeParentResIds]]);\n        } else if (!parentNode.isLeaf) {\n            // Keep the current expanded tree (if any) from the target parent if node is a leaf.\n            const expandedTreeParentResIds = parentNode.descendantsParentNodes.map(\n                (node) => node.resId\n            );\n            domainsOr.push([[this.parentFieldName, \"in\", expandedTreeParentResIds]]);\n        }\n        let domain = Domain.or(domainsOr);\n        const globalDomain = this.globalDomain;\n        if (globalDomain.length) {\n            domain = Domain.and([domain, globalDomain]);\n        }\n        return domain.toList({});\n    }\n}\n", "/** @odoo-module */\n\nimport { onWillUnmount, reactive, useEffect, useExternalListener } from \"@odoo/owl\";\nimport { useThrottleForAnimation } from \"@web/core/utils/timing\";\nimport { pick } from \"@web/core/utils/objects\";\nimport { makeDraggableHook } from \"@web/core/utils/draggable_hook_builder\";\n\nconst hookParams = {\n    name: \"useHierarchyNodeDraggable\",\n    acceptedParams: {\n        rows: [String],\n    },\n    defaultParams: {\n        edgeScrolling: { speed: 20, threshold: 60 },\n        rows: null,\n    },\n    onComputeParams({ ctx, params }) {\n        // Row selector\n        ctx.rowSelector = params.rows || null;\n        if (ctx.rowSelector) {\n            ctx.fullSelector = `${ctx.rowSelector} ${ctx.fullSelector}`;\n        }\n    },\n    onDragStart(params) {\n        const { ctx, addListener, callHandler } = params;\n\n        const onElementPointerEnter = (ev) => {\n            const element = ev.currentTarget;\n            current.hierarchyElement = element;\n            callHandler(\"onElementEnter\", { element });\n        };\n\n        const onElementPointerLeave = (ev) => {\n            const element = ev.currentTarget;\n            current.hierarchyElement = null;\n            callHandler(\"onElementLeave\", { element });\n        };\n\n        const onRowPointerEnter = (ev) => {\n            const row = ev.currentTarget;\n            current.hierarchyRow = row;\n            callHandler(\"onRowEnter\", { row });\n        };\n\n        const onRowPointerLeave = (ev) => {\n            const row = ev.currentTarget;\n            current.hierarchyRow = null;\n            callHandler(\"onRowLeave\", { row });\n        };\n\n        const { ref, current, elementSelector, rowSelector } = ctx;\n\n        for (const rowEl of ref.el.querySelectorAll(rowSelector)) {\n            addListener(rowEl, \"pointerenter\", onRowPointerEnter);\n            addListener(rowEl, \"pointerleave\", onRowPointerLeave);\n        }\n\n        for (const siblingEl of ref.el.querySelectorAll(elementSelector)) {\n            if (siblingEl !== current.element) {\n                addListener(siblingEl, \"pointerenter\", onElementPointerEnter);\n                addListener(siblingEl, \"pointerleave\", onElementPointerLeave);\n            }\n        }\n\n        return pick(current, \"element\", \"row\");\n    },\n    onDragEnd({ ctx }) {\n        return pick(ctx.current, \"element\", \"row\", \"hierarchyRow\");\n    },\n    onDrop({ ctx }) {\n        const { current } = ctx;\n        const rowElement = current.hierarchyRow;\n        const element = current.hierarchyElement;\n        if ((rowElement && rowElement !== current.row) || element) {\n            return {\n                element: current.element,\n                row: current.row,\n                nextRow: rowElement && current.row !== rowElement ? rowElement : null,\n                newParentNode: element,\n            };\n        }\n    },\n    onWillStartDrag({ ctx }) {\n        const { current, rowSelector } = ctx;\n\n        if (rowSelector) {\n            current.row = current.element.closest(rowSelector);\n        }\n\n        return pick(current, \"element\", \"row\");\n    },\n};\n\nexport function useHierarchyNodeDraggable(params) {\n    const setupHooks = {\n        addListener: useExternalListener,\n        setup: useEffect,\n        teardown: onWillUnmount,\n        throttle: useThrottleForAnimation,\n        wrapState: reactive,\n    }\n    return makeDraggableHook({ ...hookParams, setupHooks })(params);\n}\n", "/** @odoo-module */\n\nimport { Component, useRef, onPatched } from \"@odoo/owl\";\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useBus, useService } from \"@web/core/utils/hooks\";\nimport { scrollTo } from \"@web/core/utils/scrolling\";\n\nimport { HierarchyCard } from \"./hierarchy_card\";\nimport { useHierarchyNodeDraggable } from \"./hierarchy_node_draggable\";\n\nexport class HierarchyRenderer extends Component {\n    static components = {\n        HierarchyCard,\n    };\n    static props = {\n        model: Object,\n        openRecord: Function,\n        archInfo: Object,\n        templates: Object,\n    };\n    static template = \"web_hierarchy.HierarchyRenderer\";\n\n    setup() {\n        this.rendererRef = useRef(\"renderer\");\n        this.notification = useService(\"notification\");\n        if (this.canDragAndDropRecord) {\n            useHierarchyNodeDraggable({\n                ref: this.rendererRef,\n                enable: this.draggable,\n                elements: \".o_hierarchy_node_container\",\n                handle: \".o_hierarchy_node\",\n                rows: \".o_hierarchy_row\",\n                ignore: \"button\",\n                onDragStart: ({ addClass, element }) => {\n                    addClass(element, \"o_hierarchy_dragged\");\n                    addClass(element.querySelector(\".o_hierarchy_node\"), \"shadow\");\n                },\n                onDragEnd: ({ removeClass, element, row, hierarchyRow }) => {\n                    removeClass(element, \"o_hierarchy_dragged\");\n                    if (row) {\n                        removeClass(row, \"o_hierarchy_hover\");\n                    }\n                    if (hierarchyRow) {\n                        removeClass(hierarchyRow, \"o_hierarchy_hover\");\n                    }\n                },\n                onDrop: (params) => {\n                    this.nodeDrop(params);\n                },\n                onElementEnter: ({ addClass, element }) => {\n                    addClass(element, \"o_hierarchy_hover\");\n                },\n                onElementLeave: ({ removeClass, element }) => {\n                    removeClass(element, \"o_hierarchy_hover\");\n                },\n                onRowEnter: ({ addClass, row }) => {\n                    addClass(row, \"o_hierarchy_hover\");\n                },\n                onRowLeave: ({ removeClass, row }) => {\n                    removeClass(row, \"o_hierarchy_hover\");\n                },\n            });\n        }\n        this.scrollTarget = \"none\";\n        useBus(this.props.model.bus, \"hierarchyScrollTarget\", (ev) => {\n            this.scrollTarget = ev.detail?.scrollTarget || \"none\";\n        });\n        onPatched(this.onPatched);\n    }\n\n    onPatched() {\n        if (this.scrollTarget === \"none\") {\n            return;\n        }\n        const row =\n            this.scrollTarget === \"bottom\"\n                ? this.rendererRef.el.querySelector(\":scope .o_hierarchy_row:last-child\")\n                : this.rendererRef.el\n                      .querySelector(\n                          `:scope .o_hierarchy_node[data-node-id=\"${this.scrollTarget}\"]`\n                      )\n                      ?.closest(\".o_hierarchy_row\");\n        this.scrollTarget = \"none\";\n        if (!row) {\n            return;\n        }\n        scrollTo(row, { behavior: \"smooth\" });\n    }\n\n    get canDragAndDropRecord() {\n        return this.draggable && !this.env.isSmall;\n    }\n\n    get draggable() {\n        return this.props.archInfo.draggable;\n    }\n\n    get rows() {\n        const rootNodes = this.props.model.root.rootNodes.filter((n) => !n.hidden);\n        const rows = [{ nodes: rootNodes }];\n        const processNode = (node) => {\n            if (!node.isLeaf) {\n                const subNodes = node.nodes.filter((n) => !n.hidden);\n                rows.push({ parentNode: node, nodes: subNodes });\n                for (const subNode of subNodes) {\n                    processNode(subNode);\n                }\n            }\n        };\n\n        for (const node of this.props.model.root.rootNodes) {\n            processNode(node);\n        }\n\n        return rows;\n    }\n\n    async nodeDrop({ element, row, nextRow, newParentNode }) {\n        let parentNodeId, parentResId;\n        if (newParentNode) {\n            parentNodeId = newParentNode.dataset.nodeId;\n        } else if (nextRow?.dataset.rowId !== row.dataset.rowId) {\n            parentNodeId = nextRow.dataset.parentNodeId;\n            if (!parentNodeId) {\n                const nodes = this.rows[nextRow.dataset.rowId].nodes || [];\n                if (nodes) {\n                    parentNodeId = nodes[0].parentNode?.id;\n                    if (!parentNodeId) {\n                        parentResId = nodes[0].parentResId;\n                        if (!nodes.every((node) => node.parentResId === parentResId)) {\n                            this.notification.add(\n                                _t(\"Impossible to update the parent node of the dragged node because no parent has been found.\"),\n                                {\n                                    type: \"danger\",\n                                }\n                            );\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        await this.props.model.updateParentNode(element.dataset.nodeId, { parentResId, parentNodeId });\n    }\n}\n", "import { registry } from \"@web/core/registry\";\nimport { HierarchyArchParser } from \"./hierarchy_arch_parser\";\nimport { HierarchyController } from \"./hierarchy_controller\";\nimport { HierarchyModel } from \"./hierarchy_model\";\nimport { HierarchyRenderer } from \"./hierarchy_renderer\";\n\nexport const hierarchyView = {\n    type: \"hierarchy\",\n    ArchParser: HierarchyArchParser,\n    Controller: HierarchyController,\n    Model: HierarchyModel,\n    Renderer: HierarchyRenderer,\n    buttonTemplate: \"web_hierarchy.HierarchyButtons\",\n    searchMenuTypes: [\"filter\"],\n\n    props: (genericProps, view) => {\n        const { ArchParser, Model, Renderer, buttonTemplate: viewButtonTemplate } = view;\n        const { arch, relatedModels, resModel, buttonTemplate } = genericProps;\n        return {\n            ...genericProps,\n            archInfo: new ArchParser().parse(arch, relatedModels, resModel),\n            buttonTemplate: buttonTemplate || viewButtonTemplate,\n            Model,\n            Renderer,\n        };\n    }\n}\n\nregistry.category(\"views\").add(\"hierarchy\", hierarchyView);\n", "/** @odoo-module */\n\nimport { HierarchyCard } from \"@web_hierarchy/hierarchy_card\";\n\nexport class HrEmployeeHierarchyCard extends HierarchyCard {\n    static template = \"hr_org_chart.HrEmployeeHierarchyCard\";\n}\n", "/** @odoo-module **/\n\nimport { Avatar } from \"@mail/views/web/fields/avatar/avatar\";\n\nimport { HierarchyRenderer } from \"@web_hierarchy/hierarchy_renderer\";\nimport { HrEmployeeHierarchyCard } from \"./hr_employee_hierarchy_card\";\n\nexport class HrEmployeeHierarchyRenderer extends HierarchyRenderer {\n    static template = \"hr_org_chart.HrEmployeeHierarchyRenderer\";\n    static components = {\n        ...HierarchyRenderer.components,\n        HierarchyCard: HrEmployeeHierarchyCard,\n        Avatar,\n    };\n}\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { hierarchyView } from \"@web_hierarchy/hierarchy_view\";\nimport { HrEmployeeHierarchyRenderer } from \"./hr_employee_hierarchy_renderer\";\nimport { HierarchyController } from \"@web_hierarchy/hierarchy_controller\";\nimport { HrActionHelper } from \"@hr/views/hr_action_helper\";\n\nexport class HrEmployeeHierarchyController extends HierarchyController {\n    static template = \"hr_org_chart.HierarchyView\";\n    static components = { ...HierarchyController.components, HrActionHelper };\n}\n\nexport const hrEmployeeHierarchyView = {\n    ...hierarchyView,\n    Controller: HrEmployeeHierarchyController,\n    Renderer: HrEmployeeHierarchyRenderer,\n};\n\nregistry.category(\"views\").add(\"hr_employee_hierarchy\", hrEmployeeHierarchyView);\n"], "file": "/web/assets/52b3a2f/web.assets_backend_lazy.js", "sourceRoot": "../../../"}