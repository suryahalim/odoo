
/***************************************************************
*  Filepath: /web/static/src/views/graph/graph_arch_parser.js  *
*  Lines: 101                                                  *
***************************************************************/
odoo.define('@web/views/graph/graph_arch_parser', ['@web/core/utils/strings', '@web/core/utils/xml', '@web/search/utils/misc'], function (require) {
'use strict';
let __exports = {};
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");
const { GROUPABLE_TYPES } = require("@web/search/utils/misc");

const MODES = ["bar", "line", "pie"];
const ORDERS = ["ASC", "DESC", "asc", "desc", null];

const GraphArchParser = __exports.GraphArchParser = class GraphArchParser {
    parse(arch, fields = {}) {
        const archInfo = { fields, fieldAttrs: {}, groupBy: [], measures: [] };
        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "graph": {
                    if (node.hasAttribute("disable_linking")) {
                        archInfo.disableLinking = exprToBoolean(
                            node.getAttribute("disable_linking")
                        );
                    }
                    if (node.hasAttribute("stacked")) {
                        archInfo.stacked = exprToBoolean(node.getAttribute("stacked"));
                    }
                    if (node.hasAttribute("cumulated")) {
                        archInfo.cumulated = exprToBoolean(node.getAttribute("cumulated"));
                    }
                    if (node.hasAttribute("cumulated_start")) {
                        archInfo.cumulatedStart = exprToBoolean(
                            node.getAttribute("cumulated_start")
                        );
                    }
                    const mode = node.getAttribute("type");
                    if (mode && MODES.includes(mode)) {
                        archInfo.mode = mode;
                    }
                    const order = node.getAttribute("order");
                    if (order && ORDERS.includes(order)) {
                        archInfo.order = order.toUpperCase();
                    }
                    const title = node.getAttribute("string");
                    if (title) {
                        archInfo.title = title;
                    }
                    break;
                }
                case "field": {
                    const fieldName = node.getAttribute("name"); // exists (rng validation)
                    if (fieldName === "id") {
                        break;
                    }
                    const string = node.getAttribute("string");
                    if (string) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].string = string;
                    }
                    const widget = node.getAttribute("widget");
                    if (widget) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].widget = widget;
                    }
                    if (
                        node.getAttribute("invisible") === "True" ||
                        node.getAttribute("invisible") === "1"
                    ) {
                        if (!archInfo.fieldAttrs[fieldName]) {
                            archInfo.fieldAttrs[fieldName] = {};
                        }
                        archInfo.fieldAttrs[fieldName].isInvisible = true;
                        break;
                    }
                    const isMeasure = node.getAttribute("type") === "measure";
                    if (isMeasure) {
                        archInfo.measures.push(fieldName);
                        // the last field with type="measure" (if any) will be used as measure else __count
                        archInfo.measure = fieldName;
                    } else {
                        const { type } = archInfo.fields[fieldName]; // exists (rng validation)
                        if (GROUPABLE_TYPES.includes(type)) {
                            let groupBy = fieldName;
                            const interval = node.getAttribute("interval");
                            if (interval) {
                                groupBy += `:${interval}`;
                            }
                            archInfo.groupBy.push(groupBy);
                        }
                    }
                    break;
                }
            }
        });
        return archInfo;
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web/static/src/views/graph/graph_controller.js  *
*  Lines: 65                                                  *
**************************************************************/
odoo.define('@web/views/graph/graph_controller', ['@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, useRef } = require("@odoo/owl");

const GraphController = __exports.GraphController = class GraphController extends Component {
    static template = "web.GraphView";
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);

        useSetupAction({
            rootRef: useRef("root"),
            getLocalState: () => {
                return { metaData: this.model.metaData };
            },
            getContext: () => this.getContext(),
        });
        this.searchBarToggler = useSearchBarToggler();
    }

    /**
     * @returns {Object}
     */
    getContext() {
        // expand context object? change keys?
        const { measure, groupBy, mode } = this.model.metaData;
        const context = {
            graph_measure: measure,
            graph_mode: mode,
            graph_groupbys: groupBy.map((gb) => gb.spec),
        };
        if (mode !== "pie") {
            context.graph_order = this.model.metaData.order;
            context.graph_stacked = this.model.metaData.stacked;
            if (mode === "line") {
                context.graph_cumulated = this.model.metaData.cumulated;
            }
        }
        return context;
    }

    loadAll() {
        return this.model.forceLoadAll();
    }
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web/static/src/views/graph/graph_model.js  *
*  Lines: 671                                            *
*********************************************************/
odoo.define('@web/views/graph/graph_model', ['@web/core/l10n/translation', '@web/core/utils/arrays', '@web/core/utils/concurrency', '@web/search/utils/dates', '@web/search/utils/group_by', '@web/search/utils/misc', '@web/model/model', '@web/views/utils', '@web/core/domain'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { sortBy, groupBy } = require("@web/core/utils/arrays");
const { KeepLast, Race } = require("@web/core/utils/concurrency");
const { rankInterval } = require("@web/search/utils/dates");
const { getGroupBy } = require("@web/search/utils/group_by");
const { GROUPABLE_TYPES } = require("@web/search/utils/misc");
const { addPropertyFieldDefs, Model } = require("@web/model/model");
const { computeReportMeasures, processMeasure } = require("@web/views/utils");
const { Domain } = require("@web/core/domain");

const SEP = __exports.SEP = " / ";
const DATA_LIMIT = 80;

const SEQUENTIAL_TYPES = __exports.SEQUENTIAL_TYPES = ["date", "datetime"];

/**
 * @typedef {import("@web/search/search_model").SearchParams} SearchParams
 */

class DateClasses {
    // We view the param "array" as a matrix of values and undefined.
    // An equivalence class is formed of defined values of a column.
    // So nothing has to do with dates but we only use Dateclasses to manage
    // identification of dates.
    /**
     * @param {(any[])[]} array
     */
    constructor(array) {
        this.__referenceIndex = null;
        this.__array = array;
        for (let i = 0; i < this.__array.length; i++) {
            const arr = this.__array[i];
            if (arr.length && this.__referenceIndex === null) {
                this.__referenceIndex = i;
            }
        }
    }

    /**
     * @param {number} index
     * @param {any} o
     * @returns {string}
     */
    classLabel(index, o) {
        return `${this.__array[index].indexOf(o)}`;
    }

    /**
     * @param {string} classLabel
     * @returns {any[]}
     */
    classMembers(classLabel) {
        const classNumber = Number(classLabel);
        const classMembers = new Set();
        for (const arr of this.__array) {
            if (arr[classNumber] !== undefined) {
                classMembers.add(arr[classNumber]);
            }
        }
        return [...classMembers];
    }

    /**
     * @param {string} classLabel
     * @param {number} [index]
     * @returns {any}
     */
    representative(classLabel, index) {
        const classNumber = Number(classLabel);
        const i = index === undefined ? this.__referenceIndex : index;
        if (i === null) {
            return null;
        }
        return this.__array[i][classNumber];
    }

    /**
     * @param {number} index
     * @returns {number}
     */
    arrayLength(index) {
        return this.__array[index].length;
    }
}

const GraphModel = __exports.GraphModel = class GraphModel extends Model {
    /**
     * @override
     */
    setup(params) {
        // concurrency management
        this.keepLast = new KeepLast();
        this.race = new Race();
        const _fetchDataPoints = this._fetchDataPoints.bind(this);
        this._fetchDataPoints = (...args) => {
            return this.race.add(_fetchDataPoints(...args));
        };

        this.initialGroupBy = null;

        this.metaData = params;
        this.data = null;
        this.searchParams = null;
        // This dataset will be added as a line plot on top of stacked bar chart.
        this.lineOverlayDataset = null;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        this.searchParams = searchParams;
        if (!this.initialGroupBy) {
            this.initialGroupBy = searchParams.context.graph_groupbys || this.metaData.groupBy; // = arch groupBy --> change that
        }
        const metaData = this._buildMetaData();
        await addPropertyFieldDefs(
            this.orm,
            metaData.resModel,
            searchParams.context,
            metaData.fields,
            metaData.groupBy.map((gb) => gb.fieldName)
        );
        await this._fetchDataPoints(metaData);
    }

    async forceLoadAll() {
        const metaData = this._buildMetaData();
        await this._fetchDataPoints(metaData, true);
        this.notify();
    }

    /**
     * @override
     */
    hasData() {
        return this.dataPoints.length > 0;
    }

    /**
     * Only supposed to be called to change one or several parameters among
     * "measure", "mode", "order", "stacked" and "cumulated".
     * @param {Object} params
     */
    async updateMetaData(params) {
        if ("measure" in params) {
            const metaData = this._buildMetaData(params);
            await this._fetchDataPoints(metaData);
            this.useSampleModel = false;
        } else {
            await this.race.getCurrentProm();
            this.metaData = Object.assign({}, this.metaData, params);
            this._prepareData();
        }
        this.notify();
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    /**
     * @protected
     * @param {Object} [params={}]
     * @returns {Object}
     */
    _buildMetaData(params) {
        const { comparison, domain, context, groupBy } = this.searchParams;

        const metaData = Object.assign({}, this.metaData, { context });
        if (comparison) {
            metaData.domains = comparison.domains;
            metaData.comparisonField = comparison.fieldName;
        } else {
            metaData.domains = [{ arrayRepr: domain, description: null }];
        }
        metaData.measure = context.graph_measure || metaData.measure;
        metaData.mode = context.graph_mode || metaData.mode;
        metaData.groupBy = groupBy.length ? groupBy : this.initialGroupBy;
        if (metaData.mode !== "pie") {
            metaData.order = "graph_order" in context ? context.graph_order : metaData.order;
            if (comparison) {
                metaData.stacked = false;
            } else if ("graph_stacked" in context) {
                metaData.stacked = context.graph_stacked;
            }
            if (metaData.mode === "line") {
                metaData.cumulated =
                    "graph_cumulated" in context ? context.graph_cumulated : metaData.cumulated;
            }
        }

        this._normalize(metaData);

        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [
            ...(metaData.viewMeasures || []),
            metaData.measure,
        ]);

        return Object.assign(metaData, params);
    }

    /**
     * Fetch the data points determined by the metaData. This function has
     * several side effects. It can alter this.metaData and set this.dataPoints.
     * @protected
     * @param {Object} metaData
     * @param {boolean} [forceUseAllDataPoints=false]
     */
    async _fetchDataPoints(metaData, forceUseAllDataPoints = false) {
        this.dataPoints = await this.keepLast.add(this._loadDataPoints(metaData));
        this.metaData = metaData;
        this._prepareData(forceUseAllDataPoints);
    }

    /**
     * Separates dataPoints coming from the read_group(s) into different
     * datasets. This function returns the parameters data and labels used
     * to produce the charts.
     * @protected
     * @param {Object[]} dataPoints
     * @param {boolean} forceUseAllDataPoints
     * @returns {Object}
     */
    _getData(dataPoints, forceUseAllDataPoints) {
        const { comparisonField, groupBy, mode } = this.metaData;

        let identify = false;
        if (comparisonField && groupBy.length && groupBy[0].fieldName === comparisonField) {
            identify = true;
        }
        const dateClasses = identify ? this._getDateClasses(dataPoints) : null;

        const dataPtMapping = new WeakMap();
        const datasetsTmp = {};
        let exceeds = false;

        // dataPoints --> labels
        let labels = [];
        const labelMap = {};
        for (const dataPt of dataPoints) {
            const datasetLabel = this._getDatasetLabel(dataPt);
            if (!(datasetLabel in datasetsTmp)) {
                if (!forceUseAllDataPoints && Object.keys(datasetsTmp).length >= DATA_LIMIT) {
                    exceeds = true;
                    continue;
                }
                datasetsTmp[datasetLabel] = {
                    label: datasetLabel,
                    originIndex: dataPt.originIndex,
                }; // add the entry but don't initialize it entirely
            }
            dataPtMapping.set(dataPt, datasetsTmp[datasetLabel]);

            const x = dataPt.labels.slice(0, mode === "pie" ? undefined : 1);
            const trueLabel = x.length ? x.join(SEP) : _t("Total");
            if (dateClasses) {
                x[0] = dateClasses.classLabel(dataPt.originIndex, x[0]);
            }
            const key = JSON.stringify(x);
            if (labelMap[key] === undefined) {
                labelMap[key] = labels.length;
                if (dateClasses) {
                    if (mode === "pie") {
                        x[0] = dateClasses.classMembers(x[0]).join(", ");
                    } else {
                        x[0] = dateClasses.representative(x[0]);
                    }
                }
                const label = x.length ? x.join(SEP) : _t("Total");
                labels.push(label);
            }
            dataPt.labelIndex = labelMap[key];
            dataPt.trueLabel = trueLabel;
        }

        // dataPoints + labels --> datasetsTmp --> datasets
        for (const dataPt of dataPoints) {
            if (!dataPtMapping.has(dataPt)) {
                continue;
            }

            const {
                domain,
                labelIndex,
                originIndex,
                trueLabel,
                value,
                identifier,
                cumulatedStart,
            } = dataPt;
            const dataset = dataPtMapping.get(dataPt);
            if (!dataset.data) {
                let dataLength = labels.length;
                if (mode !== "pie" && dateClasses) {
                    dataLength = dateClasses.arrayLength(originIndex);
                }
                Object.assign(dataset, {
                    data: new Array(dataLength).fill(0),
                    cumulatedStart,
                    trueLabels: labels.slice(0, dataLength), // should be good // check this in case identify = true
                    domains: new Array(dataLength).fill([]),
                    identifiers: new Set(),
                });
            }
            dataset.data[labelIndex] = value;
            dataset.domains[labelIndex] = domain;
            dataset.trueLabels[labelIndex] = trueLabel;
            dataset.identifiers.add(identifier);
        }
        // sort by origin
        let datasets = sortBy(Object.values(datasetsTmp), "originIndex");

        if (mode === "pie") {
            // We kinda have a matrix. We remove the zero columns and rows. This is a global operation.
            // That's why it cannot be done before.
            datasets = datasets.filter((dataset) => dataset.data.some((v) => Boolean(v)));
            const labelsToKeepIndexes = {};
            labels.forEach((_, index) => {
                if (datasets.some((dataset) => Boolean(dataset.data[index]))) {
                    labelsToKeepIndexes[index] = true;
                }
            });
            labels = labels.filter((_, index) => labelsToKeepIndexes[index]);
            for (const dataset of datasets) {
                dataset.data = dataset.data.filter((_, index) => labelsToKeepIndexes[index]);
                dataset.domains = dataset.domains.filter((_, index) => labelsToKeepIndexes[index]);
                dataset.trueLabels = dataset.trueLabels.filter(
                    (_, index) => labelsToKeepIndexes[index]
                );
            }
        }

        return {
            datasets,
            labels,
            exceeds,
        };
    }

    _getLabel(description) {
        if (!description) {
            return _t("Sum");
        } else {
            return _t("Sum (%s)", description);
        }
    }

    _getLineOverlayDataset() {
        const { domains, stacked } = this.metaData;
        const data = this.data;
        let lineOverlayDataset = null;
        if (stacked) {
            const stacks = groupBy(data.datasets, (dataset) => dataset.originIndex);
            if (Object.keys(stacks).length == 1) {
                const [[originIndex, datasets]] = Object.entries(stacks);
                if (datasets.length > 1) {
                    const data = [];
                    for (const dataset of datasets) {
                        for (let i = 0; i < dataset.data.length; i++) {
                            data[i] = (data[i] || 0) + dataset.data[i];
                        }
                    }
                    lineOverlayDataset = {
                        label: this._getLabel(domains[originIndex].description),
                        data,
                        trueLabels: datasets[0].trueLabels,
                    };
                }
            }
        }
        return lineOverlayDataset;
    }

    /**
     * Determines the dataset to which the data point belongs.
     * @protected
     * @param {Object} dataPoint
     * @returns {string}
     */
    _getDatasetLabel(dataPoint) {
        const { measure, measures, domains, mode } = this.metaData;
        const { labels, originIndex } = dataPoint;
        if (mode === "pie") {
            return domains[originIndex].description || "";
        }
        // ([origin] + second to last groupBys) or measure
        let datasetLabel = labels.slice(1).join(SEP);
        if (domains.length > 1) {
            datasetLabel =
                domains[originIndex].description + (datasetLabel ? SEP + datasetLabel : "");
        }
        datasetLabel = datasetLabel || measures[measure].string;
        return datasetLabel;
    }

    /**
     * @protected
     * @param {Object[]} dataPoints
     * @returns {DateClasses}
     */
    _getDateClasses(dataPoints) {
        const { domains } = this.metaData;
        const dateSets = domains.map(() => new Set());
        for (const { labels, originIndex } of dataPoints) {
            const date = labels[0];
            dateSets[originIndex].add(date);
        }
        const arrays = dateSets.map((dateSet) => [...dateSet]);
        return new DateClasses(arrays);
    }

    /**
     * @protected
     * @returns {string}
     */
    _getDefaultFilterLabel(field) {
        return _t("None");
    }

    /**
     * Eventually filters and sort data points.
     * @protected
     * @returns {Object[]}
     */
    _getProcessedDataPoints() {
        const { domains, groupBy, mode, order } = this.metaData;
        let processedDataPoints = [];
        if (mode === "line") {
            processedDataPoints = this.dataPoints.filter(
                (dataPoint) => dataPoint.labels[0] !== this._getDefaultFilterLabel(groupBy[0])
            );
        } else if (mode === "pie") {
            processedDataPoints = this.dataPoints.filter(
                (dataPoint) => dataPoint.value > 0 && dataPoint.count !== 0
            );
        } else {
            processedDataPoints = this.dataPoints.filter((dataPoint) => dataPoint.count !== 0);
        }

        if (order !== null && mode !== "pie" && domains.length === 1 && groupBy.length > 0) {
            // group data by their x-axis value, and then sort datapoints
            // based on the sum of values by group in ascending/descending order
            const groupedDataPoints = {};
            for (const dataPt of processedDataPoints) {
                const key = dataPt.labels[0]; // = x-axis value under the current assumptions
                if (!groupedDataPoints[key]) {
                    groupedDataPoints[key] = [];
                }
                groupedDataPoints[key].push(dataPt);
            }
            const groups = Object.values(groupedDataPoints);
            const groupTotal = (group) => group.reduce((sum, dataPt) => sum + dataPt.value, 0);
            processedDataPoints = sortBy(groups, groupTotal, order.toLowerCase()).flat();
        }

        return processedDataPoints;
    }

    /**
     * Fetch and process graph data.  It is basically a(some) read_group(s)
     * with correct fields for each domain.  We have to do some light processing
     * to separate date groups in the field list, because they can be defined
     * with an aggregation function, such as my_date:week.
     * @protected
     * @param {Object} metaData
     * @returns {Object[]}
     */
    async _loadDataPoints(metaData) {
        const { measure, domains, fields, groupBy, resModel, cumulatedStart } = metaData;
        const fieldName = groupBy[0]?.fieldName;
        const sequential_field =
            cumulatedStart && SEQUENTIAL_TYPES.includes(fields[fieldName]?.type) ? fieldName : null;
        const sequential_spec = sequential_field && groupBy[0].spec;
        const measures = ["__count"];
        if (measure !== "__count") {
            let { aggregator, type } = fields[measure];
            if (type === "many2one") {
                aggregator = "count_distinct";
            }
            if (aggregator === undefined) {
                throw new Error(
                    `No aggregate function has been provided for the measure '${measure}'`
                );
            }
            measures.push(`${measure}:${aggregator}`);
        }

        const numbering = {}; // used to avoid ambiguity with many2one with values with same labels:
        // for instance [1, "ABC"] [3, "ABC"] should be distinguished.

        const proms = domains.map(async (domain, originIndex) => {
            const data = await this.orm.webReadGroup(
                resModel,
                domain.arrayRepr,
                measures,
                groupBy.map((gb) => gb.spec),
                {
                    lazy: false, // what is this thing???
                    context: { fill_temporal: true, ...this.searchParams.context },
                }
            );
            let start = false;
            if (
                cumulatedStart &&
                sequential_field &&
                data.groups.length &&
                domain.arrayRepr.some((leaf) => leaf.length === 3 && leaf[0] == sequential_field)
            ) {
                const first_date = data.groups[0].__range[sequential_spec].from;
                const new_domain = Domain.combine(
                    [
                        new Domain([[sequential_field, "<", first_date]]),
                        Domain.removeDomainLeaves(domain.arrayRepr, [sequential_field]),
                    ],
                    "AND"
                ).toList();
                start = await this.orm.webReadGroup(
                    resModel,
                    new_domain,
                    measures,
                    groupBy.filter((gb) => gb.fieldName != sequential_field).map((gb) => gb.spec),
                    {
                        lazy: false, // what is this thing???
                        context: { ...this.searchParams.context },
                    }
                );
            }
            const dataPoints = [];
            const cumulatedStartValue = {};
            if (start) {
                for (const group of start.groups) {
                    const rawValues = [];
                    for (const gb of groupBy.filter((gb) => gb.fieldName != sequential_field)) {
                        rawValues.push({ [gb.spec]: group[gb.spec] });
                    }
                    cumulatedStartValue[JSON.stringify(rawValues)] = group[measure];
                }
            }
            for (const group of data.groups) {
                const { __domain, __count } = group;
                const labels = [];
                const rawValues = [];
                for (const gb of groupBy) {
                    let label;
                    const val = group[gb.spec];
                    rawValues.push({ [gb.spec]: val });
                    const fieldName = gb.fieldName;
                    const { type } = fields[fieldName];
                    if (type === "boolean") {
                        label = `${val}`; // toUpperCase?
                    } else if (val === false) {
                        label = this._getDefaultFilterLabel(gb);
                    } else if (["many2many", "many2one"].includes(type)) {
                        const [id, name] = val;
                        const key = JSON.stringify([fieldName, name]);
                        if (!numbering[key]) {
                            numbering[key] = {};
                        }
                        const numbers = numbering[key];
                        if (!numbers[id]) {
                            numbers[id] = Object.keys(numbers).length + 1;
                        }
                        const num = numbers[id];
                        label = num === 1 ? name : `${name} (${num})`;
                    } else if (type === "selection") {
                        const selected = fields[fieldName].selection.find((s) => s[0] === val);
                        label = selected[1];
                    } else {
                        label = val;
                    }
                    labels.push(label);
                }

                let value = group[measure];
                if (value instanceof Array) {
                    // case where measure is a many2one and is used as groupBy
                    value = 1;
                }
                if (!Number.isInteger(value)) {
                    metaData.allIntegers = false;
                }
                const group_id = JSON.stringify(rawValues.slice(1));
                dataPoints.push({
                    count: __count,
                    domain: __domain,
                    value,
                    labels,
                    originIndex,
                    identifier: JSON.stringify(rawValues),
                    cumulatedStart: cumulatedStartValue[group_id] || 0,
                });
            }
            return dataPoints;
        });
        const promResults = await Promise.all(proms);
        return promResults.flat();
    }

    /**
     * Process metaData.groupBy in order to keep only the finest interval option for
     * elements based on date/datetime field (e.g. 'date:year'). This means that
     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.
     * For instance,
     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].
     * @protected
     * @param {Object} metaData
     */
    _normalize(metaData) {
        const { fields } = metaData;
        const groupBy = [];
        for (const gb of metaData.groupBy) {
            let ngb = gb;
            if (typeof gb === "string") {
                ngb = getGroupBy(gb, fields);
            }
            groupBy.push(ngb);
        }

        const processedGroupBy = [];
        for (const gb of groupBy) {
            const { fieldName, interval } = gb;
            if (!fieldName.includes(".")) {
                const { groupable, type } = fields[fieldName];
                if (
                    // cf. _description_groupable in odoo/fields.py
                    !groupable ||
                    ["id", "__count"].includes(fieldName) ||
                    !GROUPABLE_TYPES.includes(type)
                ) {
                    continue;
                }
            }
            const index = processedGroupBy.findIndex((gb) => gb.fieldName === fieldName);
            if (index === -1) {
                processedGroupBy.push(gb);
            } else if (interval) {
                const registeredInterval = processedGroupBy[index].interval;
                if (rankInterval(registeredInterval) < rankInterval(interval)) {
                    processedGroupBy.splice(index, 1, gb);
                }
            }
        }
        metaData.groupBy = processedGroupBy;

        metaData.measure = processMeasure(metaData.measure);
    }

    /**
     * @protected
     * @param {boolean} [forceUseAllDataPoints=false]
     */
    _prepareData(forceUseAllDataPoints = false) {
        const processedDataPoints = this._getProcessedDataPoints();
        this.data = this._getData(processedDataPoints, forceUseAllDataPoints);
        this.lineOverlayDataset = null;
        if (this.metaData.mode === "bar") {
            this.lineOverlayDataset = this._getLineOverlayDataset();
        }
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web/static/src/views/graph/graph_renderer.js  *
*  Lines: 932                                               *
************************************************************/
odoo.define('@web/views/graph/graph_renderer', ['@web/core/l10n/translation', '@web/core/colors/colors', '@web/core/registry', '@web/views/fields/formatters', '@web/views/graph/graph_model', '@web/core/utils/arrays', '@web/core/assets', '@web/core/utils/render', '@web/core/utils/hooks', '@odoo/owl', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/browser/cookie', '@web/views/view_components/report_view_measures'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const {
    getBorderWhite,
    DEFAULT_BG,
    getColor,
    getCustomColor,
    lightenColor,
    darkenColor,
} = require("@web/core/colors/colors");
const { registry } = require("@web/core/registry");
const { formatFloat } = require("@web/views/fields/formatters");
const { SEP } = require("@web/views/graph/graph_model");
const { sortBy } = require("@web/core/utils/arrays");
const { loadBundle } = require("@web/core/assets");
const { renderToString } = require("@web/core/utils/render");
const { useService } = require("@web/core/utils/hooks");

const { Component, onWillUnmount, useEffect, useRef, onWillStart } = require("@odoo/owl");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { cookie } = require("@web/core/browser/cookie");
const { ReportViewMeasures } = require("@web/views/view_components/report_view_measures");

const NO_DATA = _t("No data");
const formatters = registry.category("formatters");

const colorScheme = cookie.get("color_scheme");
const GRAPH_LEGEND_COLOR = getCustomColor(colorScheme, "#111827", "#ffffff");
const GRAPH_GRID_COLOR = getCustomColor(colorScheme, "rgba(0,0,0,.1)", "rgba(255,255,255,.15");
const GRAPH_LABEL_COLOR = getCustomColor(colorScheme, "#111827", "#E4E4E4");
const NO_DATA_COLOR = getCustomColor(colorScheme, DEFAULT_BG, "#3C3E4B");

/**
 * Custom Plugin for Line chart:
 * Draw the scale grid on top of the chart to
 * see this last one correctly.
 */
const gridOnTop = {
    id: "gridOnTop",
    afterDraw: (chart) => {
        const elements = chart.getDatasetMeta(0).data || [];
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const yAxis = chart.scales.y;
        const xAxis = chart.scales.x;

        ctx.lineWidth = 1;
        ctx.strokeStyle = GRAPH_GRID_COLOR;

        // Draw Y axis scale
        yAxis.ticks.forEach((value, index) => {
            const y = yAxis.getPixelForTick(index);
            ctx.beginPath();
            // Draw the line scale
            ctx.moveTo(chartArea.left, y);
            ctx.lineTo(chartArea.right, y);
            // Draw the tick mark
            ctx.moveTo(chartArea.left - 8, y);
            ctx.lineTo(chartArea.left, y);
            ctx.setLineDash([]);
            ctx.stroke();
        });

        // Draw X axis tick marks
        xAxis.ticks.forEach((value, tickIndex) => {
            const x = xAxis.getPixelForTick(tickIndex);
            ctx.beginPath();
            ctx.moveTo(x, chartArea.bottom);
            ctx.lineTo(x, chartArea.bottom + 8);
            ctx.stroke();
        });

        // Draw the X axis dashed line
        elements.forEach((point, eltIndex) => {
            xAxis.ticks.forEach((value, tickIndex) => {
                if (point.active && eltIndex === tickIndex) {
                    const x = xAxis.getPixelForTick(tickIndex);
                    ctx.beginPath();
                    ctx.moveTo(x, chartArea.top);
                    ctx.lineTo(x, chartArea.bottom);
                    ctx.strokeStyle = GRAPH_GRID_COLOR;
                    ctx.stroke();
                }
            });
        });
    },
};

/**
 * @param {Object} chartArea
 * @returns {string}
 */
function getMaxWidth(chartArea) {
    const { left, right } = chartArea;
    return Math.floor((right - left) / 1.618) + "px";
}

/**
 * Used to avoid too long legend items.
 * @param {string} label
 * @returns {string} shortened version of the input label
 */
function shortenLabel(label) {
    // string returned could be wrong if a groupby value contain a " / "!
    const groups = label.toString().split(SEP);
    let shortLabel = groups.slice(0, 3).join(SEP);
    if (shortLabel.length > 30) {
        shortLabel = `${shortLabel.slice(0, 30)}...`;
    } else if (groups.length > 3) {
        shortLabel = `${shortLabel}${SEP}...`;
    }
    return shortLabel;
}

const GraphRenderer = __exports.GraphRenderer = class GraphRenderer extends Component {
    static template = "web.GraphRenderer";
    static components = { Dropdown, DropdownItem, ReportViewMeasures };
    static props = ["class?", "model", "buttonTemplate"];

    setup() {
        this.model = this.props.model;

        this.rootRef = useRef("root");
        this.canvasRef = useRef("canvas");
        this.containerRef = useRef("container");
        this.actionService = useService("action");

        this.chart = null;
        this.tooltip = null;
        this.legendTooltip = null;

        onWillStart(async () => {
            await loadBundle("web.chartjs_lib");
        });

        useEffect(() => this.renderChart());
        onWillUnmount(this.onWillUnmount);
    }

    onWillUnmount() {
        if (this.chart) {
            this.chart.destroy();
        }
    }

    /**
     * This function aims to remove a suitable number of lines from the
     * tooltip in order to make it reasonably visible. A message indicating
     * the number of lines is added if necessary.
     * @param {HTMLElement} tooltip
     * @param {number} maxTooltipHeight this the max height in pixels of the tooltip
     */
    adjustTooltipHeight(tooltip, maxTooltipHeight) {
        const sizeOneLine = tooltip.querySelector("tbody tr").clientHeight;
        const tbodySize = tooltip.querySelector("tbody").clientHeight;
        const toKeep = Math.max(
            0,
            Math.floor((maxTooltipHeight - (tooltip.clientHeight - tbodySize)) / sizeOneLine) - 1
        );
        const lines = tooltip.querySelectorAll("tbody tr");
        const toRemove = lines.length - toKeep;
        if (toRemove > 0) {
            for (let index = toKeep; index < lines.length; ++index) {
                lines[index].remove();
            }
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            tr.classList.add("o_show_more", "text-center", "fw-bold");
            td.setAttribute("colspan", "2");
            td.innerText = _t("...");
            tr.appendChild(td);
            tooltip.querySelector("tbody").appendChild(tr);
        }
    }

    /**
     * Creates a custom HTML tooltip.
     * @param {Object} data
     * @param {Object} metaData
     * @param {Object} context see chartjs documentation
     */
    customTooltip(data, metaData, context) {
        const tooltipModel = context.tooltip;
        const { measure, measures, disableLinking, mode } = metaData;
        this.containerRef.el.style.cursor = "";
        this.removeTooltips();
        if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {
            return;
        }
        if (!disableLinking && mode !== "line") {
            this.containerRef.el.style.cursor = "pointer";
        }
        const chartAreaTop = this.chart.chartArea.top;
        const viewContentTop = this.containerRef.el.getBoundingClientRect().top;
        const innerHTML = renderToString("web.GraphRenderer.CustomTooltip", {
            maxWidth: getMaxWidth(this.chart.chartArea),
            measure: measures[measure].string,
            mode: this.model.metaData.mode,
            tooltipItems: this.getTooltipItems(data, metaData, tooltipModel),
        });
        const template = Object.assign(document.createElement("template"), { innerHTML });
        const tooltip = template.content.firstChild;
        this.containerRef.el.prepend(tooltip);

        let top;
        const tooltipHeight = tooltip.clientHeight;
        const minTopAllowed = Math.floor(chartAreaTop);
        const maxTopAllowed = Math.floor(window.innerHeight - (viewContentTop + tooltipHeight)) - 2;
        const y = Math.floor(tooltipModel.y);
        if (minTopAllowed <= maxTopAllowed) {
            // Here we know that the full tooltip can fit in the screen.
            // We put it in the position where Chart.js would put it
            // if two conditions are respected:
            //  1: the tooltip is not cut (because we know it is possible to not cut it)
            //  2: the tooltip does not hide the legend.
            // If it is not possible to use the Chart.js proposition (y)
            // we use the best approximated value.
            if (y <= maxTopAllowed) {
                if (y >= minTopAllowed) {
                    top = y;
                } else {
                    top = minTopAllowed;
                }
            } else {
                top = maxTopAllowed;
            }
        } else {
            // Here we know that we cannot satisfy condition 1 above,
            // so we position the tooltip at the minimal position and
            // cut it the minimum possible.
            top = minTopAllowed;
            const maxTooltipHeight = window.innerHeight - (viewContentTop + chartAreaTop) - 2;
            this.adjustTooltipHeight(tooltip, maxTooltipHeight);
        }
        this.fixTooltipLeftPosition(tooltip, tooltipModel.x);
        tooltip.style.top = Math.floor(top) + "px";

        this.tooltip = tooltip;
    }

    /**
     * Sets best left position of a tooltip approaching the proposal x.
     * @param {HTMLElement} tooltip
     * @param {number} x
     */
    fixTooltipLeftPosition(tooltip, x) {
        let left;
        const tooltipWidth = tooltip.clientWidth;
        const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);
        const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);
        x = Math.floor(x);
        if (x < minLeftAllowed) {
            left = minLeftAllowed;
        } else if (x > maxLeftAllowed) {
            left = maxLeftAllowed;
        } else {
            left = x;
        }
        tooltip.style.left = `${left}px`;
    }

    /**
     * Used to format correctly the values in tooltip and y.
     * @param {number} value
     * @param {boolean} [allIntegers=true]
     * @returns {string}
     */
    formatValue(value, allIntegers = true, formatType = "") {
        const largeNumber = Math.abs(value) >= 1000;
        if (formatType) {
            return formatters.get(formatType)(value);
        }
        if (allIntegers && !largeNumber) {
            return String(value);
        }
        if (largeNumber) {
            return formatFloat(value, { humanReadable: true, decimals: 2, minDigits: 1 });
        }
        return formatFloat(value);
    }

    /**
     * Returns the bar chart data
     * @returns {Object}
     */
    getBarChartData() {
        // style data
        const { domains, stacked } = this.model.metaData;
        const { data, lineOverlayDataset } = this.model;
        for (let index = 0; index < data.datasets.length; ++index) {
            const dataset = data.datasets[index];
            const itemColor = getColor(index, colorScheme, data.datasets.length);
            // used when stacked
            if (stacked) {
                dataset.stack = domains[dataset.originIndex].description || "";
            }
            // set dataset color
            dataset.backgroundColor = itemColor;
            dataset.borderRadius = 4;
        }
        if (lineOverlayDataset) {
            // Mutate the lineOverlayDataset to include the config on how it will be displayed.
            Object.assign(lineOverlayDataset, {
                type: "line",
                order: -1,
                tension: 0,
                fill: false,
                pointHitRadius: 20,
                pointRadius: 5,
                pointHoverRadius: 10,
                backgroundColor: getCustomColor(colorScheme, "#343a40", "#e9ecef"),
                borderColor: getCustomColor(colorScheme, "rgba(0,0,0,.3)", "rgba(255,255,255,.5)"),
                borderWidth: 2,
                lineWidth: 3,
            });
            // We're not mutating the original datasets (`this.model.data.datasets`)
            // because some part of the code depends on it.
            return {
                ...data,
                datasets: [...data.datasets, lineOverlayDataset],
            };
        }

        return data;
    }

    /**
     * Returns the chart config.
     * @returns {Object}
     */
    getChartConfig() {
        const { mode } = this.model.metaData;
        let data;
        switch (mode) {
            case "bar":
                data = this.getBarChartData();
                break;
            case "line":
                data = this.getLineChartData();
                break;
            case "pie":
                data = this.getPieChartData();
        }
        const options = this.prepareOptions();
        const config = { data, options, type: mode };
        if (mode === "line") {
            config.plugins = [gridOnTop];
        }
        return config;
    }

    /**
     * Returns the animation options.
     * 1. This adds progressive animation for Bar & Line charts.
     * 2. Reduce animation duration for Pie chart.
     * @returns {Object}
     */
    getAnimationOptions() {
        let delayed;
        const { mode } = this.model.metaData;
        const labelsCount = this.model.data.labels.length;
        const gap = 350;
        const animationOptions = {};
        if (mode === "pie") {
            animationOptions.offset = { duration: 200 };
        } else {
            animationOptions.duration = 600;
            animationOptions.onComplete = () => {
                delayed = true;
            };
            animationOptions.delay = (context) => {
                let delay = 0;
                if ((mode === "bar" || mode === "line") && !delayed) {
                    delay = context.dataIndex * (gap / labelsCount);
                }
                return delay;
            };
        }
        return animationOptions;
    }

    /**
     * Returns an object used to style chart elements independently from
     * the datasets.
     * @returns {Object}
     */
    getElementOptions() {
        const { mode, stacked } = this.model.metaData;
        const elementOptions = {};
        if (mode === "bar") {
            elementOptions.bar = { borderWidth: 1 };
        } else if (mode === "line") {
            elementOptions.line = { fill: stacked, tension: 0 };
        }
        return elementOptions;
    }

    /**
     * @returns {Object}
     */
    getLegendOptions() {
        const { mode } = this.model.metaData;
        const legendOptions = {
            onHover: this.onLegendHover.bind(this),
            onLeave: this.onLegendLeave.bind(this),
        };
        if (mode === "line") {
            legendOptions.onClick = this.onLegendClick.bind(this);
        }
        if (mode === "pie") {
            legendOptions.labels = {
                generateLabels: (chart) => {
                    return chart.data.labels.map((label, index) => {
                        const hidden = !chart.getDataVisibility(index);
                        const fullText = label;
                        const text = shortenLabel(fullText);
                        const fillStyle =
                            label === NO_DATA
                                ? NO_DATA_COLOR
                                : getColor(index, colorScheme, chart.data.labels.length);
                        return {
                            text,
                            fullText,
                            fillStyle,
                            hidden,
                            index,
                            fontColor: GRAPH_LEGEND_COLOR,
                            lineWidth: 0,
                        };
                    });
                },
            };
        } else {
            legendOptions.position = "top";
            legendOptions.align = "end";
            const referenceColor = mode === "bar" ? "backgroundColor" : "borderColor";
            legendOptions.labels = {
                generateLabels: (chart) => {
                    const { data } = chart;
                    const labels = data.datasets.map((dataset, index) => {
                        return {
                            text: shortenLabel(dataset.label),
                            fullText: dataset.label,
                            fillStyle: dataset[referenceColor],
                            hidden: !chart.isDatasetVisible(index),
                            lineCap: dataset.borderCapStyle,
                            lineDash: dataset.borderDash,
                            lineDashOffset: dataset.borderDashOffset,
                            lineJoin: dataset.borderJoinStyle,
                            lineWidth: dataset.borderWidth,
                            strokeStyle: dataset[referenceColor],
                            pointStyle: dataset.pointStyle,
                            datasetIndex: index,
                            fontColor: GRAPH_LEGEND_COLOR,
                        };
                    });
                    return labels;
                },
            };
        }
        return legendOptions;
    }

    /**
     * Returns line chart data.
     * @returns {Object}
     */
    getLineChartData() {
        const { cumulated } = this.model.metaData;
        const data = this.model.data;
        for (let index = 0; index < data.datasets.length; ++index) {
            const dataset = data.datasets[index];
            const itemColor = getColor(index, colorScheme, data.datasets.length);
            dataset.backgroundColor = getCustomColor(
                colorScheme,
                lightenColor(itemColor, 0.5),
                darkenColor(itemColor, 0.5)
            );
            dataset.cubicInterpolationMode = "monotone";
            dataset.borderColor = itemColor;
            dataset.borderWidth = 2;
            dataset.hoverBackgroundColor = dataset.borderColor;
            dataset.pointRadius = 3;
            dataset.pointHoverRadius = 6;
            if (cumulated) {
                let accumulator = dataset.cumulatedStart;
                dataset.data = dataset.data.map((value) => {
                    accumulator += value;
                    return accumulator;
                });
            }
            if (data.labels.length === 1) {
                // shift of the real value to right. This is done to
                // center the points in the chart. See data.labels below in
                // Chart parameters
                dataset.data.unshift(undefined);
                dataset.trueLabels.unshift(undefined);
                dataset.domains.unshift(undefined);
            }
            dataset.pointBackgroundColor = dataset.borderColor;
        }
        // center the points in the chart (without that code they are put
        // on the left and the graph seems empty)
        data.labels = data.labels.length > 1 ? data.labels : ["", ...data.labels, ""];
        return data;
    }

    /**
     * Returns pie chart data.
     * @returns {Object}
     */
    getPieChartData() {
        const { domains } = this.model.metaData;
        const data = this.model.data;
        // style/complete data
        // give same color to same groups from different origins
        const colors = data.labels.map((_, index) =>
            getColor(index, colorScheme, data.labels.length)
        );
        const borderColor = getBorderWhite(colorScheme);
        for (const dataset of data.datasets) {
            dataset.backgroundColor = colors;
            dataset.hoverBackgroundColor = colors;
            dataset.borderColor = borderColor;
            dataset.hoverOffset = 60;
        }
        // make sure there is a zone associated with every origin
        const representedOriginIndexes = new Set(
            data.datasets.map((dataset) => dataset.originIndex)
        );
        let addNoDataToLegend = false;
        const fakeData = new Array(data.labels.length + 1);
        fakeData[data.labels.length] = 1;
        const fakeTrueLabels = new Array(data.labels.length + 1);
        fakeTrueLabels[data.labels.length] = NO_DATA;
        for (let index = 0; index < domains.length; ++index) {
            if (!representedOriginIndexes.has(index)) {
                data.datasets.push({
                    label: domains[index].description,
                    data: fakeData,
                    trueLabels: fakeTrueLabels,
                    backgroundColor: [...colors, NO_DATA_COLOR],
                    borderColor,
                });
                addNoDataToLegend = true;
            }
        }
        if (addNoDataToLegend) {
            data.labels.push(NO_DATA);
        }

        return data;
    }

    /**
     * Returns the options used to generate the chart axes.
     * @returns {Object}
     */
    getScaleOptions() {
        const { labels } = this.model.data;
        const { fieldAttrs, measure, measures, mode, stacked } = this.model.metaData;
        if (mode === "pie") {
            return {};
        }
        const xAxe = {
            type: "category",
            ticks: {
                callback: (val, index) => {
                    const value = labels[index];
                    return shortenLabel(value);
                },
                color: GRAPH_LABEL_COLOR,
            },
            grid: {
                color: "transparent",
            },
            border: {
                display: false,
            },
        };
        const yAxe = {
            beginAtZero: true,
            type: "linear",
            title: {
                text: measures[measure].string,
                color:
                    cookie.get("color_scheme") === "dark"
                        ? getColor(15, cookie.get("color_scheme"))
                        : null,
            },
            ticks: {
                callback: (value) => this.formatValue(value, false, fieldAttrs[measure]?.widget),
                color: GRAPH_LABEL_COLOR,
            },
            stacked: mode === "line" && stacked ? stacked : undefined,
            grid: {
                display: mode === "line" ? false : true,
                color: GRAPH_GRID_COLOR,
            },
            border: {
                display: false,
            },
            suggestedMax: 0,
            suggestedMin: 0,
        };
        return { x: xAxe, y: yAxe };
    }

    /**
     * This function extracts the information from the data points in
     * tooltipModel.dataPoints (corresponding to datapoints over a given
     * label determined by the mouse position) that will be displayed in a
     * custom tooltip.
     * @param {Object} data
     * @param {Object} metaData
     * @param {Object} tooltipModel see chartjs documentation
     * @returns {Object[]}
     */
    getTooltipItems(data, metaData, tooltipModel) {
        const { allIntegers, domains, mode, groupBy, measure } = metaData;
        const sortedDataPoints = sortBy(tooltipModel.dataPoints, "raw", "desc");
        const items = [];
        for (const item of sortedDataPoints) {
            const index = item.dataIndex;
            // If `datasetIndex` is not found in the `datasets`, then it refers to the `lineOverlayDataset`.
            const dataset = data.datasets[item.datasetIndex] || this.model.lineOverlayDataset;
            let label = dataset.trueLabels[index];
            let value = dataset.data[index];
            const measureWidget = metaData.fieldAttrs[measure]?.widget;
            value = this.formatValue(value, allIntegers, measureWidget);
            let boxColor;
            let percentage;
            if (mode === "pie") {
                if (label === NO_DATA) {
                    value = this.formatValue(0, allIntegers, measureWidget);
                }
                if (domains.length > 1) {
                    label = `${dataset.label} / ${label}`;
                }
                boxColor = dataset.backgroundColor[index];
                const totalData = dataset.data.reduce((a, b) => a + b, 0);
                percentage = totalData && ((dataset.data[index] * 100) / totalData).toFixed(2);
            } else {
                if (groupBy.length > 1 || domains.length > 1) {
                    label = `${label} / ${dataset.label}`;
                }
                boxColor = mode === "bar" ? dataset.backgroundColor : dataset.borderColor;
            }
            items.push({ label, value, boxColor, percentage });
        }
        return items;
    }

    /**
     * Returns the options used to generate chart tooltips.
     * @returns {Object}
     */
    getTooltipOptions() {
        const { data, metaData } = this.model;
        const { mode } = metaData;
        const tooltipOptions = {
            enabled: false,
            external: this.customTooltip.bind(this, data, metaData),
        };
        if (mode === "line") {
            tooltipOptions.mode = "index";
            tooltipOptions.intersect = false;
            tooltipOptions.position = "average";
        }
        if (mode === "bar") {
            tooltipOptions.xAlign = "center";
            tooltipOptions.yAlign = "bottom";
        }
        if (mode === "pie") {
            tooltipOptions.xAlign = "center";
            tooltipOptions.yAlign = "center";
        }
        return tooltipOptions;
    }

    /**
     * If a group has been clicked on, display a view of its records.
     * @param {MouseEvent} ev
     */
    onGraphClicked(ev) {
        const [activeElement] = this.chart.getElementsAtEventForMode(
            ev,
            "nearest",
            { intersect: true },
            false
        );
        if (!activeElement) {
            return;
        }
        const { datasetIndex, index } = activeElement;
        const { domains } = this.chart.data.datasets[datasetIndex];
        if (domains) {
            this.onGraphClickedFinal(domains[index]);
        }
    }

    /**
     * Overrides the default legend 'onClick' behaviour. This is done to
     * remove all existing tooltips right before updating the chart.
     * @param {Event} ev
     * @param {Object} legendItem
     */
    onLegendClick(ev, legendItem) {
        this.removeTooltips();
        // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138
        const index = legendItem.datasetIndex;
        const meta = this.chart.getDatasetMeta(index);
        meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;
        this.chart.update();
    }

    /**
     * If the text of a legend item has been shortened and the user mouse
     * hovers that item (actually the event type is mousemove), a tooltip
     * with the item full text is displayed.
     * @param {Event} ev
     * @param {Object} legendItem
     */
    onLegendHover(ev, legendItem) {
        ev = ev.native;
        this.canvasRef.el.style.cursor = "pointer";
        /**
         * The string legendItem.text is an initial segment of legendItem.fullText.
         * If the two coincide, no need to generate a tooltip. If a tooltip
         * for the legend already exists, it is already good and does not
         * need to be recreated.
         */
        const { fullText, text } = legendItem;
        if (this.legendTooltip || text === fullText) {
            return;
        }
        const viewContentTop = this.canvasRef.el.getBoundingClientRect().top;
        const legendTooltip = Object.assign(document.createElement("div"), {
            className: "o_tooltip_legend popover p-3 pe-none position-absolute",
            innerText: fullText,
        });
        legendTooltip.style.top = `${ev.clientY - viewContentTop}px`;
        legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);
        this.containerRef.el.appendChild(legendTooltip);
        this.fixTooltipLeftPosition(legendTooltip, ev.clientX);
        this.legendTooltip = legendTooltip;
    }

    /**
     * If there's a legend tooltip and the user mouse out of the
     * corresponding legend item, the tooltip is removed.
     */
    onLegendLeave() {
        this.canvasRef.el.style.cursor = "";
        this.removeLegendTooltip();
    }

    /**
     * Prepares options for the chart according to the current mode
     * (= chart type). This function returns the parameter options used to
     * instantiate the chart.
     */
    prepareOptions() {
        const { disableLinking, mode } = this.model.metaData;
        const options = {
            maintainAspectRatio: false,
            scales: this.getScaleOptions(),
            plugins: {
                legend: this.getLegendOptions(),
                tooltip: this.getTooltipOptions(),
            },
            elements: this.getElementOptions(),
            onResize: () => {
                this.resizeChart(options);
            },
            animation: this.getAnimationOptions(),
        };
        if (!disableLinking && mode !== "line") {
            options.onClick = this.onGraphClicked.bind(this);
        }
        if (mode === "line") {
            options.interaction = {
                mode: "index",
                intersect: false,
            };
        }
        if (mode === "pie") {
            options.radius = "90%";
        }
        return options;
    }

    /**
     * Adapt Pie chart layout on mobile
     * @param {Object} context
     */
    resizeChart(context) {
        const { mode } = this.model.metaData;
        if (mode === "pie") {
            if (this.env.isSmall) {
                context.plugins.legend.position = "bottom";
                context.plugins.legend.align = "center";
            } else {
                context.plugins.legend.position = "right";
                context.plugins.legend.align = "start";
            }
        }
    }

    /**
     * Removes the legend tooltip (if any).
     */
    removeLegendTooltip() {
        if (this.legendTooltip) {
            this.legendTooltip.remove();
            this.legendTooltip = null;
        }
    }

    /**
     * Removes all existing tooltips (if any).
     */
    removeTooltips() {
        if (this.tooltip) {
            this.tooltip.remove();
            this.tooltip = null;
        }
        this.removeLegendTooltip();
    }

    /**
     * Instantiates a Chart (Chart.js lib) to render the graph according to
     * the current config.
     */
    renderChart() {
        if (this.chart) {
            this.chart.destroy();
        }
        if (this.canvasRef.el) {
            const config = this.getChartConfig();
            this.chart = new Chart(this.canvasRef.el, config);
        }
    }

    /**
     * Execute the action to open the view on the current model.
     *
     * @param {Array} domain
     * @param {Array} views
     * @param {Object} context
     */
    openView(domain, views, context) {
        this.actionService.doAction(
            {
                context,
                domain,
                name: this.model.metaData.title,
                res_model: this.model.metaData.resModel,
                target: "current",
                type: "ir.actions.act_window",
                views,
            },
            {
                viewType: "list",
            }
        );
    }
    /**
     * @param {string} domain the domain of the clicked area
     */
    onGraphClickedFinal(domain) {
        const { context } = this.model.metaData;

        Object.keys(context).forEach((x) => {
            if (x === "group_by" || x.startsWith("search_default_")) {
                delete context[x];
            }
        });

        const views = {};
        for (const [viewId, viewType] of this.env.config.views || []) {
            views[viewType] = viewId;
        }
        function getView(viewType) {
            return [views[viewType] || false, viewType];
        }
        const actionViews = [getView("list"), getView("form")];
        this.openView(domain, actionViews, context);
    }

    /**
     * @param {Object} param0
     * @param {string} param0.measure
     */
    onMeasureSelected({ measure }) {
        this.model.updateMetaData({ measure });
    }

    /**
     * @param {"bar"|"line"|"pie"} mode
     */
    onModeSelected(mode) {
        if (this.model.metaData.mode != mode) {
            this.model.updateMetaData({ mode });
        }
    }

    /**
     * @param {"ASC"|"DESC"} order
     */
    toggleOrder(order) {
        const { order: currentOrder } = this.model.metaData;
        const nextOrder = currentOrder === order ? null : order;
        this.model.updateMetaData({ order: nextOrder });
    }

    toggleStacked() {
        const { stacked } = this.model.metaData;
        this.model.updateMetaData({ stacked: !stacked });
    }

    toggleCumulated() {
        const { cumulated } = this.model.metaData;
        this.model.updateMetaData({ cumulated: !cumulated });
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web/static/src/views/graph/graph_search_model.js  *
*  Lines: 25                                                    *
****************************************************************/
odoo.define('@web/views/graph/graph_search_model', ['@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
const { SearchModel } = require("@web/search/search_model");

const GraphSearchModel = __exports.GraphSearchModel = class GraphSearchModel extends SearchModel {
    _getIrFilterDescription() {
        this.preparingIrFilterDescription = true;
        const result = super._getIrFilterDescription(...arguments);
        this.preparingIrFilterDescription = false;
        return result;
    }

    _getSearchItemGroupBys(activeItem) {
        const { searchItemId } = activeItem;
        const { context, type } = this.searchItems[searchItemId];
        if (!this.preparingIrFilterDescription && type === "favorite" && context.graph_groupbys) {
            return context.graph_groupbys;
        }
        return super._getSearchItemGroupBys(...arguments);
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web/static/src/views/graph/graph_view.js  *
*  Lines: 62                                            *
********************************************************/
odoo.define('@web/views/graph/graph_view', ['@web/core/l10n/translation', '@web/core/registry', '@web/views/graph/graph_arch_parser', '@web/views/graph/graph_model', '@web/views/graph/graph_controller', '@web/views/graph/graph_renderer', '@web/views/graph/graph_search_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { GraphArchParser } = require("@web/views/graph/graph_arch_parser");
const { GraphModel } = require("@web/views/graph/graph_model");
const { GraphController } = require("@web/views/graph/graph_controller");
const { GraphRenderer } = require("@web/views/graph/graph_renderer");
const { GraphSearchModel } = require("@web/views/graph/graph_search_model");

const viewRegistry = registry.category("views");

const graphView = __exports.graphView = {
    type: "graph",
    Controller: GraphController,
    Renderer: GraphRenderer,
    Model: GraphModel,
    ArchParser: GraphArchParser,
    SearchModel: GraphSearchModel,
    searchMenuTypes: ["filter", "groupBy", "comparison", "favorite"],
    buttonTemplate: "web.GraphView.Buttons",

    props: (genericProps, view) => {
        let modelParams;
        if (genericProps.state) {
            modelParams = genericProps.state.metaData;
        } else {
            const { arch, fields, resModel } = genericProps;
            const parser = new view.ArchParser();
            const archInfo = parser.parse(arch, fields);
            modelParams = {
                disableLinking: Boolean(archInfo.disableLinking),
                fieldAttrs: archInfo.fieldAttrs,
                fields: fields,
                groupBy: archInfo.groupBy,
                measure: archInfo.measure || "__count",
                viewMeasures: archInfo.measures,
                mode: archInfo.mode || "bar",
                order: archInfo.order || null,
                resModel: resModel,
                stacked: "stacked" in archInfo ? archInfo.stacked : true,
                cumulated: archInfo.cumulated || false,
                cumulatedStart: archInfo.cumulatedStart || false,
                title: archInfo.title || _t("Untitled"),
            };
        }

        return {
            ...genericProps,
            modelParams,
            Model: view.Model,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

viewRegistry.add("graph", graphView);

return __exports;
});
;

/***************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_arch_parser.js  *
*  Lines: 79                                                   *
***************************************************************/
odoo.define('@web/views/pivot/pivot_arch_parser', ['@web/core/utils/strings', '@web/core/utils/xml'], function (require) {
'use strict';
let __exports = {};
const { exprToBoolean } = require("@web/core/utils/strings");
const { visitXML } = require("@web/core/utils/xml");

const PivotArchParser = __exports.PivotArchParser = class PivotArchParser {
    parse(arch) {
        const archInfo = {
            activeMeasures: [], // store the defined active measures
            colGroupBys: [], // store the defined group_by used on cols
            defaultOrder: null,
            fieldAttrs: {},
            rowGroupBys: [], // store the defined group_by used on rows
            widgets: {}, // wigdets defined in the arch
        };

        visitXML(arch, (node) => {
            switch (node.tagName) {
                case "pivot": {
                    if (node.hasAttribute("disable_linking")) {
                        archInfo.disableLinking = exprToBoolean(
                            node.getAttribute("disable_linking")
                        );
                    }
                    if (node.hasAttribute("default_order")) {
                        archInfo.defaultOrder = node.getAttribute("default_order");
                    }
                    if (node.hasAttribute("string")) {
                        archInfo.title = node.getAttribute("string");
                    }
                    if (node.hasAttribute("display_quantity")) {
                        archInfo.displayQuantity = exprToBoolean(
                            node.getAttribute("display_quantity")
                        );
                    }
                    break;
                }
                case "field": {
                    let fieldName = node.getAttribute("name"); // exists (rng validation)

                    archInfo.fieldAttrs[fieldName] = {};
                    if (node.hasAttribute("string")) {
                        archInfo.fieldAttrs[fieldName].string = node.getAttribute("string");
                    }
                    if (
                        node.getAttribute("invisible") === "True" ||
                        node.getAttribute("invisible") === "1"
                    ) {
                        archInfo.fieldAttrs[fieldName].isInvisible = true;
                        break;
                    }

                    if (node.hasAttribute("interval")) {
                        fieldName += ":" + node.getAttribute("interval");
                    }
                    if (node.hasAttribute("widget")) {
                        archInfo.widgets[fieldName] = node.getAttribute("widget");
                    }
                    if (node.getAttribute("type") === "measure" || node.hasAttribute("operator")) {
                        archInfo.activeMeasures.push(fieldName);
                    }
                    if (node.getAttribute("type") === "col") {
                        archInfo.colGroupBys.push(fieldName);
                    }
                    if (node.getAttribute("type") === "row") {
                        archInfo.rowGroupBys.push(fieldName);
                    }
                    break;
                }
            }
        });

        return archInfo;
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_controller.js  *
*  Lines: 51                                                  *
**************************************************************/
odoo.define('@web/views/pivot/pivot_controller', ['@web/search/layout', '@web/model/model', '@web/views/standard_view_props', '@web/search/action_hook', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/search/cog_menu/cog_menu', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { Layout } = require("@web/search/layout");
const { useModelWithSampleData } = require("@web/model/model");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useSetupAction } = require("@web/search/action_hook");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");

const { Component, useRef } = require("@odoo/owl");

const PivotController = __exports.PivotController = class PivotController extends Component {
    static template = "web.PivotView";
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        modelParams: Object,
        Renderer: Function,
        buttonTemplate: String,
    };

    setup() {
        this.model = useModelWithSampleData(this.props.Model, this.props.modelParams);

        useSetupAction({
            rootRef: useRef("root"),
            getLocalState: () => {
                const { data, metaData } = this.model;
                return { data, metaData };
            },
            getContext: () => this.getContext(),
        });
        this.searchBarToggler = useSearchBarToggler();
    }
    /**
     * @returns {Object}
     */
    getContext() {
        return {
            pivot_measures: this.model.metaData.activeMeasures,
            pivot_column_groupby: this.model.metaData.fullColGroupBys,
            pivot_row_groupby: this.model.metaData.fullRowGroupBys,
        };
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_header.js  *
*  Lines: 152                                             *
**********************************************************/
odoo.define('@web/views/pivot/pivot_header', ['@odoo/owl', '@web/core/dropdown/checkbox_item', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_hooks', '@web/core/l10n/localization', '@web/core/utils/arrays', '@web/core/utils/hooks', '@web/search/custom_group_by_item/custom_group_by_item', '@web/search/properties_group_by_item/properties_group_by_item', '@web/search/utils/dates', '@web/search/utils/misc'], function (require) {
'use strict';
let __exports = {};
const { Component } = require("@odoo/owl");
const { CheckboxItem } = require("@web/core/dropdown/checkbox_item");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { useDropdownState } = require("@web/core/dropdown/dropdown_hooks");
const { localization } = require("@web/core/l10n/localization");
const { sortBy } = require("@web/core/utils/arrays");
const { useBus } = require("@web/core/utils/hooks");
const { CustomGroupByItem } = require("@web/search/custom_group_by_item/custom_group_by_item");
const { PropertiesGroupByItem } = require("@web/search/properties_group_by_item/properties_group_by_item");
const { getIntervalOptions } = require("@web/search/utils/dates");
const { FACET_ICONS, GROUPABLE_TYPES } = require("@web/search/utils/misc");

const PivotHeader = __exports.PivotHeader = class PivotHeader extends Component {
    static template = "web.PivotHeader";
    static components = {
        CustomGroupByItem,
        Dropdown,
        CheckboxItem,
        PropertiesGroupByItem,
    };
    static defaultProps = {
        isInHead: false,
        isXAxis: false,
        showCaretDown: false,
    };
    static props = {
        cell: Object,
        isInHead: { type: Boolean, optional: true },
        isXAxis: { type: Boolean, optional: true },
        customGroupBys: Object,
        onAddCustomGroupBy: Function,
        onItemSelected: Function,
        onClick: Function,
        slots: { optional: true },
    };

    setup() {
        this.icon = FACET_ICONS.groupBy;
        const fields = [];
        for (const [fieldName, field] of Object.entries(this.env.searchModel.searchViewFields)) {
            if (this.validateField(fieldName, field)) {
                fields.push(Object.assign({ name: fieldName }, field));
            }
        }
        this.fields = sortBy(fields, "string");
        this.l10n = localization;
        this.dropdownState = useDropdownState();

        useBus(this.env.searchModel, "update", this.render);
    }

    /**
     * @returns {boolean}
     */
    get hideCustomGroupBy() {
        return this.env.searchModel.hideCustomGroupBy || false;
    }

    /**
     * @returns {Object[]}
     */
    get items() {
        let items = this.env.searchModel.getSearchItems(
            (searchItem) =>
                ["groupBy", "dateGroupBy"].includes(searchItem.type) && !searchItem.custom
        );
        if (items.length === 0) {
            items = this.fields;
        }

        // Add custom groupbys
        let groupNumber = 1 + Math.max(0, ...items.map(({ groupNumber: n }) => n));
        for (const [fieldName, customGroupBy] of this.props.customGroupBys.entries()) {
            items.push({ ...customGroupBy, name: fieldName, groupNumber: groupNumber++ });
        }

        return items.map((item) => ({
            ...item,
            id: item.id || item.name,
            fieldName: item.fieldName || item.name,
            description: item.description || item.string,
            isActive: false,
            options:
                item.options ||
                (["date", "datetime"].includes(item.type) ? getIntervalOptions() : undefined),
        }));
    }

    get cell() {
        return this.props.cell;
    }

    /**
     * Retrieve the padding of a left header.
     * @returns {Number} Padding
     */
    get padding() {
        return 5 + this.cell.indent * 30;
    }

    /**
     * @param {string} fieldName
     * @param {Object} field
     * @returns {boolean}
     */
    validateField(fieldName, field) {
        const { groupable, type } = field;
        return groupable && fieldName !== "id" && GROUPABLE_TYPES.includes(type);
    }

    /**
     * @override
     * @param {Object} param0
     * @param {number} param0.itemId
     * @param {number} [param0.optionId]
     */
    onGroupBySelected({ itemId, optionId }) {
        // Here, we purposely do not call super.onGroupBySelected as we don't want
        // to change the group-by on the model, only inside the pivot
        const item = this.items.find(({ id }) => id === itemId);
        this.props.onItemSelected({
            itemId,
            optionId,
            fieldName: item.fieldName,
            interval: optionId,
            groupId: this.cell.groupId,
        });
    }

    /**
     * @param {string} fieldName
     */
    onAddCustomGroup(fieldName) {
        this.props.onAddCustomGroupBy(fieldName);
    }

    /**
     * @param {Event} event
     */
    onClick(event) {
        if (this.cell.isLeaf && !this.cell.isFolded) {
            this.dropdownState.open();
        }
        this.props.onClick();
    }
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_model.js  *
*  Lines: 1724                                           *
*********************************************************/
odoo.define('@web/views/pivot/pivot_model', ['@web/core/l10n/translation', '@web/core/domain', '@web/core/utils/arrays', '@web/core/utils/concurrency', '@web/search/utils/dates', '@web/model/model', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { Domain } = require("@web/core/domain");
const { cartesian, sections, sortBy, symmetricalDifference } = require("@web/core/utils/arrays");
const { KeepLast, Race } = require("@web/core/utils/concurrency");
const { DEFAULT_INTERVAL } = require("@web/search/utils/dates");
const { addPropertyFieldDefs, Model } = require("@web/model/model");
const { computeReportMeasures, processMeasure } = require("@web/views/utils");

/**
 * @param {number} value
 * @param {number} comparisonValue
 * @returns {number}
 */
function computeVariation(value, comparisonValue) {
    if (isNaN(value) || isNaN(comparisonValue)) {
        return NaN;
    }
    if (comparisonValue === 0) {
        if (value === 0) {
            return 0;
        } else if (value > 0) {
            return 1;
        } else {
            return -1;
        }
    }
    return (value - comparisonValue) / Math.abs(comparisonValue);
}

/**
 * Pivot Model
 *
 * The pivot model keeps an in-memory representation of the pivot table that is
 * displayed on the screen.  The exact layout of this representation is not so
 * simple, because a pivot table is at its core a 2-dimensional object, but
 * with a 'list' component: some rows/cols can be expanded so we zoom into the
 * structure.
 *
 * However, we need to be able to manipulate the data in a somewhat efficient
 * way, and to transform it into a list of lines to be displayed by the renderer.
 *
 * Basicaly the pivot table presents aggregated values for various groups of records
 * in one domain. If a comparison is asked for, two domains are considered.
 *
 * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):
 * ___________________________________________________________________________________________________________________________________________
 * |                    |   Total                                                                                                             |
 * |                    |_____________________________________________________________________________________________________________________|
 * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   Sales total                         |  Sales total                         |  Sales total                         |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |
 * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |
 * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |
 * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |
 * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 *
 *
 * META DATA:
 *
 * In the above pivot table, the records have been grouped using the fields
 *
 *      continent_id, city_id
 *
 * for rows and
 *
 *      sale_team_id
 *
 * for columns.
 *
 * The measure is the field 'sales_total'.
 *
 * Two domains are considered: 'May 2020' and 'June 2020'.
 *
 * In the model,
 *
 *      - rowGroupBys is the list [continent_id, city_id]
 *      - colGroupBys is the list [sale_team_id]
 *      - measures is the list [sales_total]
 *      - domains is the list [d1, d2] with d1 and d2 domain expressions
 *          for say sale_date in May 2020 and June 2020, for instance
 *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]
 *      - origins is the list ['May 2020', 'June 2020']
 *
 * DATA:
 *
 * Recall that a group is constituted by records (in a given domain)
 * that have the same (raw) values for a list of fields.
 * Thus the group itself is identified by this list and the domain.
 * In comparison mode, the same group (forgetting the domain part or 'originIndex')
 * can be eventually found in the two domains.
 * This defines the way in which the groups are identified or not.
 *
 * In the above table, (forgetting the domain) the following groups are found:
 *
 *      the 'row groups'
 *      - Total
 *      - Europe
 *      - America
 *      - Europe, Brussels
 *      - Europe, Paris
 *      - America, Washington
 *
 *      the 'col groups'
 *
 *      - Total
 *      - Sale Team 1
 *      - Sale Team 2
 *
 *      and all non trivial combinations of row groups and col groups
 *
 *      - Europe, Sale Team 1
 *      - Europe, Brussels, Sale Team 2
 *      - America, Washington, Sale Team 1
 *      - ...
 *
 * The list of fields is created from the concatenation of two lists of fields, the first in
 *
 * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys
 * (called rowGroupBys) used to create row groups
 *
 * In the example: [], [continent_id], [continent_id, city_id].
 *
 * and the second in
 * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys
 * (called colGroupBys) used to create col groups.
 *
 * In the example: [], [sale_team_id].
 *
 * Thus there are (n+1)*(m+1) lists of fields possible.
 *
 * In the example: 6 lists possible, namely [],
 *                                          [continent_id], [sale_team_id],
 *                                          [continent_id, sale_team_id], [continent_id, city_id],
 *                                          [continent_id, city_id, sale_team_id]
 *
 * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]
 *
 * For each list of fields possible and each domain considered, one read_group is done
 * and gives results of the form (an exception for list [])
 *
 * g = {
 *  f1: v1, ..., fi: vi,
 *  g1: w1, ..., gj: wj,
 *  m1: x1, ..., mk: xk,
 *  __count: c,
 *  __domain: d
 * }
 *
 * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and
 * m1,...,mk are the fields selected as measures.
 *
 * For example, g = {
 *      continent_id: [1, 'Europe']
 *      sale_team_id: [1, 'Sale Team 1']
 *      sales_count: 25,
 *      __count: 4
 *      __domain: [
 *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],
 *                  ['continent_id', '=', 1],
 *                  ['sale_team_id', '=', 1]
 *                ]
 * }
 *
 * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain
 * or the corresponding 'originIndex'.
 *
 * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]
 * (not forgetting the list [v1,...vi] comes from left).
 * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].
 *
 * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]
 * and [[], [w1,...,wj]].
 *
 * Here is a description of the data structure manipulated by the pivot model.
 *
 * Five objects contain all the data from the read_groups
 *
 *      - rowGroupTree: contains information on row headers
 *             the nodes correspond to the groups of the form [[v1,...,vi], []]
 *             The root is [[], []].
 *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],
 *             this means that a direct child is obtained by grouping records using the single field fi+1
 *
 *             The structure at each level is of the form
 *
 *             {
 *                  root: {
 *                      values: [v1,...,vl],
 *                      labels: [la1,...,lal]
 *                  },
 *                  directSubTrees: {
 *                      v => {
 *                              root: {
 *                                  values: [v1,...,vl,v]
 *                                  labels: [label1,...,labell,label]
 *                              },
 *                              directSubTrees: {...}
 *                          },
 *                      v' => {...},
 *                      ...
 *                  }
 *             }
 *
 *             (directSubTrees is a Map instance)
 *
 *             In the example, the rowGroupTree is:
 *
 *             {
 *                  root: {
 *                      values: [],
 *                      labels: []
 *                  },
 *                  directSubTrees: {
 *                      1 => {
 *                              root: {
 *                                  values: [1],
 *                                  labels: ['Europe'],
 *                              },
 *                              directSubTrees: {
 *                                  1 => {
 *                                          root: {
 *                                              values: [1, 1],
 *                                              labels: ['Europe', 'Brussels'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                                  2 => {
 *                                          root: {
 *                                              values: [1, 2],
 *                                              labels: ['Europe', 'Paris'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                          },
 *                      2 => {
 *                              root: {
 *                                  values: [2],
 *                                  labels: ['America'],
 *                              },
 *                              directSubTrees: {
 *                                  3 => {
 *                                          root: {
 *                                              values: [2, 3],
 *                                              labels: ['America', 'Washington'],
 *                                          }
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                      },
 *                  },
 *             }
 *
 *      - colGroupTree: contains information on col headers
 *              The same as above with right instead of left
 *
 *      - measurements: contains information on measure values for all the groups
 *
 *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])
 *              and values are arrays of length equal to number of origins containing objects of the form
 *                  {m1: x1,...,mk: xk}
 *              The structure looks like
 *
 *              {
 *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]
 *                  ....
 *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],
 *                  ....
 *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],
 *              }
 *              Thus the structure contains all information for all groups and all origins on measure values.
 *
 *
 *              this.measurments["[[], []]"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the
 *              first domain (origin).
 *
 *              In the example:
 *                  {
 *                      "[[], []]": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)
 *                      ...
 *                      "[[1, 2], [2]]": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)
 *                      ...
 *                  }
 *
 *      - counts: contains information on the number of records in each groups
 *              The structure is similar to the above but the arrays contains numbers (counts)
 *      - groupDomains:
 *              The structure is similar to the above but the arrays contains domains
 *
 *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.
 *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the getTable function.
 */

/**
 * @typedef Meta
 * @property {string[]} activeMeasures
 * @property {string[]} colGroupBys
 * @property {boolean} disableLinking
 * @property {Object} fields
 * @property {Object} measures
 * @property {string} resModel
 * @property {string[]} rowGroupBys
 * @property {string} title
 * @property {boolean} useSampleModel
 * @property {Object} widgets
 * @property {Map} customGroupBys
 * @property {string[]} expandedRowGroupBys
 * @property {string[]} expandedColGroupBys
 * @property {Object} sortedColumn
 * @property {Array[]} domains
 * @property {string[]} origins
 */

/**
 * @typedef Data
 * @property {Object} colGroupTree
 * @property {Object} rowGroupTree
 * @property {Object} groupDomains
 * @property {Object} measurements
 * @property {Object} counts
 * @property {Object} numbering
 */

/**
 * @typedef {import("@web/search/search_model").SearchParams} SearchParams
 */

/**
 * @typedef Config
 * @property {MetaData} metaData
 * @property {Data} data
 */

const PivotModel = __exports.PivotModel = class PivotModel extends Model {
    /**
     * @override
     * @param {Object} params.metaData
     * @param {string[]} params.metaData.activeMeasures
     * @param {string[]} params.metaData.colGroupBys
     * @param {Object} params.metaData.fields
     * @param {Object[]} params.metaData.measures
     * @param {string} params.metaData.resModel
     * @param {string[]} params.metaData.rowGroupBys
     * @param {string|null} params.metaData.defaultOrder
     * @param {boolean} params.metaData.disableLinking
     * @param {boolean} params.metaData.useSampleModel
     * @param {Map} [params.metaData.customGroupBys={}]
     * @param {string[]} [params.metaData.expandedColGroupBys=[]]
     * @param {string[]} [params.metaData.expandedRowGroupBys=[]]
     * @param {Object|null} [params.metaData.sortedColumn=null]
     * @param {Object} [params.data] previously exported data
     */
    setup(params) {
        // concurrency management
        this.keepLast = new KeepLast();
        this.race = new Race();
        const _loadData = this._loadData.bind(this);
        this._loadData = (...args) => {
            return this.race.add(_loadData(...args));
        };

        let sortedColumn = params.metaData.sortedColumn || null;
        if (!sortedColumn && params.metaData.defaultOrder) {
            const defaultOrder = params.metaData.defaultOrder.split(" ");
            sortedColumn = {
                groupId: [[], []],
                measure: defaultOrder[0],
                order: defaultOrder[1] ? defaultOrder[1] : "asc",
            };
        }

        this.searchParams = {
            context: {},
            domain: [],
            domains: [],
            groupBy: [],
        };
        this.data = params.data || {
            colGroupTree: null,
            rowGroupTree: null,
            groupDomains: {},
            measurements: {},
            counts: {},
            numbering: {},
        };
        const metaData = Object.assign({}, params.metaData, {
            customGroupBys: params.metaData.customGroupBys || new Map(),
            expandedRowGroupBys: params.metaData.expandedRowGroupBys || [],
            expandedColGroupBys: params.metaData.expandedColGroupBys || [],
            sortedColumn,
        });
        this.metaData = this._buildMetaData(metaData);

        this.reload = false; // used to discriminate between the first load and subsequent reloads
        this.nextActiveMeasures = null; // allows to toggle several measures consecutively
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.
     *
     * @param {Object} params
     * @param {Array[]} params.groupId
     * @param {string} params.fieldName
     * @param {'row'|'col'} params.type
     * @param {boolean} [params.custom=false]
     * @param {string} [params.interval]
     */
    async addGroupBy(params) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const { groupId, fieldName, type, custom } = params;
        let { interval } = params;
        const metaData = this._buildMetaData();
        if (custom && !metaData.customGroupBys.has(fieldName)) {
            const field = metaData.fields[fieldName];
            if (!interval && ["date", "datetime"].includes(field.type)) {
                interval = DEFAULT_INTERVAL;
            }
            metaData.customGroupBys.set(fieldName, {
                ...field,
                id: fieldName,
            });
        }

        let groupBy = fieldName;
        if (interval) {
            groupBy = `${groupBy}:${interval}`;
        }
        if (type === "row") {
            metaData.expandedRowGroupBys.push(groupBy);
        } else {
            metaData.expandedColGroupBys.push(groupBy);
        }
        const config = { metaData, data: this.data };
        await this._expandGroup(groupId, type, config);
        this.metaData = metaData;
        this.notify();
    }
    /**
     * Close the group with id given by groupId. A type must be specified
     * in case groupId is [[], []] (the id of the group 'Total') because this
     * group is present in both colGroupTree and rowGroupTree.
     *
     * @param {Array[]} groupId
     * @param {'row'|'col'} type
     */
    closeGroup(groupId, type) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloading the table
        }

        let groupBys;
        let expandedGroupBys;
        let keyPart;
        let group;
        let tree;
        if (type === "row") {
            groupBys = this.metaData.rowGroupBys;
            expandedGroupBys = this.metaData.expandedRowGroupBys;
            tree = this.data.rowGroupTree;
            group = this._findGroup(this.data.rowGroupTree, groupId[0]);
            keyPart = 0;
        } else {
            groupBys = this.metaData.colGroupBys;
            expandedGroupBys = this.metaData.expandedColGroupBys;
            tree = this.data.colGroupTree;
            group = this._findGroup(this.data.colGroupTree, groupId[1]);
            keyPart = 1;
        }

        const groupIdPart = groupId[keyPart];
        const range = groupIdPart.map((_, index) => index);
        function keep(key) {
            const idPart = JSON.parse(key)[keyPart];
            return (
                range.some((index) => groupIdPart[index] !== idPart[index]) ||
                idPart.length === groupIdPart.length
            );
        }
        function omitKeys(object) {
            const newObject = {};
            for (const key in object) {
                if (keep(key)) {
                    newObject[key] = object[key];
                }
            }
            return newObject;
        }
        this.data.measurements = omitKeys(this.data.measurements);
        this.data.counts = omitKeys(this.data.counts);
        this.data.groupDomains = omitKeys(this.data.groupDomains);

        group.directSubTrees.clear();
        delete group.sortedKeys;
        var newGroupBysLength = this._getTreeHeight(tree) - 1;
        if (newGroupBysLength <= groupBys.length) {
            expandedGroupBys.splice(0);
            groupBys.splice(newGroupBysLength);
        } else {
            expandedGroupBys.splice(newGroupBysLength - groupBys.length);
        }
        this.notify();
    }
    /**
     * Reload the view with the current rowGroupBys and colGroupBys
     * This is the easiest way to expand all the groups that are not expanded
     */
    async expandAll() {
        const config = { metaData: this.metaData, data: this.data };
        await this._loadData(config, false);
        this.notify();
    }
    /**
     * Expand a group by using groupBy to split it and trigger a re-rendering.
     *
     * @param {Object} group
     * @param {'row'|'col'} type
     */
    async expandGroup(groupId, type) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const config = { metaData: this.metaData, data: this.data };
        await this._expandGroup(groupId, type, config);
        this.notify();
    }
    /**
     * Export model data in a form suitable for an easy encoding of the pivot
     * table in excell.
     *
     * @returns {Object}
     */
    exportData() {
        const measureCount = this.metaData.activeMeasures.length;
        const originCount = this.metaData.origins.length;

        const table = this.getTable();

        // process headers
        const headers = table.headers;
        let colGroupHeaderRows;
        let measureRow = [];
        let originRow = [];

        function processHeader(header) {
            const inTotalColumn = header.groupId[1].length === 0;
            return {
                title: header.title,
                width: header.width,
                height: header.height,
                is_bold: !!header.measure && inTotalColumn,
            };
        }

        if (originCount > 1) {
            colGroupHeaderRows = headers.slice(0, headers.length - 2);
            measureRow = headers[headers.length - 2].map(processHeader);
            originRow = headers[headers.length - 1].map(processHeader);
        } else {
            colGroupHeaderRows = headers.slice(0, headers.length - 1);
            measureRow = headers[headers.length - 1].map(processHeader);
        }

        // remove the empty headers on left side
        colGroupHeaderRows[0].splice(0, 1);

        colGroupHeaderRows = colGroupHeaderRows.map((headerRow) => {
            return headerRow.map(processHeader);
        });

        // process rows
        const tableRows = table.rows.map((row) => {
            return {
                title: row.title,
                indent: row.indent,
                values: row.subGroupMeasurements.map((measurement) => {
                    let value = measurement.value;
                    if (value === undefined) {
                        value = "";
                    } else if (measurement.originIndexes.length > 1) {
                        // in that case the value is a variation and a
                        // number between 0 and 1
                        value = value * 100;
                    }
                    return {
                        is_bold: measurement.isBold,
                        value: value,
                    };
                }),
            };
        });

        return {
            model: this.metaData.resModel,
            title: this.metaData.title,
            col_group_headers: colGroupHeaderRows,
            measure_headers: measureRow,
            origin_headers: originRow,
            rows: tableRows,
            measure_count: measureCount,
            origin_count: originCount,
        };
    }
    /**
     * Swap the pivot columns and the rows. The flip operation is synchronous.
     * However, we must wait for a potential pending reload to complete before
     * flipping the axes. This method is thus async.
     */
    async flip() {
        await this.race.getCurrentProm();

        // swap the data: the main column and the main row
        let temp = this.data.rowGroupTree;
        this.data.rowGroupTree = this.data.colGroupTree;
        this.data.colGroupTree = temp;

        // we need to update the record metaData: (expanded) row and col groupBys
        temp = this.metaData.rowGroupBys;
        this.metaData.rowGroupBys = this.metaData.colGroupBys;
        this.metaData.colGroupBys = temp;
        temp = this.metaData.expandedColGroupBys;
        this.metaData.expandedColGroupBys = this.metaData.expandedRowGroupBys;
        this.metaData.expandedRowGroupBys = temp;

        function twistKey(key) {
            return JSON.stringify(JSON.parse(key).reverse());
        }

        function twist(object) {
            const newObject = {};
            Object.keys(object).forEach((key) => {
                const value = object[key];
                newObject[twistKey(key)] = value;
            });
            return newObject;
        }

        this.data.measurements = twist(this.data.measurements);
        this.data.counts = twist(this.data.counts);
        this.data.groupDomains = twist(this.data.groupDomains);

        this.notify();
    }
    /**
     * Returns a domain representation of a group
     *
     * @param {Object} group
     * @param {Array} group.colValues
     * @param {Array} group.rowValues
     * @param {number} group.originIndex
     * @returns {Array[]}
     */
    getGroupDomain(group) {
        const config = { metaData: this.metaData, data: this.data };
        return this._getGroupDomain(group, config);
    }
    /**
     * Returns a description of the pivot table.
     *
     * @returns {Object}
     */
    getTable() {
        const headers = this._getTableHeaders();
        return {
            headers: headers,
            rows: this._getTableRows(this.data.rowGroupTree, headers[headers.length - 1]),
        };
    }
    /**
     * Returns the total number of columns of the pivot table.
     *
     * @returns {integer}
     */
    getTableWidth() {
        var leafCounts = this._getLeafCounts(this.data.colGroupTree);
        return leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] + 2;
    }
    /**
     * @returns {boolean} true iff there's no data in the table
     */
    hasData() {
        return this._hasData(this.data);
    }
    /**
     * @override
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        this.searchParams = searchParams;
        const processedMeasures = processMeasure(searchParams.context.pivot_measures);
        const activeMeasures = processedMeasures || this.metaData.activeMeasures;
        const metaData = this._buildMetaData({ activeMeasures });
        if (!this.reload) {
            metaData.rowGroupBys =
                searchParams.context.pivot_row_groupby ||
                (searchParams.groupBy.length ? searchParams.groupBy : metaData.rowGroupBys);
            this.reload = true;
        } else {
            metaData.rowGroupBys = searchParams.groupBy.length
                ? searchParams.groupBy
                : searchParams.context.pivot_row_groupby || metaData.rowGroupBys;
        }
        metaData.colGroupBys =
            searchParams.context.pivot_column_groupby || this.metaData.colGroupBys;

        if (JSON.stringify(metaData.rowGroupBys) !== JSON.stringify(this.metaData.rowGroupBys)) {
            metaData.expandedRowGroupBys = [];
        }
        if (JSON.stringify(metaData.colGroupBys) !== JSON.stringify(this.metaData.colGroupBys)) {
            metaData.expandedColGroupBys = [];
        }

        const allActivesMeasures = new Set(this.metaData.activeMeasures);
        if (processedMeasures) {
            processedMeasures.forEach((e) => allActivesMeasures.add(e));
        }

        metaData.measures = computeReportMeasures(metaData.fields, metaData.fieldAttrs, [
            ...allActivesMeasures,
        ]);
        const config = { metaData, data: this.data };
        await addPropertyFieldDefs(
            this.orm,
            metaData.resModel,
            searchParams.context,
            metaData.fields,
            new Set([...metaData.rowGroupBys, ...metaData.colGroupBys])
        );
        return this._loadData(config);
    }
    /**
     * Sort the rows, depending on the values of a given column.  This is an
     * in-memory sort.
     *
     * @param {Object} sortedColumn
     * @param {number[]} sortedColumn.groupId
     */
    sortRows(sortedColumn) {
        if (this.race.getCurrentProm()) {
            return; // we are currently reloaded the table
        }

        const config = { metaData: this.metaData, data: this.data };
        this._sortRows(sortedColumn, config);

        this.notify();
    }
    /**
     * Toggle the active state for a given measure, then reload the data
     * if this turns out to be necessary.
     *
     * @param {string} fieldName
     * @returns {Promise}
     */
    async toggleMeasure(fieldName) {
        const metaData = this._buildMetaData();
        this.nextActiveMeasures = this.nextActiveMeasures || metaData.activeMeasures;
        metaData.activeMeasures = this.nextActiveMeasures;
        const index = metaData.activeMeasures.indexOf(fieldName);
        if (index !== -1) {
            // in this case, we already have all data in memory, no need to
            // actually reload a lesser amount of information (but still, we need
            // to wait in case there is a pending load)
            metaData.activeMeasures.splice(index, 1);
            await Promise.resolve(this.race.getCurrentProm());
            this.metaData = metaData;
        } else {
            metaData.activeMeasures.push(fieldName);
            const config = { metaData, data: this.data };
            await this._loadData(config);
            this.useSampleModel = false;
        }
        this.nextActiveMeasures = null;
        this.notify();
    }

    //--------------------------------------------------------------------------
    // Protected
    //--------------------------------------------------------------------------

    /**
     * Add labels/values in the provided groupTree. A new leaf is created in
     * the groupTree with a root object corresponding to the group with given
     * labels/values.
     *
     * @protected
     * @param {Object} groupTree, either this.data.rowGroupTree or this.data.colGroupTree
     * @param {string[]} labels
     * @param {Array} values
     */
    _addGroup(groupTree, labels, values) {
        let tree = groupTree;
        // we assume here that the group with value value.slice(value.length - 2) has already been added.
        values.slice(0, values.length - 1).forEach(function (value) {
            tree = tree.directSubTrees.get(value);
        });
        const value = values[values.length - 1];
        if (tree.directSubTrees.has(value)) {
            return;
        }
        tree.directSubTrees.set(value, {
            root: {
                labels: labels,
                values: values,
            },
            directSubTrees: new Map(),
        });
    }
    /**
     * Return a copy of this.metaData, extended with optional params. This is useful
     * for async methods that need to modify this.metaData, but it can't be done in
     * place directly for the model to be concurrency proof (so they work on a
     * copy and commit it at the end).
     *
     * @protected
     * @param {Object} params
     * @returns {Object}
     */
    _buildMetaData(params) {
        const metaData = Object.assign({}, this.metaData, params);
        metaData.activeMeasures = [...metaData.activeMeasures];
        metaData.colGroupBys = [...metaData.colGroupBys];
        metaData.rowGroupBys = [...metaData.rowGroupBys];
        metaData.expandedColGroupBys = [...metaData.expandedColGroupBys];
        metaData.expandedRowGroupBys = [...metaData.expandedRowGroupBys];
        metaData.customGroupBys = new Map([...metaData.customGroupBys]);
        // shallow copy sortedColumn because we never modify groupId in place
        metaData.sortedColumn = metaData.sortedColumn ? { ...metaData.sortedColumn } : null;
        if (this.searchParams.comparison) {
            const domains = this.searchParams.comparison.domains.slice().reverse();
            metaData.domains = domains.map((d) => d.arrayRepr);
            metaData.origins = domains.map((d) => d.description);
        } else {
            metaData.domains = [this.searchParams.domain];
            metaData.origins = [""];
        }
        Object.defineProperty(metaData, "fullColGroupBys", {
            get() {
                return metaData.colGroupBys.concat(metaData.expandedColGroupBys);
            },
        });
        Object.defineProperty(metaData, "fullRowGroupBys", {
            get() {
                return metaData.rowGroupBys.concat(metaData.expandedRowGroupBys);
            },
        });
        return metaData;
    }
    /**
     * Expand a group by using groupBy to split it.
     *
     * @protected
     * @param {Object} group
     * @param {'row'|'col'} type
     * @param {Config} config
     */
    async _expandGroup(groupId, type, config) {
        const { metaData } = config;
        const group = {
            rowValues: groupId[0],
            colValues: groupId[1],
            type: type,
        };
        const groupValues = type === "row" ? groupId[0] : groupId[1];
        const groupBys = type === "row" ? metaData.fullRowGroupBys : metaData.fullColGroupBys;
        if (groupValues.length >= groupBys.length) {
            throw new Error("Cannot expand group");
        }
        const groupBy = groupBys[groupValues.length];
        let leftDivisors;
        let rightDivisors;
        if (group.type === "row") {
            leftDivisors = [[groupBy]];
            rightDivisors = sections(metaData.fullColGroupBys);
        } else {
            leftDivisors = sections(metaData.fullRowGroupBys);
            rightDivisors = [[groupBy]];
        }
        const divisors = cartesian(leftDivisors, rightDivisors);
        delete group.type;
        await this._subdivideGroup(group, divisors, config);
    }
    /**
     * Find a group with given values in the provided groupTree, either
     * this.rowGrouptree or this.data.colGroupTree.
     *
     * @protected
     * @param {Object} groupTree
     * @param {Array} values
     * @returns {Object}
     */
    _findGroup(groupTree, values) {
        let tree = groupTree;
        values.slice(0, values.length).forEach((value) => {
            tree = tree.directSubTrees.get(value);
        });
        return tree;
    }
    /**
     * In case originIndex is an array of length 1, thus a single origin
     * index, returns the given measure for a group determined by the id
     * groupId and the origin index.
     * If originIndexes is an array of length 2, we compute the variation
     * of the measure values for the groups determined by groupId and the
     * different origin indexes.
     *
     * @protected
     * @param {Array[]} groupId
     * @param {string} measure
     * @param {number[]} originIndexes
     * @param {Config} config
     * @returns {number}
     */
    _getCellValue(groupId, measure, originIndexes, config) {
        var key = JSON.stringify(groupId);
        if (!config.data.measurements[key]) {
            return;
        }
        var values = originIndexes.map((originIndex) => {
            return config.data.measurements[key][originIndex][measure];
        });
        if (originIndexes.length > 1) {
            return computeVariation(values[1], values[0]);
        } else {
            return values[0];
        }
    }
    /**
     * @protected
     * @param {string[]} rowGroupBy
     * @param {string[]} colGroupBy
     * @returns {string[]}
     */
    _getGroupBySpecs(rowGroupBy, colGroupBy) {
        const set = rowGroupBy.concat(colGroupBy).reduce((acc, gb) => {
            acc.add(this._normalize(gb));
            return acc;
        }, new Set());
        return [...set];
    }
    /**
     * Returns a domain representation of a group
     *
     * @protected
     * @param {Object} group
     * @param {Array} group.colValues
     * @param {Array} group.rowValues
     * @param {number} group.originIndex
     * @param {Config} config
     * @returns {Array[]}
     */
    _getGroupDomain(group, config) {
        const { data } = config;
        var key = JSON.stringify([group.rowValues, group.colValues]);
        return data.groupDomains[key][group.originIndex];
    }
    /**
     * Returns the group sanitized labels.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} groupBys
     * @param {Config} config
     * @returns {string[]}
     */
    _getGroupLabels(group, groupBys, config) {
        return groupBys.map((gb) => {
            const groupBy = this._normalize(gb);
            return this._sanitizeLabel(group[groupBy], groupBy, config);
        });
    }
    /**
     * Returns a promise that returns the annotated read_group results
     * corresponding to a partition of the given group obtained using the given
     * rowGroupBy and colGroupBy.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} rowGroupBy
     * @param {string[]} colGroupBy
     * @param {Object} params
     */
    async _getGroupSubdivision(group, rowGroupBy, colGroupBy, params) {
        const groupBy = this._getGroupBySpecs(rowGroupBy, colGroupBy);
        const subGroups = await this._getSubGroups(groupBy, params);
        return {
            group,
            subGroups,
            rowGroupBy: rowGroupBy,
            colGroupBy: colGroupBy,
        };
    }

    /**
     * Returns the group sanitized values.
     *
     * @protected
     * @param {Object} group
     * @param {string[]} groupBys
     * @returns {Array}
     */
    _getGroupValues(group, groupBys) {
        return groupBys.map((gb) => {
            const groupBy = this._normalize(gb);
            return this._sanitizeValue(group[groupBy]);
        });
    }
    /**
     * Returns the leaf counts of each group inside the given tree.
     *
     * @protected
     * @param {Object} tree
     * @returns {Object} keys are group ids
     */
    _getLeafCounts(tree) {
        const leafCounts = {};
        let leafCount;
        if (!tree.directSubTrees.size) {
            leafCount = 1;
        } else {
            leafCount = [...tree.directSubTrees.values()].reduce((acc, subTree) => {
                const subLeafCounts = this._getLeafCounts(subTree);
                Object.assign(leafCounts, subLeafCounts);
                return acc + leafCounts[JSON.stringify(subTree.root.values)];
            }, 0);
        }

        leafCounts[JSON.stringify(tree.root.values)] = leafCount;
        return leafCounts;
    }
    /**
     * Returns the group sanitized measure values for the measures in
     * this.metaData.activeMeasures (that migth contain '__count', not really a fieldName).
     *
     * @protected
     * @param {Object} group
     * @param {Config} config
     * @returns {Array}
     */
    _getMeasurements(group, config) {
        const { metaData } = config;
        return metaData.activeMeasures.reduce((measurements, measureName) => {
            var measurement = group[measureName];
            if (measurement instanceof Array) {
                // case field is many2one and used as measure and groupBy simultaneously
                measurement = 1;
            }
            if (
                metaData.measures[measureName].type === "boolean" &&
                measurement instanceof Boolean
            ) {
                measurement = measurement ? 1 : 0;
            }
            if (metaData.origins.length > 1 && !measurement) {
                measurement = 0;
            }
            measurements[measureName] = measurement;
            return measurements;
        }, {});
    }
    /**
     * Returns a description of the measures row of the pivot table
     *
     * @protected
     * @param {Object[]} columns for which measure cells must be generated
     * @returns {Object[]}
     */
    _getMeasuresRow(columns) {
        const sortedColumn = this.metaData.sortedColumn || {};
        const measureRow = [];

        columns.forEach((column) => {
            this.metaData.activeMeasures.forEach((measureName) => {
                const measureCell = {
                    groupId: column.groupId,
                    height: 1,
                    measure: measureName,
                    title: this.metaData.measures[measureName].string,
                    width: 2 * this.metaData.origins.length - 1,
                };
                if (
                    sortedColumn.measure === measureName &&
                    JSON.stringify(sortedColumn.groupId) === JSON.stringify(column.groupId) // FIXME
                ) {
                    measureCell.order = sortedColumn.order;
                }
                measureRow.push(measureCell);
            });
        });

        return measureRow;
    }
    /**
     * Returns the list of measure specs associated with metaData.activeMeasures, i.e.
     * a measure 'fieldName' becomes 'fieldName:aggregator' where
     * aggregator is the value specified on the field 'fieldName' for
     * the key aggregator.
     *
     * @protected
     * @param {Config} config
     * @return {string[]}
     */
    _getMeasureSpecs(config) {
        const { metaData } = config;
        return metaData.activeMeasures.reduce((acc, measure) => {
            if (measure === "__count") {
                acc.push(measure);
                return acc;
            }
            const field = this.metaData.fields[measure];
            if (field.type === "many2one") {
                field.aggregator = "count_distinct";
            }
            if (field.aggregator === undefined) {
                throw new Error(
                    "No aggregate function has been provided for the measure '" + measure + "'"
                );
            }
            acc.push(measure + ":" + field.aggregator);
            return acc;
        }, []);
    }
    /**
     * Make sure that the labels of different many2one values are distinguished
     * by numbering them if necessary.
     *
     * @protected
     * @param {Array} label
     * @param {string} fieldName
     * @param {Config} config
     * @returns {string}
     */
    _getNumberedLabel(label, fieldName, config) {
        const { data } = config;
        const id = label[0];
        const name = label[1];
        data.numbering[fieldName] = data.numbering[fieldName] || {};
        data.numbering[fieldName][name] = data.numbering[fieldName][name] || {};
        const numbers = data.numbering[fieldName][name];
        numbers[id] = numbers[id] || Object.keys(numbers).length + 1;
        return name + (numbers[id] > 1 ? "  (" + numbers[id] + ")" : "");
    }
    /**
     * Returns a description of the origins row of the pivot table
     *
     * @protected
     * @param {Object[]} columns for which origin cells must be generated
     * @returns {Object[]}
     */
    _getOriginsRow(columns) {
        const sortedColumn = this.metaData.sortedColumn || {};
        const originRow = [];

        columns.forEach((column) => {
            const groupId = column.groupId;
            const measure = column.measure;
            const isSorted =
                sortedColumn.measure === measure &&
                JSON.stringify(sortedColumn.groupId) === JSON.stringify(groupId); // FIXME
            const isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];
            const isSortedByVariation = isSorted && sortedColumn.originIndexes[1];

            this.metaData.origins.forEach((origin, originIndex) => {
                const originCell = {
                    groupId: groupId,
                    height: 1,
                    measure: measure,
                    originIndexes: [originIndex],
                    title: origin,
                    width: 1,
                };
                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {
                    originCell.order = sortedColumn.order;
                }
                originRow.push(originCell);

                if (originIndex > 0) {
                    const variationCell = {
                        groupId: groupId,
                        height: 1,
                        measure: measure,
                        originIndexes: [originIndex - 1, originIndex],
                        title: _t("Variation"),
                        width: 1,
                    };
                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {
                        variationCell.order = sortedColumn.order;
                    }
                    originRow.push(variationCell);
                }
            });
        });

        return originRow;
    }
    /**
     * @protected
     * @param {string[]} groupBy
     * @param {Object} params
     * @returns {Promise<Object[]>}
     */
    async _getSubGroups(groupBy, params) {
        const { resModel, groupDomain, measureSpecs, kwargs, mapping } = params;
        const key = JSON.stringify(groupBy);
        if (!mapping[key]) {
            mapping[key] = this.orm.readGroup(resModel, groupDomain, measureSpecs, groupBy, kwargs);
        }
        return mapping[key];
    }
    /**
     * Returns the list of header rows of the pivot table: the col group rows
     * (depending on the col groupbys), the measures row and optionnaly the
     * origins row (if there are more than one origins).
     *
     * @protected
     * @returns {Object[]}
     */
    _getTableHeaders() {
        const colGroupBys = this.metaData.fullColGroupBys;
        const height = colGroupBys.length + 1;
        const measureCount = this.metaData.activeMeasures.length;
        const originCount = this.metaData.origins.length;
        const leafCounts = this._getLeafCounts(this.data.colGroupTree);
        let headers = [];
        const measureColumns = []; // used to generate the measure cells

        // 1) generate col group rows (total row + one row for each col groupby)
        const colGroupRows = new Array(height).fill(0).map(() => []);
        // blank top left cell
        colGroupRows[0].push({
            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]
            title: "",
            width: 1,
        });

        // col groupby cells with group values
        /**
         * Recursive function that generates the header cells corresponding to
         * the groups of a given tree.
         *
         * @param {Object} tree
         */
        function generateTreeHeaders(tree, fields) {
            const group = tree.root;
            const rowIndex = group.values.length;
            const row = colGroupRows[rowIndex];
            const groupId = [[], group.values];
            const isLeaf = !tree.directSubTrees.size;
            const leafCount = leafCounts[JSON.stringify(tree.root.values)];
            const cell = {
                groupId: groupId,
                height: isLeaf ? colGroupBys.length + 1 - rowIndex : 1,
                isLeaf: isLeaf,
                isFolded: isLeaf && colGroupBys.length > group.values.length,
                label:
                    rowIndex === 0
                        ? undefined
                        : fields[colGroupBys[rowIndex - 1].split(":")[0]].string,
                title: group.labels.length ? group.labels[group.labels.length - 1] : _t("Total"),
                width: leafCount * measureCount * (2 * originCount - 1),
            };
            row.push(cell);
            if (isLeaf) {
                measureColumns.push(cell);
            }

            [...tree.directSubTrees.values()].forEach((subTree) => {
                generateTreeHeaders(subTree, fields);
            });
        }

        generateTreeHeaders(this.data.colGroupTree, this.metaData.fields);
        // blank top right cell for 'Total' group (if there is more that one leaf)
        if (leafCounts[JSON.stringify(this.data.colGroupTree.root.values)] > 1) {
            var groupId = [[], []];
            var totalTopRightCell = {
                groupId: groupId,
                height: height,
                title: "",
                width: measureCount * (2 * originCount - 1),
            };
            colGroupRows[0].push(totalTopRightCell);
            measureColumns.push(totalTopRightCell);
        }
        headers = headers.concat(colGroupRows);

        // 2) generate measures row
        var measuresRow = this._getMeasuresRow(measureColumns);
        headers.push(measuresRow);

        // 3) generate origins row if more than one origin
        if (originCount > 1) {
            headers.push(this._getOriginsRow(measuresRow));
        }

        return headers;
    }
    /**
     * Returns the list of body rows of the pivot table for a given tree.
     *
     * @protected
     * @param {Object} tree
     * @param {Object[]} columns
     * @returns {Object[]}
     */
    _getTableRows(tree, columns) {
        let rows = [];
        const group = tree.root;
        const rowGroupId = [group.values, []];
        const title = group.labels.length ? group.labels[group.labels.length - 1] : _t("Total");
        const indent = group.labels.length;
        const isLeaf = !tree.directSubTrees.size;
        const rowGroupBys = this.metaData.fullRowGroupBys;

        const subGroupMeasurements = columns.map((column) => {
            const colGroupId = column.groupId;
            const groupIntersectionId = [rowGroupId[0], colGroupId[1]];
            const measure = column.measure;
            const originIndexes = column.originIndexes || [0];

            const value = this._getCellValue(groupIntersectionId, measure, originIndexes, {
                data: this.data,
            });

            const measurement = {
                groupId: groupIntersectionId,
                originIndexes: originIndexes,
                measure: measure,
                value: value,
                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,
            };
            return measurement;
        });

        rows.push({
            title: title,
            label:
                indent === 0
                    ? undefined
                    : this.metaData.fields[rowGroupBys[indent - 1].split(":")[0]].string,
            groupId: rowGroupId,
            indent: indent,
            isLeaf: isLeaf,
            isFolded: isLeaf && rowGroupBys.length > group.values.length,
            subGroupMeasurements: subGroupMeasurements,
        });

        const subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];
        subTreeKeys.forEach((subTreeKey) => {
            const subTree = tree.directSubTrees.get(subTreeKey);
            rows = rows.concat(this._getTableRows(subTree, columns));
        });

        return rows;
    }
    /**
     * returns the height of a given groupTree
     *
     * @protected
     * @param {Object} tree, a groupTree
     * @returns {number}
     */
    _getTreeHeight(tree) {
        const subTreeHeights = [...tree.directSubTrees.values()].map(
            this._getTreeHeight.bind(this)
        );
        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;
    }
    /**
     * @protected
     * @param {Data} data
     * @returns {boolean} true iff there's no data in the table
     */
    _hasData(data) {
        return (data.counts[JSON.stringify([[], []])] || []).some((count) => {
            return count > 0;
        });
    }
    /**
     * Initialize/Reinitialize data.rowGroupTree, colGroupTree, measurements,
     * counts and subdivide the group 'Total' as many times it is necessary.
     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in
     * order to see if there is data in the intersection of the group 'Total'
     * and the various origins. In case there is none, non supplementary rpc
     * will be done (see the code of subdivideGroup).
     *
     * @protected
     * @param {Config} config
     */
    async _loadData(config, prune = true) {
        config.data = {}; // data will be completely recomputed
        const { data, metaData } = config;
        data.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        data.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        data.measurements = {};
        data.counts = {};
        data.groupDomains = {};
        data.numbering = {};
        const key = JSON.stringify([[], []]);
        data.groupDomains[key] = metaData.domains.slice(0);

        const group = { rowValues: [], colValues: [] };
        const leftDivisors = sections(metaData.fullRowGroupBys);
        const rightDivisors = sections(metaData.fullColGroupBys);
        const divisors = cartesian(leftDivisors, rightDivisors);

        await this._subdivideGroup(group, divisors.slice(0, 1), config);
        await this._subdivideGroup(group, divisors.slice(1), config);

        // keep folded groups folded after the reload if the structure of the table is the same
        if (prune && this._hasData(data) && this._hasData(this.data)) {
            if (
                symmetricalDifference(metaData.rowGroupBys, this.metaData.rowGroupBys).length === 0
            ) {
                this._pruneTree(data.rowGroupTree, this.data.rowGroupTree);
            }
            if (
                symmetricalDifference(metaData.colGroupBys, this.metaData.colGroupBys).length === 0
            ) {
                this._pruneTree(data.colGroupTree, this.data.colGroupTree);
            }
        }

        this.data = config.data;
        this.metaData = config.metaData;
    }
    /**
     * @protected
     * @param {string} gb
     * @returns {string}
     */
    _normalize(gb) {
        const [fieldName, interval] = gb.split(":");
        const field = this.metaData.fields[fieldName];
        if (["date", "datetime"].includes(field.type)) {
            return `${fieldName}:${interval || "month"}`;
        } else {
            return fieldName;
        }
    }
    /**
     * Extract the information in the read_group results (groupSubdivisions)
     * and develop this.data.rowGroupTree, colGroupTree, measurements, counts, and
     * groupDomains.
     * If a column needs to be sorted, the rowGroupTree corresponding to the
     * group is sorted.
     *
     * @protected
     * @param {Object} group
     * @param {Object[]} groupSubdivisions
     * @param {Config} config
     */
    _prepareData(group, groupSubdivisions, config) {
        const { data, metaData } = config;
        const groupRowValues = group.rowValues;
        let groupRowLabels = [];
        let rowSubTree = data.rowGroupTree;
        let root;
        if (groupRowValues.length) {
            // we should have labels information on hand! regretful!
            rowSubTree = this._findGroup(data.rowGroupTree, groupRowValues);
            root = rowSubTree.root;
            groupRowLabels = root.labels;
        }

        const groupColValues = group.colValues;
        let groupColLabels = [];
        if (groupColValues.length) {
            root = this._findGroup(data.colGroupTree, groupColValues).root;
            groupColLabels = root.labels;
        }

        groupSubdivisions.forEach((groupSubdivision) => {
            groupSubdivision.subGroups.forEach((subGroup) => {
                const rowValues = groupRowValues.concat(
                    this._getGroupValues(subGroup, groupSubdivision.rowGroupBy)
                );
                const rowLabels = groupRowLabels.concat(
                    this._getGroupLabels(subGroup, groupSubdivision.rowGroupBy, config)
                );

                const colValues = groupColValues.concat(
                    this._getGroupValues(subGroup, groupSubdivision.colGroupBy)
                );
                const colLabels = groupColLabels.concat(
                    this._getGroupLabels(subGroup, groupSubdivision.colGroupBy, config)
                );

                if (!colValues.length && rowValues.length) {
                    this._addGroup(data.rowGroupTree, rowLabels, rowValues);
                }
                if (colValues.length && !rowValues.length) {
                    this._addGroup(data.colGroupTree, colLabels, colValues);
                }

                const key = JSON.stringify([rowValues, colValues]);
                const originIndex = groupSubdivision.group.originIndex;

                if (!(key in data.measurements)) {
                    data.measurements[key] = metaData.origins.map(() => {
                        return this._getMeasurements({}, config);
                    });
                }
                data.measurements[key][originIndex] = this._getMeasurements(subGroup, config);

                if (!(key in data.counts)) {
                    data.counts[key] = metaData.origins.map(function () {
                        return 0;
                    });
                }
                data.counts[key][originIndex] = subGroup.__count;

                if (!(key in data.groupDomains)) {
                    data.groupDomains[key] = metaData.origins.map(function () {
                        return Domain.FALSE.toList();
                    });
                }
                // if __domain is not defined this means that we are in the
                // case where
                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []
                if (subGroup.__domain) {
                    data.groupDomains[key][originIndex] = subGroup.__domain;
                }
            });
        });

        if (metaData.sortedColumn) {
            this._sortRows(metaData.sortedColumn, config);
        }
    }
    /**
     * Make any group in tree a leaf if it was a leaf in oldTree.
     *
     * @protected
     * @param {Object} tree
     * @param {Object} oldTree
     */
    _pruneTree(tree, oldTree) {
        if (!oldTree.directSubTrees.size) {
            tree.directSubTrees.clear();
            delete tree.sortedKeys;
            return;
        }
        [...tree.directSubTrees.keys()].forEach((subTreeKey) => {
            const subTree = tree.directSubTrees.get(subTreeKey);
            if (!oldTree.directSubTrees.has(subTreeKey)) {
                subTree.directSubTrees.clear();
                delete subTree.sortedKeys;
            } else {
                const oldSubTree = oldTree.directSubTrees.get(subTreeKey);
                this._pruneTree(subTree, oldSubTree);
            }
        });
    }

    _getEmptyGroupLabel(fieldName) {
        return _t("None");
    }

    /**
     * Extract from a groupBy value a label.
     *
     * @protected
     * @param {any} value
     * @param {string} groupBy
     * @param {Config} config
     * @returns {string}
     */
    _sanitizeLabel(value, groupBy, config) {
        const { metaData } = config;
        const fieldName = groupBy.split(":")[0];
        if (
            fieldName &&
            metaData.fields[fieldName] &&
            metaData.fields[fieldName].type === "boolean"
        ) {
            return value === undefined ? _t("None") : value ? _t("Yes") : _t("No");
        }
        if (value === false) {
            return this._getEmptyGroupLabel(fieldName);
        }
        if (value instanceof Array) {
            return this._getNumberedLabel(value, fieldName, config);
        }
        if (
            fieldName &&
            metaData.fields[fieldName] &&
            metaData.fields[fieldName].type === "selection"
        ) {
            const selected = metaData.fields[fieldName].selection.find((o) => o[0] === value);
            return selected ? selected[1] : value; // selected should be truthy normally ?!
        }
        return value;
    }
    /**
     * Extract from a groupBy value the raw value of that groupBy (discarding
     * a label if any)
     *
     * @protected
     * @param {any} value
     * @returns {any}
     */
    _sanitizeValue(value) {
        if (value instanceof Array) {
            return value[0];
        }
        return value;
    }
    /**
     * Get all partitions of a given group using the provided list of divisors
     * and enrich the objects of this.data.rowGroupTree, colGroupTree,
     * measurements, counts.
     *
     * @protected
     * @param {Object} group
     * @param {Array[]} divisors
     * @param {Config} config
     */
    async _subdivideGroup(group, divisors, config) {
        const { data, metaData } = config;
        const key = JSON.stringify([group.rowValues, group.colValues]);

        const proms = metaData.origins.reduce((acc, origin, originIndex) => {
            // if no information on group content is available, we fetch data.
            // if group is known to be empty for the given origin,
            // we don't need to fetch data for that origin.
            if (!data.counts[key] || data.counts[key][originIndex] > 0) {
                const subGroup = {
                    rowValues: group.rowValues,
                    colValues: group.colValues,
                    originIndex: originIndex,
                };
                const groupDomain = this._getGroupDomain(subGroup, config);
                const measureSpecs = this._getMeasureSpecs(config);
                const resModel = config.metaData.resModel;
                const kwargs = { lazy: false, context: this.searchParams.context };
                const mapping = {};
                divisors.forEach((divisor) => {
                    acc.push(
                        this._getGroupSubdivision(subGroup, divisor[0], divisor[1], {
                            resModel,
                            groupDomain,
                            measureSpecs,
                            kwargs,
                            mapping,
                        })
                    );
                });
            }
            return acc;
        }, []);
        const groupSubdivisions = await this.keepLast.add(Promise.all(proms));
        if (groupSubdivisions.length) {
            this._prepareData(group, groupSubdivisions, config);
        }
    }
    /**
     * Sort the rows, depending on the values of a given column.  This is an
     * in-memory sort.
     *
     * @protected
     * @param {Object} sortedColumn
     * @param {number[]} sortedColumn.groupId
     * @param {Config} config
     */
    _sortRows(sortedColumn, config) {
        const metaData = config.metaData || this.metaData;
        const data = config.data || this.data;
        const colGroupValues = sortedColumn.groupId[1];
        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];
        metaData.sortedColumn = sortedColumn;

        const sortFunction = (tree) => {
            return (subTreeKey) => {
                const subTree = tree.directSubTrees.get(subTreeKey);
                const groupIntersectionId = [subTree.root.values, colGroupValues];
                const value =
                    this._getCellValue(
                        groupIntersectionId,
                        sortedColumn.measure,
                        sortedColumn.originIndexes,
                        { data }
                    ) || 0;
                return sortedColumn.order === "asc" ? value : -value;
            };
        };

        this._sortTree(sortFunction, data.rowGroupTree);
    }
    /**
     * Sort recursively the subTrees of tree using sortFunction.
     * In the end each node of the tree has its direct children sorted
     * according to the criterion reprensented by sortFunction.
     *
     * @protected
     * @param {Function} sortFunction
     * @param {Object} tree
     */
    _sortTree(sortFunction, tree) {
        tree.sortedKeys = sortBy([...tree.directSubTrees.keys()], sortFunction(tree));
        [...tree.directSubTrees.values()].forEach((subTree) => {
            this._sortTree(sortFunction, subTree);
        });
    }
}

return __exports;
});
;

/************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_renderer.js  *
*  Lines: 256                                               *
************************************************************/
odoo.define('@web/views/pivot/pivot_renderer', ['@web/core/l10n/translation', '@web/core/checkbox/checkbox', '@web/core/l10n/localization', '@web/core/registry', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/views/fields/formatters', '@web/views/pivot/pivot_header', '@odoo/owl', '@web/core/network/download', '@web/core/utils/hooks', '@web/views/view_components/report_view_measures'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { localization } = require("@web/core/l10n/localization");
const { registry } = require("@web/core/registry");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { formatPercentage } = require("@web/views/fields/formatters");
const { PivotHeader } = require("@web/views/pivot/pivot_header");

const { Component, onWillUpdateProps, useRef } = require("@odoo/owl");
const { download } = require("@web/core/network/download");
const { useService } = require("@web/core/utils/hooks");
const { ReportViewMeasures } = require("@web/views/view_components/report_view_measures");

const formatters = registry.category("formatters");

const PivotRenderer = __exports.PivotRenderer = class PivotRenderer extends Component {
    static template = "web.PivotRenderer";
    static components = { Dropdown, DropdownItem, CheckBox, PivotHeader, ReportViewMeasures };
    static props = ["model", "buttonTemplate"];

    setup() {
        this.actionService = useService("action");
        this.model = this.props.model;
        this.table = this.model.getTable();
        this.l10n = localization;
        this.tableRef = useRef("table");

        onWillUpdateProps(this.onWillUpdateProps);
    }
    onWillUpdateProps() {
        this.table = this.model.getTable();
    }
    /**
     * Get the formatted value of the cell.
     *
     * @private
     * @param {Object} cell
     * @returns {string} Formatted value
     */
    getFormattedValue(cell) {
        const field = this.model.metaData.measures[cell.measure];
        let formatType = this.model.metaData.widgets[cell.measure];
        if (!formatType) {
            const fieldType = field.type;
            formatType = ["many2one", "reference"].includes(fieldType) ? "integer" : fieldType;
        }
        const formatter = formatters.get(formatType);
        return formatter(cell.value, field);
    }
    /**
     * Get the formatted variation of a cell.
     *
     * @private
     * @param {Object} cell
     * @returns {string} Formatted variation
     */
    getFormattedVariation(cell) {
        if (isNaN(cell.value)) {
            return "-";
        }
        return formatPercentage(cell.value, this.model.metaData.fields[cell.measure]);
    }

    getHeaderProps({ cell, isXAxis = false, isInHead = false }) {
        const type = isXAxis ? "col" : "row";
        return {
            cell,
            isXAxis,
            isInHead,
            customGroupBys: this.model.metaData.customGroupBys,
            onItemSelected: (payload) => this.onGroupBySelected(type, payload),
            onAddCustomGroupBy: (fieldName) =>
                this.onAddCustomGroupBy(type, cell.groupId, fieldName),
            onClick: () => this.onHeaderClick(cell, type),
        };
    }

    //----------------------------------------------------------------------
    // Handlers
    //----------------------------------------------------------------------

    /**
     * Handle the adding of a custom groupby (inside the view, not the searchview).
     *
     * @param {"col"|"row"} type
     * @param {Array[]} groupId
     * @param {string} fieldName
     */
    onAddCustomGroupBy(type, groupId, fieldName) {
        this.model.addGroupBy({ groupId, fieldName, custom: true, type });
    }

    /**
     * Handle the selection of a groupby dropdown item.
     *
     * @param {"col"|"row"} type
     * @param {Object} payload
     */
    onGroupBySelected(type, payload) {
        this.model.addGroupBy({ ...payload, type });
    }
    /**
     * Handle a click on a header cell.
     *
     * @param {Object} cell
     * @param {string} type col or row
     */
    onHeaderClick(cell, type) {
        if (cell.isLeaf && cell.isFolded) {
            this.model.expandGroup(cell.groupId, type);
        } else if (!cell.isLeaf) {
            this.model.closeGroup(cell.groupId, type);
        }
    }
    /**
     * Handle a click on a measure cell.
     *
     * @param {Object} cell
     */
    onMeasureClick(cell) {
        this.model.sortRows({
            groupId: cell.groupId,
            measure: cell.measure,
            order: (cell.order || "desc") === "asc" ? "desc" : "asc",
            originIndexes: cell.originIndexes,
        });
    }
    /**
     * Hover the column in which the mouse is.
     *
     * @param {MouseEvent} ev
     */
    onMouseEnter(ev) {
        var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);
        if (ev.currentTarget.tagName === "TH") {
            if (
                !ev.currentTarget.classList.contains("o_pivot_origin_row") &&
                this.model.metaData.origins.length === 2
            ) {
                index = 3 * index; // two origins + comparison column
            }
            index += 1; // row groupbys column
        }
        this.tableRef.el
            .querySelectorAll("td:nth-child(" + (index + 1) + ")")
            .forEach((elt) => elt.classList.add("o_cell_hover"));
    }
    /**
     * Remove the hover on the columns.
     */
    onMouseLeave() {
        this.tableRef.el
            .querySelectorAll(".o_cell_hover")
            .forEach((elt) => elt.classList.remove("o_cell_hover"));
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Exports the current pivot table data in a xls file. For this, we have to
     * serialize the current state, then call the server /web/pivot/export_xlsx.
     * Force a reload before exporting to ensure to export up-to-date data.
     */
    onDownloadButtonClicked() {
        if (this.model.getTableWidth() > 16384) {
            throw new Error(
                _t(
                    "For Excel compatibility, data cannot be exported if there are more than 16384 columns.\n\nTip: try to flip axis, filter further or reduce the number of measures."
                )
            );
        }
        const table = this.model.exportData();
        download({
            url: "/web/pivot/export_xlsx",
            data: { data: new Blob([JSON.stringify(table)], { type: "application/json" }) },
        });
    }
    /**
     * Expands all groups
     */
    onExpandButtonClicked() {
        this.model.expandAll();
    }
    /**
     * Flips axis
     */
    onFlipButtonClicked() {
        this.model.flip();
    }
    /**
     * Toggles the given measure
     *
     * @param {Object} param0
     * @param {string} param0.measure
     */
    onMeasureSelected({ measure }) {
        this.model.toggleMeasure(measure);
    }
    /**
     * Execute the action to open the view on the current model.
     *
     * @param {Array} domain
     * @param {Array} views
     * @param {Object} context
     */
    openView(domain, views, context) {
        this.actionService.doAction({
            type: "ir.actions.act_window",
            name: this.model.metaData.title,
            res_model: this.model.metaData.resModel,
            views: views,
            view_mode: "list",
            target: "current",
            context,
            domain,
        });
    }
    /**
     * @param {CustomEvent} ev
     */
    onOpenView(cell) {
        if (cell.value === undefined || this.model.metaData.disableLinking) {
            return;
        }

        const context = Object.assign({}, this.model.searchParams.context);
        Object.keys(context).forEach((x) => {
            if (x === "group_by" || x.startsWith("search_default_")) {
                delete context[x];
            }
        });

        // retrieve form and list view ids from the action
        const { views = [] } = this.env.config;
        this.views = ["list", "form"].map((viewType) => {
            const view = views.find((view) => view[1] === viewType);
            return [view ? view[0] : false, viewType];
        });

        const group = {
            rowValues: cell.groupId[0],
            colValues: cell.groupId[1],
            originIndex: cell.originIndexes[0],
        };
        this.openView(this.model.getGroupDomain(group), this.views, context);
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web/static/src/views/pivot/pivot_search_model.js  *
*  Lines: 29                                                    *
****************************************************************/
odoo.define('@web/views/pivot/pivot_search_model', ['@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
const { SearchModel } = require("@web/search/search_model");

const PivotSearchModel = __exports.PivotSearchModel = class PivotSearchModel extends SearchModel {
    _getIrFilterDescription() {
        this.preparingIrFilterDescription = true;
        const result = super._getIrFilterDescription(...arguments);
        this.preparingIrFilterDescription = false;
        return result;
    }

    _getSearchItemGroupBys(activeItem) {
        const { searchItemId } = activeItem;
        const { context, type } = this.searchItems[searchItemId];
        if (
            !this.preparingIrFilterDescription &&
            type === "favorite" &&
            context.pivot_row_groupby
        ) {
            return context.pivot_row_groupby;
        }
        return super._getSearchItemGroupBys(...arguments);
    }
}

return __exports;
});
;

/********************************************************
*  Filepath: /web/static/src/views/pivot/pivot_view.js  *
*  Lines: 66                                            *
********************************************************/
odoo.define('@web/views/pivot/pivot_view', ['@web/core/l10n/translation', '@web/core/registry', '@web/views/pivot/pivot_arch_parser', '@web/views/pivot/pivot_controller', '@web/views/pivot/pivot_model', '@web/views/pivot/pivot_renderer', '@web/views/pivot/pivot_search_model'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");
const { registry } = require("@web/core/registry");
const { PivotArchParser } = require("@web/views/pivot/pivot_arch_parser");
const { PivotController } = require("@web/views/pivot/pivot_controller");
const { PivotModel } = require("@web/views/pivot/pivot_model");
const { PivotRenderer } = require("@web/views/pivot/pivot_renderer");
const { PivotSearchModel } = require("@web/views/pivot/pivot_search_model");

const viewRegistry = registry.category("views");

const pivotView = __exports.pivotView = {
    type: "pivot",
    Controller: PivotController,
    Renderer: PivotRenderer,
    Model: PivotModel,
    ArchParser: PivotArchParser,
    SearchModel: PivotSearchModel,
    searchMenuTypes: ["filter", "groupBy", "comparison", "favorite"],
    buttonTemplate: "web.PivotView.Buttons",

    props: (genericProps, view) => {
        const modelParams = {};
        if (genericProps.state) {
            modelParams.data = genericProps.state.data;
            modelParams.metaData = genericProps.state.metaData;
        } else {
            const { arch, fields, resModel } = genericProps;

            // parse arch
            const archInfo = new view.ArchParser().parse(arch);

            if (!archInfo.activeMeasures.length || archInfo.displayQuantity) {
                archInfo.activeMeasures.unshift("__count");
            }

            modelParams.metaData = {
                activeMeasures: archInfo.activeMeasures,
                colGroupBys: archInfo.colGroupBys,
                defaultOrder: archInfo.defaultOrder,
                disableLinking: Boolean(archInfo.disableLinking),
                fields: fields,
                fieldAttrs: archInfo.fieldAttrs,
                resModel: resModel,
                rowGroupBys: archInfo.rowGroupBys,
                title: archInfo.title || _t("Untitled"),
                widgets: archInfo.widgets,
            };
        }

        return {
            ...genericProps,
            Model: view.Model,
            modelParams,
            Renderer: view.Renderer,
            buttonTemplate: view.buttonTemplate,
        };
    },
};

viewRegistry.add("pivot", pivotView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_arch_parser.js  *
*  Lines: 59                                                              *
**************************************************************************/
odoo.define('@mail/views/web/activity/activity_arch_parser', ['@web/core/utils/xml', '@web/views/fields/field'], function (require) {
'use strict';
let __exports = {};
const { visitXML } = require("@web/core/utils/xml");
const { Field } = require("@web/views/fields/field");

const ActivityArchParser = __exports.ActivityArchParser = class ActivityArchParser {
    parse(xmlDoc, models, modelName) {
        const jsClass = xmlDoc.getAttribute("js_class");
        const title = xmlDoc.getAttribute("string");

        const fieldNodes = {};
        const templateDocs = {};
        const fieldNextIds = {};

        visitXML(xmlDoc, (node) => {
            if (node.hasAttribute("t-name")) {
                templateDocs[node.getAttribute("t-name")] = node;
                return;
            }

            if (node.tagName === "field") {
                const fieldInfo = Field.parseFieldNode(
                    node,
                    models,
                    modelName,
                    "activity",
                    jsClass
                );
                if (!(fieldInfo.name in fieldNextIds)) {
                    fieldNextIds[fieldInfo.name] = 0;
                }
                const fieldId = `${fieldInfo.name}_${fieldNextIds[fieldInfo.name]++}`;
                fieldNodes[fieldId] = fieldInfo;
                node.setAttribute("field_id", fieldId);
            }

            // Keep track of last update so images can be reloaded when they may have changed.
            if (node.tagName === "img") {
                const attSrc = node.getAttribute("t-att-src");
                if (
                    attSrc &&
                    /\bactivity_image\b/.test(attSrc) &&
                    !Object.values(fieldNodes).some((f) => f.name === "write_date")
                ) {
                    fieldNodes.write_date_0 = { name: "write_date", type: "datetime" };
                }
            }
        });
        return {
            fieldNodes,
            templateDocs,
            title,
        };
    }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_cell.js  *
*  Lines: 76                                                       *
*******************************************************************/
odoo.define('@mail/views/web/activity/activity_cell', ['@mail/core/web/activity_list_popover', '@mail/views/web/fields/avatar/avatar', '@odoo/owl', '@web/core/popover/popover_hook', '@web/core/l10n/dates'], function (require) {
'use strict';
let __exports = {};
const { ActivityListPopover } = require("@mail/core/web/activity_list_popover");
const { Avatar } = require("@mail/views/web/fields/avatar/avatar");

const { Component, useRef } = require("@odoo/owl");

const { usePopover } = require("@web/core/popover/popover_hook");

const { formatDate } = require("@web/core/l10n/dates");

const ActivityCell = __exports.ActivityCell = class ActivityCell extends Component {
    static components = {
        Avatar,
    };
    static props = {
        activityIds: {
            type: Array,
            elements: Number,
        },
        attachmentsInfo: {
            optional: true,
            type: Object,
        },
        activityTypeId: Number,
        reportingDate: String,
        countByState: Object,
        reloadFunc: Function,
        resId: Number,
        resModel: String,
        userAssignedIds: Array,
    };
    static template = "mail.ActivityCell";

    setup() {
        this.popover = usePopover(ActivityListPopover, { position: "bottom-start" });
        this.contentRef = useRef("content");
    }

    get reportingDateFormatted() {
        return formatDate(luxon.DateTime.fromISO(this.props.reportingDate));
    }

    get ongoingActivityCount() {
        return (
            (this.props.countByState?.planned ?? 0) +
            (this.props.countByState?.today ?? 0) +
            (this.props.countByState?.overdue ?? 0)
        );
    }

    get totalActivityCount() {
        return this.ongoingActivityCount + (this.props.countByState?.done ?? 0);
    }

    onClick() {
        if (this.popover.isOpen) {
            this.popover.close();
        } else {
            this.popover.open(this.contentRef.el, {
                activityIds: this.props.activityIds,
                defaultActivityTypeId: this.props.activityTypeId,
                onActivityChanged: () => {
                    this.props.reloadFunc();
                    this.popover.close();
                },
                resId: this.props.resId,
                resModel: this.props.resModel,
            });
        }
    }
}

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_compiler.js  *
*  Lines: 97                                                           *
***********************************************************************/
odoo.define('@mail/views/web/activity/activity_compiler', ['@web/core/utils/xml', '@web/views/view_compiler', '@web/views/utils'], function (require) {
'use strict';
let __exports = {};
const { createElement, extractAttributes } = require("@web/core/utils/xml");
const { toInterpolatedStringExpression, ViewCompiler } = require("@web/views/view_compiler");
const { toStringExpression } = require("@web/views/utils");

const ActivityCompiler = __exports.ActivityCompiler = class ActivityCompiler extends ViewCompiler {
    /**
     * @override
     */
    compileField(el, params) {
        let compiled;
        if (el.hasAttribute("widget")) {
            compiled = super.compileField(el, params);
        } else {
            // fields without a specified widget are rendered as simple spans in activity records
            compiled = createElement("div", {
                "t-out": `record["${el.getAttribute("name")}"].value`,
            });
        }
        const classNames = [];
        const { bold, display, muted } = extractAttributes(el, ["bold", "display", "muted"]);
        if (display === "right") {
            classNames.push("float-end");
        }
        if (display === "full") {
            classNames.push("d-block", "text-truncate");
        } else {
            classNames.push("d-inline-block");
        }
        if (bold) {
            classNames.push("fw-bold");
        }
        if (muted) {
            classNames.push("text-muted");
        }
        if (classNames.length > 0) {
            const clsFormatted = el.hasAttribute("widget")
                ? toStringExpression(classNames.join(" "))
                : classNames.join(" ");
            compiled.setAttribute("class", clsFormatted);
        }

        const attrs = {};
        for (const attr of el.attributes) {
            attrs[attr.name] = attr.value;
        }

        if (el.hasAttribute("widget")) {
            const attrsParts = Object.entries(attrs).map(([key, value]) => {
                if (key.startsWith("t-attf-")) {
                    key = key.slice(7);
                    value = toInterpolatedStringExpression(value);
                } else if (key.startsWith("t-att-")) {
                    key = key.slice(6);
                    value = `"" + (${value})`;
                } else if (key.startsWith("t-att")) {
                    throw new Error("t-att on <field> nodes is not supported");
                } else if (!key.startsWith("t-")) {
                    value = toStringExpression(value);
                }
                return `'${key}':${value}`;
            });
            compiled.setAttribute("attrs", `{${attrsParts.join(",")}}`);
        }

        for (const attr in attrs) {
            if (attr.startsWith("t-") && !attr.startsWith("t-att")) {
                compiled.setAttribute(attr, attrs[attr]);
            }
        }

        return compiled;
    }
}

ActivityCompiler.OWL_DIRECTIVE_WHITELIST = [
    ...ViewCompiler.OWL_DIRECTIVE_WHITELIST,
    "t-name",
    "t-esc",
    "t-out",
    "t-set",
    "t-value",
    "t-if",
    "t-else",
    "t-elif",
    "t-foreach",
    "t-as",
    "t-key",
    "t-att.*",
    "t-call",
    "t-translation",
];

return __exports;
});
;

/*************************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_controller.js  *
*  Lines: 148                                                            *
*************************************************************************/
odoo.define('@mail/views/web/activity/activity_controller', ['@web/core/l10n/translation', '@odoo/owl', '@web/core/utils/hooks', '@web/model/model', '@web/model/relational_model/utils', '@web/search/cog_menu/cog_menu', '@web/search/layout', '@web/search/search_bar/search_bar', '@web/search/pager_hook', '@web/views/standard_view_props', '@web/views/view_dialogs/select_create_dialog'], function (require) {
'use strict';
let __exports = {};
const { _t } = require("@web/core/l10n/translation");

const { Component, useState } = require("@odoo/owl");

const { useService } = require("@web/core/utils/hooks");
const { useModel } = require("@web/model/model");
const { extractFieldsFromArchInfo } = require("@web/model/relational_model/utils");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");
const { Layout } = require("@web/search/layout");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { usePager } = require("@web/search/pager_hook");
const { standardViewProps } = require("@web/views/standard_view_props");
const { SelectCreateDialog } = require("@web/views/view_dialogs/select_create_dialog");

const ActivityController = __exports.ActivityController = class ActivityController extends Component {
    static components = { Layout, SearchBar, CogMenu };
    static props = {
        ...standardViewProps,
        Model: Function,
        Renderer: Function,
        archInfo: Object,
    };
    static template = "mail.ActivityController";

    setup() {
        this.model = useState(useModel(this.props.Model, this.modelParams));

        this.dialog = useService("dialog");
        this.action = useService("action");
        this.store = useService("mail.store");
        this.ui = useState(useService("ui"));
        usePager(() => {
            const { count, hasLimitedCount, limit, offset } = this.model.root;
            return {
                offset: offset,
                limit: limit,
                total: count,
                onUpdate: async (params) => {
                    // Ensure that only (active) records with at least one activity, "done" (archived) or not, are fetched.
                    // We don't use active_test=false in the context because otherwise we would also get archived records.
                    params.domain = [...(this.model.originalDomain || []), ["activity_ids.active", "in", [true, false]]];
                    await Promise.all([
                        this.model.root.load(params),
                        this.model.fetchActivityData(params),
                    ]);
                },
                updateTotal: hasLimitedCount ? () => this.model.root.fetchCount() : undefined,
            };
        });
    }

    get modelParams() {
        const { archInfo, resModel } = this.props;
        const { activeFields, fields } = extractFieldsFromArchInfo(archInfo, this.props.fields);
        return {
            config: {
                activeFields,
                resModel,
                fields,
            },
        };
    }

    getSearchProps() {
        const { comparision, context, domain, groupBy, orderBy } = this.env.searchModel;
        return { comparision, context, domain, groupBy, orderBy };
    }

    scheduleActivity() {
        this.dialog.add(SelectCreateDialog, {
            resModel: this.props.resModel,
            searchViewId: this.env.searchModel.searchViewId,
            domain: this.model.originalDomain,
            title: _t("Search: %s", this.props.archInfo.title),
            multiSelect: false,
            context: this.props.context,
            noCreate: this.props.context?.create === false,
            onSelected: async (resIds) => {
                await this.store.scheduleActivity(this.props.resModel, resIds);
            },
        }, {
            onClose: () => this.model.load(this.getSearchProps())
        });
    }

    openActivityFormView(resId, activityTypeId) {
        this.action.doAction(
            {
                type: "ir.actions.act_window",
                res_model: "mail.activity",
                views: [[false, "form"]],
                view_mode: "form",
                view_type: "form",
                res_id: false,
                target: "new",
                context: {
                    default_res_id: resId,
                    default_res_model: this.props.resModel,
                    default_activity_type_id: activityTypeId,
                },
            },
            {
                onClose: () => this.model.load(this.getSearchProps()),
            }
        );
    }

    sendMailTemplate(templateID, activityTypeID) {
        const groupedActivities = this.model.activityData.grouped_activities;
        const resIds = [];
        for (const resId in groupedActivities) {
            const activityByType = groupedActivities[resId];
            const activity = activityByType[activityTypeID];
            if (activity) {
                resIds.push(parseInt(resId));
            }
        }
        this.model.orm.call(this.props.resModel, "activity_send_mail", [resIds, templateID], {});
    }

    async openRecord(record, mode) {
        const activeIds = this.model.root.records.map((datapoint) => datapoint.resId);
        this.props.selectRecord(record.resId, { activeIds, mode });
    }

    get rendererProps() {
        return {
            activityTypes: this.model.activityData.activity_types,
            activityResIds: this.model.activityData.activity_res_ids,
            fields: this.model.root.fields,
            records: this.model.root.records,
            resModel: this.props.resModel,
            archInfo: this.props.archInfo,
            groupedActivities: this.model.activityData.grouped_activities,
            scheduleActivity: this.scheduleActivity.bind(this),
            onReloadData: () => this.model.load(this.getSearchProps()),
            onEmptyCell: this.openActivityFormView.bind(this),
            onSendMailTemplate: this.sendMailTemplate.bind(this),
            openRecord: this.openRecord.bind(this),
        };
    }
}

return __exports;
});
;

/********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_model.js  *
*  Lines: 32                                                        *
********************************************************************/
odoo.define('@mail/views/web/activity/activity_model', ['@web/model/relational_model/relational_model'], function (require) {
'use strict';
let __exports = {};
const { RelationalModel } = require("@web/model/relational_model/relational_model");

const ActivityModel = __exports.ActivityModel = class ActivityModel extends RelationalModel {
    static DEFAULT_LIMIT = 100;

    async load(params = {}) {
        this.originalDomain = params.domain ? [...params.domain] : [];
        // Ensure that only (active) records with at least one activity, "done" (archived) or not, are fetched.
        // We don't use active_test=false in the context because otherwise we would also get archived records.
        params.domain = [...(params.domain || []), ["activity_ids.active", "in", [true, false]]];
        if (params && "groupBy" in params) {
            params.groupBy = [];
        }
        await Promise.all([this.fetchActivityData(params), super.load(params)]);
    }

    async fetchActivityData(params) {
        this.activityData = await this.orm.call("mail.activity", "get_activity_data", [], {
            res_model: this.config.resModel,
            domain: params.domain || this.env.searchModel._domain,
            limit: params.limit || this.initialLimit,
            offset: params.offset || 0,
            fetch_done: true,
        });
    }
}

return __exports;
});
;

/*********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_record.js  *
*  Lines: 52                                                         *
*********************************************************************/
odoo.define('@mail/views/web/activity/activity_record', ['@mail/views/web/activity/activity_compiler', '@odoo/owl', '@web/core/py_js/py', '@web/core/user', '@web/core/utils/html', '@web/views/fields/field', '@web/views/kanban/kanban_record', '@web/views/view_compiler'], function (require) {
'use strict';
let __exports = {};
const { ActivityCompiler } = require("@mail/views/web/activity/activity_compiler");

const { Component } = require("@odoo/owl");

const { evaluateBooleanExpr } = require("@web/core/py_js/py");
const { user } = require("@web/core/user");
const { isHtmlEmpty } = require("@web/core/utils/html");
const { Field } = require("@web/views/fields/field");
const { getFormattedRecord, getImageSrcFromRecordInfo } = require("@web/views/kanban/kanban_record");
const { useViewCompiler } = require("@web/views/view_compiler");

const ActivityRecord = __exports.ActivityRecord = class ActivityRecord extends Component {
    static components = {
        Field,
    };
    static props = {
        archInfo: { type: Object },
        openRecord: { type: Function },
        record: { type: Object },
    };
    static template = "mail.ActivityRecord";

    setup() {
        this.evaluateBooleanExpr = evaluateBooleanExpr;
        this.widget = {
            deletable: false,
            editable: false,
            isHtmlEmpty,
        };
        const { templateDocs } = this.props.archInfo;
        const templates = useViewCompiler(ActivityCompiler, templateDocs);
        this.recordTemplate = templates["activity-box"];
    }

    getRenderingContext() {
        const { record } = this.props;
        return {
            record: getFormattedRecord(record),
            activity_image: (...args) => getImageSrcFromRecordInfo(record, ...args),
            user_context: user.context,
            widget: this.widget,
            luxon,
            __comp__: Object.assign(Object.create(this), { this: this }),
        };
    }
}

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_renderer.js  *
*  Lines: 199                                                          *
***********************************************************************/
odoo.define('@mail/views/web/activity/activity_renderer', ['@mail/core/web/mail_column_progress', '@mail/views/web/activity/activity_cell', '@mail/views/web/activity/activity_record', '@odoo/owl', '@web/core/browser/browser', '@web/core/checkbox/checkbox', '@web/core/dropdown/dropdown', '@web/core/dropdown/dropdown_item', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
const { MailColumnProgress } = require("@mail/core/web/mail_column_progress");
const { ActivityCell } = require("@mail/views/web/activity/activity_cell");
const { ActivityRecord } = require("@mail/views/web/activity/activity_record");

const { Component, useState } = require("@odoo/owl");

const { browser } = require("@web/core/browser/browser");
const { CheckBox } = require("@web/core/checkbox/checkbox");
const { Dropdown } = require("@web/core/dropdown/dropdown");
const { DropdownItem } = require("@web/core/dropdown/dropdown_item");
const { _t } = require("@web/core/l10n/translation");

const ActivityRenderer = __exports.ActivityRenderer = class ActivityRenderer extends Component {
    static components = {
        ActivityCell,
        ActivityRecord,
        ColumnProgress: MailColumnProgress,
        Dropdown,
        DropdownItem,
        CheckBox,
    };
    static props = {
        activityTypes: { type: Object },
        activityResIds: { type: Array },
        fields: { type: Object },
        resModel: { type: String },
        records: { type: Array },
        archInfo: { type: Object },
        groupedActivities: { type: Object },
        scheduleActivity: { type: Function },
        onReloadData: { type: Function },
        onEmptyCell: { type: Function },
        onSendMailTemplate: { type: Function },
        openRecord: { type: Function },
    };
    static template = "mail.ActivityRenderer";

    setup() {
        this.activeFilter = useState({
            progressValue: {
                active: null,
            },
            activityTypeId: null,
            resIds: new Set(Object.keys(this.props.groupedActivities)),
        });

        this.storageKey = ["activity_columns", this.props.resModel, this.env.config.viewId];
        this.setupStorageActiveColumns();
    }

    getGroupInfo(activityType) {
        const types = {
            done: {
                color: "secondary",
                inProgressBar: false,
                label: _t("done"), // activity_mixin.activity_state has no done state, so we add it manually here
                value: 0,
            },
            planned: {
                color: "success",
                inProgressBar: true,
                value: 0,
            },
            today: {
                color: "warning",
                inProgressBar: true,
                value: 0,
            },
            overdue: {
                color: "danger",
                inProgressBar: true,
                value: 0,
            },
        };
        for (const [type, label] of this.props.fields.activity_state.selection) {
            types[type].label = label;
        }
        const typeId = activityType.id;
        const isColumnFiltered = this.activeFilter.activityTypeId === activityType.id;
        const progressValue = isColumnFiltered ? this.activeFilter.progressValue : { active: null };

        let totalCountWithoutDone = 0;
        for (const activities of Object.values(this.props.groupedActivities)) {
            if (typeId in activities) {
                for (const [state, stateCount] of Object.entries(
                    activities[typeId].count_by_state
                )) {
                    types[state].value += stateCount;
                    if (state !== "done") {
                        totalCountWithoutDone += stateCount;
                    }
                }
            }
        }

        const progressBar = {
            bars: [],
            activeBar: isColumnFiltered ? this.activeFilter.progressValue.active : null,
        };
        for (const [value, count] of Object.entries(types)) {
            if (count.inProgressBar) {
                progressBar.bars.push({
                    count: count.value,
                    value,
                    string: types[value].label,
                    color: count.color,
                });
            }
        }

        const ongoingActivityCount = types.overdue.value + types.today.value + types.planned.value;
        const ongoingAndDoneCount = ongoingActivityCount + types.done.value;
        const labelAggregate = `${types.overdue.label} + ${types.today.label} + ${types.planned.label}`;
        const aggregateOn =
            ongoingAndDoneCount && this.isTypeDisplayDone(typeId)
                ? {
                      title: `${types.done.label} + ${labelAggregate}`,
                      value: ongoingAndDoneCount,
                  }
                : undefined;
        return {
            aggregate: {
                title: labelAggregate,
                value: isColumnFiltered ? types[progressValue.active].value : ongoingActivityCount,
            },
            aggregateOn: aggregateOn,
            data: {
                count: totalCountWithoutDone,
                filterProgressValue: (name) => this.onSetProgressBarState(typeId, name),
                progressBar,
                progressValue,
            },
        };
    }

    getRecord(resId) {
        return this.props.records.find((r) => r.resId === resId);
    }

    isTypeDisplayDone(typeId) {
        return this.props.activityTypes.find((a) => a.id === typeId).keep_done;
    }

    onSetProgressBarState(typeId, bar) {
        const name = bar.value;
        if (this.activeFilter.progressValue.active === name) {
            this.activeFilter.progressValue.active = null;
            this.activeFilter.activityTypeId = null;
            this.activeFilter.resIds = new Set(Object.keys(this.props.groupedActivities));
        } else {
            this.activeFilter.progressValue.active = name;
            this.activeFilter.activityTypeId = typeId;
            this.activeFilter.resIds = new Set(
                Object.entries(this.props.groupedActivities)
                    .filter(
                        ([, resIds]) => typeId in resIds && name in resIds[typeId].count_by_state
                    )
                    .map(([key]) => parseInt(key))
            );
        }
    }

    get activeColumns() {
        return this.props.activityTypes.filter(
            (activityType) => this.storageActiveColumns[activityType.id]
        );
    }

    setupStorageActiveColumns() {
        const storageActiveColumnsList = browser.localStorage.getItem(this.storageKey)?.split(",");

        this.storageActiveColumns = useState({});
        for (const activityType of this.props.activityTypes) {
            if (storageActiveColumnsList) {
                this.storageActiveColumns[activityType.id] = storageActiveColumnsList.includes(
                    activityType.id.toString()
                );
            } else {
                this.storageActiveColumns[activityType.id] = true;
            }
        }
    }

    toggleDisplayColumn(typeId) {
        this.storageActiveColumns[typeId] = !this.storageActiveColumns[typeId];
        browser.localStorage.setItem(
            this.storageKey.join(","),
            Object.keys(this.storageActiveColumns).filter(
                (activityType) => this.storageActiveColumns[activityType]
            )
        );
    }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /mail/static/src/views/web/activity/activity_view.js  *
*  Lines: 32                                                       *
*******************************************************************/
odoo.define('@mail/views/web/activity/activity_view', ['@mail/views/web/activity/activity_arch_parser', '@mail/views/web/activity/activity_controller', '@mail/views/web/activity/activity_model', '@mail/views/web/activity/activity_renderer', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { ActivityArchParser } = require("@mail/views/web/activity/activity_arch_parser");
const { ActivityController } = require("@mail/views/web/activity/activity_controller");
const { ActivityModel } = require("@mail/views/web/activity/activity_model");
const { ActivityRenderer } = require("@mail/views/web/activity/activity_renderer");

const { registry } = require("@web/core/registry");

const activityView = __exports.activityView = {
    type: "activity",
    searchMenuTypes: ["filter", "favorite"],
    Controller: ActivityController,
    Renderer: ActivityRenderer,
    ArchParser: ActivityArchParser,
    Model: ActivityModel,
    props: (genericProps, view) => {
        const { arch, relatedModels, resModel } = genericProps;
        const archInfo = new view.ArchParser().parse(arch, relatedModels, resModel);
        return {
            ...genericProps,
            archInfo,
            Model: view.Model,
            Renderer: view.Renderer,
        };
    },
};
registry.category("views").add("activity", activityView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /crm/static/src/views/forecast_graph/forecast_graph_view.js  *
*  Lines: 18                                                              *
**************************************************************************/
odoo.define('@crm/views/forecast_graph/forecast_graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@crm/views/forecast_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { ForecastSearchModel } = require("@crm/views/forecast_search_model");

const forecastGraphView = __exports.forecastGraphView = {
    ...graphView,
    SearchModel: ForecastSearchModel,
};

registry.category("views").add("forecast_graph", forecastGraphView);

return __exports;
});
;

/**************************************************************************
*  Filepath: /crm/static/src/views/forecast_pivot/forecast_pivot_view.js  *
*  Lines: 18                                                              *
**************************************************************************/
odoo.define('@crm/views/forecast_pivot/forecast_pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@crm/views/forecast_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { ForecastSearchModel } = require("@crm/views/forecast_search_model");

const forecastPivotView = __exports.forecastPivotView = {
    ...pivotView,
    SearchModel: ForecastSearchModel,
};

registry.category("views").add("forecast_pivot", forecastPivotView);

return __exports;
});
;

/*************************************************************
*  Filepath: /analytic/static/src/views/graph/graph_view.js  *
*  Lines: 16                                                 *
*************************************************************/
odoo.define('@analytic/views/graph/graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@analytic/views/analytic_search_model'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { AnalyticSearchModel } = require("@analytic/views/analytic_search_model");

const analyticGraphView = __exports.analyticGraphView = {
    ...graphView,
    SearchModel: AnalyticSearchModel,
};

registry.category("views").add("analytic_graph", analyticGraphView);

return __exports;
});
;

/*****************************************************************
*  Filepath: /analytic/static/src/views/pivot/pivot_renderer.js  *
*  Lines: 27                                                     *
*****************************************************************/
odoo.define('@analytic/views/pivot/pivot_renderer', ['@web/views/pivot/pivot_renderer'], function (require) {
'use strict';
let __exports = {};
const { PivotRenderer } = require("@web/views/pivot/pivot_renderer");


const AnalyticPivotRenderer = __exports.AnalyticPivotRenderer = class AnalyticPivotRenderer extends PivotRenderer {

    /*
     * Override to avoid using incomplete groupByItems
     */
    onGroupBySelected(type, payload) {
        if (typeof(payload.optionId) === "number") {
            let searchItems = this.env.searchModel.getSearchItems(
                (searchItem) =>
                    ["groupBy", "dateGroupBy"].includes(searchItem.type) && !searchItem.custom
            )
            searchItems = [...searchItems, ...searchItems.flatMap((f) => f.options).filter((f) => typeof(f?.id) === "number")]
            const { fieldName } = searchItems.find(({ id }) => id === payload.optionId);
            payload.fieldName = fieldName;
        }
        super.onGroupBySelected(type, payload);
    }
}

return __exports;
});
;

/*************************************************************
*  Filepath: /analytic/static/src/views/pivot/pivot_view.js  *
*  Lines: 18                                                 *
*************************************************************/
odoo.define('@analytic/views/pivot/pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@analytic/views/analytic_search_model', '@analytic/views/pivot/pivot_renderer'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { AnalyticSearchModel } = require("@analytic/views/analytic_search_model");
const { AnalyticPivotRenderer } = require("@analytic/views/pivot/pivot_renderer");

const analyticPivotView = __exports.analyticPivotView = {
    ...pivotView,
    Renderer: AnalyticPivotRenderer,
    SearchModel: AnalyticSearchModel,
};

registry.category("views").add("analytic_pivot", analyticPivotView);

return __exports;
});
;

/***************************************************************************************
*  Filepath: /project/static/src/views/project_task_graph/project_task_graph_model.js  *
*  Lines: 19                                                                           *
***************************************************************************************/
odoo.define('@project/views/project_task_graph/project_task_graph_model', ['@web/views/graph/graph_model', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { GraphModel } = require("@web/views/graph/graph_model");
const { _t } = require("@web/core/l10n/translation");

const ProjectTaskGraphModel = __exports.ProjectTaskGraphModel = class ProjectTaskGraphModel extends GraphModel {
    _getDefaultFilterLabel(field) {
        if (field.fieldName === "project_id") {
            return _t("🔒 Private");
        }
        return super._getDefaultFilterLabel(field);
    }
}

return __exports;
});
;

/**************************************************************************************
*  Filepath: /project/static/src/views/project_task_graph/project_task_graph_view.js  *
*  Lines: 20                                                                          *
**************************************************************************************/
odoo.define('@project/views/project_task_graph/project_task_graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@project/views/project_task_graph/project_task_graph_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { ProjectTaskGraphModel } = require("@project/views/project_task_graph/project_task_graph_model");

const viewRegistry = registry.category("views");

const projectTaskGraphView = __exports.projectTaskGraphView = {
    ...graphView,
    Model: ProjectTaskGraphModel,
};

viewRegistry.add("project_task_graph", projectTaskGraphView);

return __exports;
});
;

/**********************************************************************************
*  Filepath: /project/static/src/views/project_task_pivot/project_pivot_model.js  *
*  Lines: 25                                                                      *
**********************************************************************************/
odoo.define('@project/views/project_task_pivot/project_pivot_model', ['@web/core/l10n/translation', '@web/views/pivot/pivot_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { PivotModel } = require("@web/views/pivot/pivot_model");

const ProjectTaskPivotModel = __exports.ProjectTaskPivotModel = class ProjectTaskPivotModel extends PivotModel {
    /**
     * @override
     */
    _getEmptyGroupLabel(fieldName) {
        if (fieldName === "project_id") {
            return _t("Private");
        } else if (fieldName === "user_ids") {
            return _t("Unassigned");
        } else {
            return super._getEmptyGroupLabel(fieldName);
        }
    }
}

return __exports;
});
;

/*********************************************************************************
*  Filepath: /project/static/src/views/project_task_pivot/project_pivot_view.js  *
*  Lines: 18                                                                     *
*********************************************************************************/
odoo.define('@project/views/project_task_pivot/project_pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@project/views/project_task_pivot/project_pivot_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { ProjectTaskPivotModel } = require("@project/views/project_task_pivot/project_pivot_model");

const projectPivotView = __exports.projectPivotView = {
    ...pivotView,
    Model: ProjectTaskPivotModel,
};

registry.category("views").add("project_pivot", projectPivotView);

return __exports;
});
;

/*******************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_model.js  *
*  Lines: 92                                                                   *
*******************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_model', ['@web/core/l10n/translation', '@web/views/graph/graph_model', '@web/core/utils/arrays'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { GraphModel } = require("@web/views/graph/graph_model");
const { sortBy } = require("@web/core/utils/arrays");

const BurndownChartModel = __exports.BurndownChartModel = class BurndownChartModel extends GraphModel {
    /**
     * @override
     */
    setup(params) {
        super.setup(params);
        this.stageSeqAndNamePerId = {};
    }

    /**
     * Fetch the sequence of each stage in the project. This function alters this.stageSeqAndNamePerId
     * @protected
     * @param {Object} context
     */
    async _fetchStageInfo(context) {
        const searchDomain =
            !context.active_id || !context.default_project_id
                ? []
                : [["project_ids", "in", context.active_id]];
        const data = await this.orm.webSearchRead("project.task.type", searchDomain, {
            specification: {
                name: {},
                sequence: {},
            },
        });
        const stageSeqAndNamePerId = {};
        for (const { id, name, sequence } of data.records) {
            stageSeqAndNamePerId[id] = { name, sequence };
        }
        return stageSeqAndNamePerId;
    }

    /**
     * @param {SearchParams} searchParams
     */
    async load(searchParams) {
        const { context, groupBy } = searchParams;

        if (groupBy.includes("stage_id")) {
            if (context.stage_name_and_sequence_per_id && context.default_project_id) {
                this.stageSeqAndNamePerId = context.stage_name_and_sequence_per_id;
            } else {
                // if the stage_name_and_sequence_per_id wasn't given by the action (for example if the page is simply reloaded)
                this.stageSeqAndNamePerId = await this._fetchStageInfo(context);
            }
        } else {
            this.stageSeqAndNamePerId = {};
        }
        await super.load(searchParams);
    }

    /**
     * @override
     */
    _prepareData() {
        super._prepareData();
        const { groupBy } = this.searchParams;
        const { mode } = this.metaData;
        if (mode === "line" && groupBy.includes("stage_id")) {
            this.data.datasets = sortBy(this.data.datasets, (dataSet) => {
                const firstIdentifier = [...dataSet.identifiers][0];
                const group = Object.assign(...JSON.parse(firstIdentifier));
                const val = group.stage_id;
                if (Array.isArray(val)) {
                    return this.stageSeqAndNamePerId[val[0]]?.sequence || -1;
                }
                return -1;
            });
        }
    }

    /**
     * @protected
     * @override
     */
    async _loadDataPoints(metaData) {
        metaData.measures.__count.string = _t("# of Tasks");
        return super._loadDataPoints(metaData);
    }
}

return __exports;
});
;

/**************************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_search_model.js  *
*  Lines: 156                                                                         *
**************************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_search_model', ['@web/core/l10n/translation', '@web/core/utils/hooks', '@web/search/search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { useService } = require("@web/core/utils/hooks");
const { SearchModel } = require("@web/search/search_model");


const BurndownChartSearchModel = __exports.BurndownChartSearchModel = class BurndownChartSearchModel extends SearchModel {

    /**
     * @override
     */
    setup(services) {
        this.notificationService = useService("notification");
        super.setup(...arguments);
    }

    /**
     * @override
     */
    async load(config) {
        await super.load(...arguments);
        // Store date and stage_id searchItemId in the SearchModel for reuse in other functions.
        for (const searchItem of Object.values(this.searchItems)) {
            if (['dateGroupBy', 'groupBy'].includes(searchItem.type)) {
                if (this.stageIdSearchItemId && this.dateSearchItemId && this.isClosedSearchItemId) {
                    return;
                }
                switch (searchItem.fieldName) {
                    case 'date':
                        this.dateSearchItemId = searchItem.id;
                        break;
                    case 'stage_id':
                        this.stageIdSearchItemId = searchItem.id;
                        break;
                    case 'is_closed':
                        this.isClosedSearchItemId = searchItem.id;
                        break;
                }
            }
        }
    }

    /**
     * @override
     */
    deactivateGroup(groupId) {
        // Prevent removing 'Date & Stage' and 'Date & is closed' group by from the search
        if (this.searchItems[this.dateSearchItemId].groupId == groupId) {
            if (this.query.some(queryElem => [this.stageIdSearchItemId, this.isClosedSearchItemId].includes(queryElem.searchItemId))){
                this._addGroupByNotification(_t("The report should be grouped either by \"Stage\" to represent a Burndown Chart or by \"Is Closed\" to represent a Burn-up chart. Without one of these groupings applied, the report will not provide relevant information."));
            }
            return;
        }
        super.deactivateGroup(groupId);
    }

    /**
     * @override
     */
    toggleDateGroupBy(searchItemId, intervalId) {
        // Ensure that there is always one and only one date group by selected.
        if (searchItemId === this.dateSearchItemId) {
            let filtered_query = [];
            let triggerNotification = false;
            for (const queryElem of this.query) {
                if (queryElem.searchItemId !== searchItemId) {
                    filtered_query.push(queryElem);
                } else if (queryElem.intervalId === intervalId) {
                    triggerNotification = true;
                }
            }
            if (filtered_query.length !== this.query.length) {
                this.query = filtered_query;
                if (triggerNotification) {
                    this._addGroupByNotification(_t("The Burndown Chart must be grouped by Date"));
                }
            }
        }
        super.toggleDateGroupBy(...arguments);
    }

    /**
     * @override
     * Ensure here that there is always either the 'stage' or the 'is_closed' searchItemId inside the query.
     */
    toggleSearchItem(searchItemId) {
        // if the current searchItem stage/is_closed, the counterpart is added before removing the current searchItem
        if (searchItemId === this.isClosedSearchItemId){
            super.toggleSearchItem(this.stageIdSearchItemId);
        } else if (searchItemId === this.stageIdSearchItemId){
            super.toggleSearchItem(this.isClosedSearchItemId);
        }
        super.toggleSearchItem(...arguments);
    }

    /**
     * Adds a notification related to the group by constraint of the Burndown Chart.
     * @param body The message to display in the notification.
     * @private
     */
    _addGroupByNotification(body) {
        this.notificationService.add(
            body,
            { type: "danger" }
        );
    }

    /**
     * @override
     */
    async _notify() {
        // Ensure that we always group by date first and by stage_id/is_closed second
        let stageIdIndex = -1;
        let dateIndex = -1;
        let isClosedIndex = -1;
        for (const [index, queryElem] of this.query.entries()) {
            if (dateIndex !== -1 && (stageIdIndex !== -1 || isClosedIndex !== -1)) {
                break;
            }
            switch (queryElem.searchItemId) {
                case this.dateSearchItemId:
                    dateIndex = index;
                    break;
                case this.stageIdSearchItemId:
                    stageIdIndex = index;
                    break;
                case this.isClosedSearchItemId:
                    isClosedIndex = index;
                    break;
            }
        }
        if (isClosedIndex > 0) {
            if (isClosedIndex > dateIndex) {
                dateIndex += 1;
            }
            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);
        } else if (stageIdIndex > 0) {
            if (stageIdIndex > dateIndex) {
                dateIndex += 1;
            }
            this.query.splice(0, 0, this.query.splice(stageIdIndex, 1)[0]);
        }
        if (dateIndex > 0) {
            this.query.splice(0, 0, this.query.splice(dateIndex, 1)[0]);
        }
        await super._notify(...arguments);
    }

}

return __exports;
});
;

/******************************************************************************
*  Filepath: /project/static/src/views/burndown_chart/burndown_chart_view.js  *
*  Lines: 25                                                                  *
******************************************************************************/
odoo.define('@project/views/burndown_chart/burndown_chart_view', ['@project/views/burndown_chart/burndown_chart_model', '@web/views/graph/graph_view', '@web/core/registry', '@project/views/burndown_chart/burndown_chart_search_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { BurndownChartModel } = require("@project/views/burndown_chart/burndown_chart_model");
const { graphView } = require("@web/views/graph/graph_view");
const { registry } = require("@web/core/registry");
const { BurndownChartSearchModel } = require("@project/views/burndown_chart/burndown_chart_search_model");

const viewRegistry = registry.category("views");

const burndownChartGraphView = {
  ...graphView,
  buttonTemplate: "project.BurndownChartView.Buttons",
  hideCustomGroupBy: true,
  Model: BurndownChartModel,
  searchMenuTypes: graphView.searchMenuTypes.filter(menuType => menuType !== "comparison"),
  SearchModel: BurndownChartSearchModel,
};

viewRegistry.add("burndown_chart", burndownChartGraphView);

return __exports;
});
;

/****************************************************
*  Filepath: /hr/static/src/views/hr_graph_view.js  *
*  Lines: 21                                        *
****************************************************/
odoo.define('@hr/views/hr_graph_view', ['@web/core/registry', '@web/views/graph/graph_view', '@web/views/graph/graph_controller', '@hr/views/hr_action_helper'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { graphView } = require("@web/views/graph/graph_view");
const { GraphController } = require("@web/views/graph/graph_controller");
const { HrActionHelper } = require("@hr/views/hr_action_helper");

const HrGraphController = __exports.HrGraphController = class HrGraphController extends GraphController {
    static template = "hr.GraphView";
    static components = { ...GraphController.components, HrActionHelper };
}
const HrGraphView = __exports.HrGraphView = {
    ...graphView,
    Controller: HrGraphController,
};

registry.category("views").add("hr_graph_view", HrGraphView);

return __exports;
});
;

/****************************************************
*  Filepath: /hr/static/src/views/hr_pivot_view.js  *
*  Lines: 21                                        *
****************************************************/
odoo.define('@hr/views/hr_pivot_view', ['@web/core/registry', '@web/views/pivot/pivot_view', '@web/views/pivot/pivot_controller', '@hr/views/hr_action_helper'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { pivotView } = require("@web/views/pivot/pivot_view");
const { PivotController } = require("@web/views/pivot/pivot_controller");
const { HrActionHelper } = require("@hr/views/hr_action_helper");

const HrPivotController = __exports.HrPivotController = class HrPivotController extends PivotController {
    static template = "hr.PivotView";
    static components = { ...PivotController.components, HrActionHelper };
}
const HrPivotView = __exports.HrPivotView = {
    ...pivotView,
    Controller: HrPivotController,
};

registry.category("views").add("hr_pivot_view", HrPivotView);

return __exports;
});
;

/**********************************************************
*  Filepath: /hr_skills/static/src/views/skills_graph.js  *
*  Lines: 30                                              *
**********************************************************/
odoo.define('@hr_skills/views/skills_graph', ['@web/core/registry', '@web/views/graph/graph_renderer', '@web/views/graph/graph_view'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { GraphRenderer } = require("@web/views/graph/graph_renderer");
const { graphView } = require("@web/views/graph/graph_view");

const SkillsGraphRenderer = __exports.SkillsGraphRenderer = class SkillsGraphRenderer extends GraphRenderer {
    getScaleOptions() {
        const scaleOptions = super.getScaleOptions();

        if ('y' in scaleOptions) {
            scaleOptions.y.suggestedMax = 100;
        }

        return scaleOptions;
    }
}

const skillsGraphView = __exports.skillsGraphView = {
    ...graphView,
    Renderer: SkillsGraphRenderer,
};

registry.category("views").add("skills_graph", skillsGraphView);

return __exports;
});
;

/**************************************************************************************
*  Filepath: /hr_timesheet/static/src/views/timesheet_graph/timesheet_graph_model.js  *
*  Lines: 45                                                                          *
**************************************************************************************/
odoo.define('@hr_timesheet/views/timesheet_graph/timesheet_graph_model', ['@project/views/project_task_graph/project_task_graph_model'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { ProjectTaskGraphModel } = require("@project/views/project_task_graph/project_task_graph_model");

const FIELDS = [
    'unit_amount', 'effective_hours', 'allocated_hours', 'remaining_hours', 'total_hours_spent', 'subtask_effective_hours',
    'overtime', 'number_hours', 'difference', 'timesheet_unit_amount'
];

const hrTimesheetGraphModel = __exports.hrTimesheetGraphModel = class hrTimesheetGraphModel extends ProjectTaskGraphModel {
    /**
     * @override
     */
    setup(params, services) {
        super.setup(...arguments);
        this.companyService = services.company;
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Override processDataPoints to take into account the analytic line uom.
     * @override
     */
    _getProcessedDataPoints() {
        const currentCompany = this.companyService.currentCompany;
        const factor = currentCompany.timesheet_uom_factor || 1;
        if (factor !== 1 && FIELDS.includes(this.metaData.measure)) {
            // recalculate the Duration values according to the timesheet_uom_factor
            for (const dataPt of this.dataPoints) {
                dataPt.value *= factor;
            }
        }
        return super._getProcessedDataPoints(...arguments);
    }
}
hrTimesheetGraphModel.services = [...ProjectTaskGraphModel.services, "company"];

return __exports;
});
;

/*************************************************************************************
*  Filepath: /hr_timesheet/static/src/views/timesheet_graph/timesheet_graph_view.js  *
*  Lines: 20                                                                         *
*************************************************************************************/
odoo.define('@hr_timesheet/views/timesheet_graph/timesheet_graph_view', ['@project/views/project_task_graph/project_task_graph_view', '@hr_timesheet/views/timesheet_graph/timesheet_graph_model', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { projectTaskGraphView } = require("@project/views/project_task_graph/project_task_graph_view");
const { hrTimesheetGraphModel } = require("@hr_timesheet/views/timesheet_graph/timesheet_graph_model");
const { registry } = require("@web/core/registry");

const viewRegistry = registry.category("views");

const hrTimesheetGraphView = __exports.hrTimesheetGraphView = {
  ...projectTaskGraphView,
  Model: hrTimesheetGraphModel,
};

viewRegistry.add("hr_timesheet_graphview", hrTimesheetGraphView);

return __exports;
});
;

/*****************************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_arch_parser.js  *
*  Lines: 83                                                     *
*****************************************************************/
odoo.define('@web_hierarchy/hierarchy_arch_parser', ['@web/core/utils/xml', '@web/search/utils/order_by', '@web/views/fields/field', '@web/views/utils', '@web/core/utils/strings'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { visitXML } = require("@web/core/utils/xml");
const { stringToOrderBy } = require("@web/search/utils/order_by");
const { Field } = require("@web/views/fields/field");
const { getActiveActions } = require("@web/views/utils");
const { exprToBoolean } = require("@web/core/utils/strings");

const HierarchyArchParser = __exports.HierarchyArchParser = class HierarchyArchParser {
    parse(xmlDoc, models, modelName) {
        const archInfo = {
            activeActions: getActiveActions(xmlDoc),
            defaultOrder: stringToOrderBy(xmlDoc.getAttribute("default_order") || null),
            draggable: false,
            icon: "fa-share-alt fa-rotate-90 align-text-top",
            parentFieldName: "parent_id",
            fieldNodes: {},
            templateDocs: {},
            xmlDoc,
        };
        const fieldNextIds = {};
        const fields = models[modelName].fields;

        visitXML(xmlDoc, (node) => {
            if (node.hasAttribute("t-name")) {
                archInfo.templateDocs[node.getAttribute("t-name")] = node;
                return;
            }
            if (node.tagName === "hierarchy") {
                if (node.hasAttribute("parent_field")) {
                    const parentFieldName = node.getAttribute("parent_field");
                    if (!(parentFieldName in fields)) {
                        throw new Error(`The parent field set (${parentFieldName}) is not defined in the model (${modelName}).`);
                    } else if (fields[parentFieldName].type !== "many2one") {
                        throw new Error(`Invalid parent field, it should be a Many2One field.`);
                    } else if (fields[parentFieldName].relation !== modelName) {
                        throw new Error(`Invalid parent field, the co-model should be same model than the current one (expected: ${modelName}).`);
                    }
                    archInfo.parentFieldName = parentFieldName;
                }
                if (node.hasAttribute("child_field")) {
                    const childFieldName = node.getAttribute("child_field");
                    if (!(childFieldName in fields)) {
                        throw new Error(`The child field set (${childFieldName}) is not defined in the model (${modelName}).`);
                    } else if (fields[childFieldName].type !== "one2many") {
                        throw new Error(`Invalid child field, it should be a One2Many field.`);
                    } else if (fields[childFieldName].relation !== modelName) {
                        throw new Error(`Invalid child field, the co-model should be same model than the current one (expected: ${modelName}).`);
                    }
                    archInfo.childFieldName = childFieldName;
                }
                if (node.hasAttribute("draggable")) {
                    archInfo.draggable = exprToBoolean(node.getAttribute("draggable"));
                }
                if (node.hasAttribute("icon")) {
                    archInfo.icon = node.getAttribute("icon");
                }
            } else if (node.tagName === "field") {
                const fieldInfo = Field.parseFieldNode(node, models, modelName, "hierarchy");
                const name = fieldInfo.name;
                if (!(name in fieldNextIds)) {
                    fieldNextIds[name] = 0;
                }
                const fieldId = `${name}_${fieldNextIds[name]++}`;
                archInfo.fieldNodes[fieldId] = fieldInfo;
                node.setAttribute("field_id", fieldId);
            }
        });

        const cardDoc = archInfo.templateDocs["hierarchy-box"];
        if (!cardDoc) {
            throw new Error("Missing 'hierarchy-box' template.");
        }

        return archInfo;
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_card.js  *
*  Lines: 83                                              *
**********************************************************/
odoo.define('@web_hierarchy/hierarchy_card', ['@odoo/owl', '@web/core/py_js/py', '@web/views/fields/field', '@web/model/record', '@web/views/view_button/view_button', '@web/views/view_compiler', '@web_hierarchy/hierarchy_compiler', '@web/views/kanban/kanban_record'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component } = require("@odoo/owl");

const { evaluateBooleanExpr } = require("@web/core/py_js/py");
const { Field } = require("@web/views/fields/field");
const { Record } = require("@web/model/record");
const { ViewButton } = require("@web/views/view_button/view_button");
const { useViewCompiler } = require("@web/views/view_compiler");

const { HierarchyCompiler } = require("@web_hierarchy/hierarchy_compiler");
const { getFormattedRecord } = require("@web/views/kanban/kanban_record");

const HierarchyCard = __exports.HierarchyCard = class HierarchyCard extends Component {
    static components = {
        Record,
        Field,
        ViewButton,
    };
    static props = {
        node: Object,
        openRecord: Function,
        archInfo: Object,
        templates: Object,
        classNames: { type: String, optional: true },
    };
    static defaultProps = {
        classNames: "",
    };
    static template = "web_hierarchy.HierarchyCard";
    static Compiler = HierarchyCompiler;

    setup() {
        const { templates } = this.props;
        this.templates = useViewCompiler(this.constructor.Compiler, templates);
        this.evaluateBooleanExpr = evaluateBooleanExpr;
    }

    get classNames() {
        const classNames = [this.props.classNames];
        if (this.props.node.nodes.length) {
            classNames.push("o_hierarchy_node_unfolded");
        }
        return classNames.join(" ");
    }

    getRenderingContext(data) {
        const record = getFormattedRecord(data.record);
        return {
            context: this.props.node.context,
            JSON,
            luxon,
            record,
            __comp__: Object.assign(Object.create(this), { this: this }),
            __record__: data.record,
        };
    }

    onGlobalClick(ev) {
        if (ev.target.closest("button")) {
            return;
        }
        this.props.openRecord(this.props.node);
    }

    onClickArrowUp(ev) {
        this.props.node.fetchParentNode();
    }

    onClickArrowDown(ev) {
        if (this.props.node.nodes.length) {
            this.props.node.collapseChildNodes();
        } else {
            this.props.node.showChildNodes();
        }
    }
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_compiler.js  *
*  Lines: 51                                                  *
**************************************************************/
odoo.define('@web_hierarchy/hierarchy_compiler', ['@web/views/kanban/kanban_compiler'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { KanbanCompiler } = require("@web/views/kanban/kanban_compiler");

const HierarchyCompiler = __exports.HierarchyCompiler = class HierarchyCompiler extends KanbanCompiler {
    /**
     * @override
     * @param {Element} el
     * @param {Object} params
     * @returns {Element}
     */
    compileField(el, params) {
        const fieldName = el.getAttribute("name");
        return super.compileField(el, {
            ...(params || {}),
            recordExpr: "__record__",
            dataPointIdExpr: "__comp__.props.node.id",
            formattedValueExpr: `record['${fieldName}'].value`,
        });
    }

    compileButton(el, params) {
        return super.compileButton(el, {
            ...(params || {}),
            recordExpr: "__record__",
        });
    }

    /**
     * Allow access to the record during compilation, to properly evaluate
     * invisible on any hierarchy card nodes declared in the view.
     *
     * @override
     */
    compileNode(node, params = {}, evalInvisible = true) {
        return super.compileNode(
            node,
            {
                ...params,
                recordExpr: "__record__",
            },
            evalInvisible
        );
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_controller.js  *
*  Lines: 75                                                    *
****************************************************************/
odoo.define('@web_hierarchy/hierarchy_controller', ['@odoo/owl', '@web/core/utils/hooks', '@web/model/model', '@web/model/relational_model/utils', '@web/search/cog_menu/cog_menu', '@web/search/layout', '@web/search/search_bar/search_bar', '@web/search/search_bar/search_bar_toggler', '@web/views/standard_view_props', '@web/views/view_button/view_button_hook'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, useRef } = require("@odoo/owl");

const { useBus } = require("@web/core/utils/hooks");
const { useModel } = require("@web/model/model");
const { addFieldDependencies, extractFieldsFromArchInfo } = require("@web/model/relational_model/utils");
const { CogMenu } = require("@web/search/cog_menu/cog_menu");
const { Layout } = require("@web/search/layout");
const { SearchBar } = require("@web/search/search_bar/search_bar");
const { useSearchBarToggler } = require("@web/search/search_bar/search_bar_toggler");
const { standardViewProps } = require("@web/views/standard_view_props");
const { useViewButtons } = require("@web/views/view_button/view_button_hook");

const HierarchyController = __exports.HierarchyController = class HierarchyController extends Component {
    static components = {
        Layout,
        CogMenu,
        SearchBar,
    };
    static props = {
        ...standardViewProps,
        Model: Function,
        Renderer: Function,
        buttonTemplate: String,
        archInfo: Object,
    };
    static template = "web_hierarchy.HierarchyView";

    setup() {
        this.rootRef = useRef("root");
        const { parentFieldName, childFieldName } = this.props.archInfo;
        const { activeFields, fields } = extractFieldsFromArchInfo(this.props.archInfo, this.props.fields);
        addFieldDependencies(activeFields, fields, [{ name: parentFieldName }]);
        this.model = useModel(this.props.Model, {
            resModel: this.props.resModel,
            activeFields,
            defaultOrderBy: this.props.archInfo.defaultOrder,
            fields,
            parentFieldName,
            childFieldName,
        });
        useBus(
            this.model.bus,
            "update",
            () => {
                this.render(true);
            }
        );
        useViewButtons(this.rootRef, {
            beforeExecuteAction: this.beforeExecuteActionButton.bind(this),
            afterExecuteAction: this.afterExecuteActionButton.bind(this),
            reload: this.model.reload.bind(this.model),
        });
        this.searchBarToggler = useSearchBarToggler();
    }
    get displayNoContent() {
        return this.model.resIds.length === 0;
    }

    async openRecord(node, mode) {
        const activeIds = this.model.root.resIds;
        this.props.selectRecord(node.resId, { activeIds, mode });
    }

    async beforeExecuteActionButton(clickParams) {}

    async afterExecuteActionButton(clickParams) {}
}

return __exports;
});
;

/***********************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_model.js  *
*  Lines: 1156                                             *
***********************************************************/
odoo.define('@web_hierarchy/hierarchy_model', ['@web/core/domain', '@web/core/l10n/translation', '@web/core/utils/concurrency', '@web/model/model', '@web/search/utils/order_by'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Domain } = require("@web/core/domain");
const { _t } = require("@web/core/l10n/translation");
const { KeepLast, Mutex } = require("@web/core/utils/concurrency");
const { Model } = require("@web/model/model");
const { orderByToString } = require("@web/search/utils/order_by");

let nodeId = 0;
let forestId = 0;
let treeId = 0;

/**
 * Get the id of the given many2one field value
 *
 * @param {false | [Number, string]} value many2one value
 * @returns {false | Number} id of the many2one
 */
function getIdOfMany2oneField(value) {
    return value && value[0];
}

const HierarchyNode = __exports.HierarchyNode = class HierarchyNode {
    /**
     * Constructor of hierarchy node stored in hierarchy tree
     *
     * @param {HierarchyModel} model
     * @param {Object} config
     * @param {Object} data
     * @param {HierarchyTree} tree
     * @param {HierarchyNode} parentNode
     * @param {Boolean} populateChildNodes
     */
    constructor(model, config, data, tree, parentNode = null, populateChildNodes = true) {
        this.id = nodeId++;
        this.data = data;
        this.parentNode = parentNode;
        this.tree = tree;
        this.model = model;
        this._config = config;
        this.hidden = false;
        tree.addNode(this);
        if (populateChildNodes) {
            this.populateChildNodes();
        }
    }

    /**
     * Get ancestor node
     *
     * @returns {HierarchyNode} ancestor node
     */
    get ancestorNode() {
        return this.parentNode ? this.ancestorNode : this;
    }

    /**
     * Is leaf?
     *
     * @returns {Boolean} False if the current node has node as child nodes, otherwise True.
     */
    get isLeaf() {
        return !this.nodes.length;
    }

    /**
     * Get forest of the current node
     *
     * @returns {HierarchyForest}
     */
    get forest() {
        return this.tree.forest;
    }

    /**
     * Get the resId of current node
     *
     * @returns {Number}
     */
    get resId() {
        return this.data.id;
    }

    /**
     * Get parent field name
     *
     * @returns {String}
     */
    get parentFieldName() {
        return this.model.parentFieldName;
    }

    /**
     * Get parent res id
     *
     * @returns {Number}
     */
    get parentResId() {
        return this.parentNode?.resId || getIdOfMany2oneField(this.data[this.parentFieldName]);
    }

    /**
     * Get child node res ids
     *
     * @returns {Number[]}
     */
    get childResIds() {
        return this.nodes.length ? this.nodes.map((node) => node.resId) : this.data[this.childFieldName]?.map((d) => typeof d === "number" ? d : d.id) || [];
    }

    /**
     * Get child field name
     *
     * @returns {String}
     */
    get childFieldName() {
        return this.model.childFieldName || this.model.defaultChildFieldName;
    }

    /**
     * Has child nodes?
     *
     * @returns {Boolean}
     */
    get hasChildren() {
        return this.nodes.length > 0 || this.data[this.childFieldName]?.length > 0;
    }

    /**
     * Can show parent node
     *
     * Knows if the parent node can be fetched and displayed inside the view
     *
     * @returns {Boolean} True if the current node has a parent node but it is not yet displayed and the data of the
     *                    current node is not already displayed in another node.
     */
    get canShowParentNode() {
        return Boolean(this.parentResId)
            && !this.parentNode
            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1;
    }


    /**
     * Can show child nodes
     *
     * Knows if the child nodes can be fetched and displayed inside the view
     *
     * @returns {Boolean} True if the current node has child nodes but they are not yet displayed and the data of the
     *                    current node is not already displayed in another node.
     */
    get canShowChildNodes() {
        return this.hasChildren
            && this.nodes.length === 0
            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1;
    }

    get descendantNodes() {
        const subNodes = [];
        if (!this.isLeaf) {
            subNodes.push(...this.nodes);
            for (const node of this.nodes) {
                if (node.descendantNodes.length) {
                    subNodes.push(...node.descendantNodes);
                }
            }
        }
        return subNodes;
    }

    /**
     * Get all descendants nodes parents. If the current node has descendants,
     * it is also included in the result.
     *
     * @returns {Array} contains descendants parents in order of depth (closest
     *          to root first).
     */
    get descendantsParentNodes() {
        const descendantsParentNodes = [];
        if (!this.isLeaf) {
            descendantsParentNodes.push(this);
            this.nodes.reduce((parents, node) => {
                if (!node.isLeaf) {
                    parents.push(...node.descendantsParentNodes);
                }
                return parents;
            }, descendantsParentNodes);
        }
        return descendantsParentNodes;
    }

    /**
     * Get all descendants nodes resIds
     *
     * @returns {Number[]}
     */
    get allSubsidiaryResIds() {
        return this.descendantNodes.map((n) => n.resId);
    }

    /**
     * Populate child nodes
     *
     * Uses to create child nodes of the current one according to its data.
     */
    populateChildNodes() {
        this.nodes = [];
        const children = this.data[this.childFieldName] || [];
        if (
            children.length
            && children[0] instanceof Object
            && this.tree.forest.resIds.filter((resId) => resId === this.resId).length === 1
        ) {
            this.createChildNodes(children);
        }
    }

    /**
     * create child nodes
     *
     * @param {Object[]} childNodesData data of child nodes to generate
     */
    createChildNodes(childNodesData) {
        this.nodes = (childNodesData || this.data[this.childFieldName]).map(
            (childData) =>
                new HierarchyNode(
                    this.model,
                    this._config,
                    childData,
                    this.tree,
                    this
                )
        );
    }

    removeParentNode() {
        this.parentNode?.removeChildNode(this);
        this.parentNode = null;
        this.data[this.parentFieldName] = false;
    }

    /**
     * Fetch parent node
     */
    async fetchParentNode() {
        await this.model.fetchManager(this);
    }

    /**
     * Fetch child nodes
     */
    async showChildNodes() {
        await this.model.fetchSubordinates(this);
    }

    /**
     * Collapse child nodes
     *
     * Removes the descendant nodes of the current one and stores
     * the resIds of the child nodes in the data of the current one
     * to know it has child nodes to be able to show them again
     * when it is needed.
     */
    collapseChildNodes() {
        const childrenData = [];
        for (const childNode of this.nodes) {
            childNode.data[this.childFieldName] = childNode.childResIds;
            childrenData.push(childNode.data);
        }
        this.data[this.childFieldName] = childrenData;
        this.removeChildNodes();
        this.model.notify();
    }

    removeChildNode(node) {
        node.removeChildNodes();
        this.tree.removeNodes([node]);
        this.nodes = this.nodes.filter((n) => n.id !== node.id);
        this.data[this.childFieldName] = this.nodes.map((n) => n.data);
    }

    /**
     * Remove descendant nodes of the current one
     */
    removeChildNodes() {
        for (const childNode of this.nodes) {
            if (!childNode.isLeaf) {
                childNode.removeChildNodes();
            }
        }
        this.tree.removeNodes(this.nodes);
        this.nodes = [];
    }

    /**
     * Set parent node to the current node
     *
     * @param {HierarchyNode} node parent node to set
     */
    setParentNode(node) {
        this.parentNode = node;
        node.addChildNode(this);
        const tree = node.tree;
        if (tree.root === this) {
            tree.root = node;
        } else if (this.tree.root === this) {
            this.tree.removeRoot();
            this.setTree(node.tree);
        }
    }

    setTree(tree) {
        this.tree = tree;
        for (const childNode of this.nodes) {
            childNode.setTree(tree);
        }
    }

    /**
     * Adds child node to the current node
     *
     * @param {HierarchyNode} node child node to add
     */
    addChildNode(node) {
        this.nodes.push(node);
        this.data[this.childFieldName].push(node.data);
        this.tree.addNode(node);
    }
}

const HierarchyTree = __exports.HierarchyTree = class HierarchyTree {
    /**
     * Constructor
     *
     * @param {HierarchyModel} model
     * @param {Object} config config of the model
     * @param {Object} data root node data of the tree to create
     * @param {HierarchyForest} forest hierarchy forest containing the tree to create
     */
    constructor(model, config, data, forest) {
        this.id = treeId++;
        this.nodePerNodeId = {};
        this.forest = forest;
        if (data) {
            this.root = new HierarchyNode(model, config, data, this);
            this.forest.nodePerNodeId = {
                ...this.forest.nodePerNodeId,
                ...this.nodePerNodeId,
            };
        }
        this.model = model;
        this._config = config;
    }

    /**
     * Get node res ids inside the current tree
     *
     * @returns {Number}
     */
    get resIds() {
        return Object.values(this.nodePerNodeId).map((node) => node.resId);
    }

    /**
     * Add node inside the current tree
     *
     * @param {HierarchyNode} node node to add inside the current tree
     */
    addNode(node) {
        this.nodePerNodeId[node.id] = node;
        this.forest.addNode(node);
    }

    /**
     * Remove nodes inside the current tree
     *
     * @param {HierarchyNode} nodes nodes to remove
     */
    removeNodes(nodes) {
        const nodeIds = nodes.map((node) => node.id);
        this.nodePerNodeId = Object.fromEntries(
            Object.entries(this.nodePerNodeId)
                .filter(
                    ([nodeId,]) => !nodeIds.includes(Number(nodeId))
                )
            );
        this.forest.removeNodes(nodes);
    }

    removeRoot() {
        this.forest.removeTree(this);
    }
}

const HierarchyForest = __exports.HierarchyForest = class HierarchyForest {
    /**
     *
     * @param {HierarchyModel} model
     * @param {Object} config model config
     * @param {Object[]} data list of tree root nodes data
     */
    constructor(model, config, data) {
        this.id = forestId++;
        this.nodePerNodeId = {};
        this.trees = data.map((d) => new HierarchyTree(model, config, d, this));
        this.model = model;
        this._config = config;
    }

    /**
     * Get node res ids containing inside the current forest
     *
     * @returns {Number}
     */
    get resIds() {
        return Object.values(this.nodePerNodeId).map((node) => node.resId);
    }

    /**
     * Get root node of all trees inside the current forest
     *
     * @returns {HierarchyNode[]} root nodes
     */
    get rootNodes() {
        return this.trees.map((t) => t.root);
    }

    /**
     * Add a node inside the current forest
     *
     * @param {HierarchyNode} node node to add inside the current forest
     */
    addNode(node) {
        this.nodePerNodeId[node.id] = node;
    }

    /**
     * Removes nodes inside the current forest
     *
     * @param {HierarchyNode} nodes nodes to remove inside the current forest
     */
    removeNodes(nodes) {
        const nodeIds = nodes.map((node) => node.id);
        this.nodePerNodeId = Object.fromEntries(
            Object.entries(this.nodePerNodeId)
                .filter(
                    ([nodeId,]) => !nodeIds.includes(Number(nodeId))
                )
        );
    }

    addNewRootNode(node) {
        const tree = new HierarchyTree(this.model, this._config, null, this);
        tree.root = node;
        node.tree = tree;
        tree.addNode(node);
        for (const subNode of node.descendantNodes) {
            tree.addNode(subNode);
        }
        this.trees.push(tree);
    }

    removeTree(tree) {
        this.nodePerNodeId = Object.fromEntries(
            Object.entries(this.nodePerNodeId)
                .filter(
                    ([nodeId, ]) => !(nodeId in tree.nodePerNodeId)
                )
        );
        this.trees = this.trees.filter((t) => t.id !== tree.id);
    }
}

const HierarchyModel = __exports.HierarchyModel = class HierarchyModel extends Model {
    static services = ["notification"];

    setup(params, { notification }) {
        this.keepLast = new KeepLast();
        this.mutex = new Mutex();
        this.resModel = params.resModel;
        this.fields = params.fields;
        this.parentFieldName = params.parentFieldName;
        this.childFieldName = params.childFieldName;
        this.activeFields = params.activeFields;
        this.defaultOrderBy = params.defaultOrderBy;
        this.notification = notification;
        this.config = {
            domain: [],
            isRoot: true,
        };
    }

    /**
     * Get parent field info
     *
     * @returns {Object} parent field info
     */
    get parentField() {
        return this.fields[this.parentFieldName];
    }

    /**
     * Get res ids of all nodes displayed in the view
     *
     * @returns {Number[]} resIds of all nodes displayed in the view
     */
    get resIds() {
        return this.root?.resIds || [];
    }

    /**
     * Get default child field name when no child field name is given to the view
     *
     * @returns {String} default child field name to use
     */
    get defaultChildFieldName() {
        return "__child_ids__";
    }

    /**
     * Get default domain to use, when no domain is given in the config
     *
     * @returns {import("@web/src/core/domain").DomainListRepr} default domain
     */
    get defaultDomain() {
        return [[this.parentFieldName, "=", false]];
    }

    /**
     * Get the global domain of the view (which is the domain defined on the
     * view without applying filters).
     *
     * @returns {import("@web/src/core/domain").DomainListRepr} global domain
     */
    get globalDomain() {
        if (!this.env.searchModel?.globalDomain.length) {
            return [];
        }
        return new Domain(this.env.searchModel.globalDomain).toList(
            this.env.searchModel.domainEvalContext
        );
    }

    /**
     * Get active fields name
     *
     * @returns {String[]} active fields name
     */
    get activeFieldNames() {
        return Object.keys(this.activeFields);
    }

    /**
     * Get fields to fetch
     * @returns {String[]} fields to fetch
     */
    get fieldsToFetch() {
        const fieldsToFetch = [
            ...this.activeFieldNames,
        ];
        if (this.childFieldName) {
            fieldsToFetch.push(this.childFieldName);
        }
        return fieldsToFetch;
    }

    get context() {
        return {
            bin_size: true,
            ...(this.config.context || {}),
        };
    }

    /**
     * Load the config and data for hierarchy view
     *
     * @param {Object} params params to use to load data of hierarchy view
     */
    async load(params = {}) {
        nodeId = forestId = treeId = 0;
        const config = this._getNextConfig(this.config, params);
        const data = await this.keepLast.add(this._loadData(config));
        this.root = this._createRoot(config, data);
        this.config = config;
        this.notify();
    }

    /**
     * Reload the current view with all currently loaded records
     */
    async reload() {
        nodeId = forestId = treeId = 0;
        const data = await this.keepLast.add(this._loadData(this.config, true));
        this.root = this._createRoot(this.config, data);
        this.notify({ scrollTarget: "none" });
    }

    /**
     * @override
     * Each notify should specify a scroll target (default is to scroll to the
     * bottom).
     */
    notify(payload = { scrollTarget: "bottom" }) {
        super.notify();
        this.bus.trigger("hierarchyScrollTarget", payload);
    }

    /**
     * Fetch parent node of given node
     * @param {HierarchyNode} node node to fetch its parent node
     */
    async fetchManager(node) {
        if (this.root.trees.length > 1) { // reset the hierarchy
            const treeExpanded = this._findTreeExpanded();
            const resIdsToFetch = [node.parentResId, node.resId, ...node.allSubsidiaryResIds];
            if (treeExpanded && treeExpanded.root.id !== node.id && treeExpanded.root.parentResId === node.parentResId) {
                resIdsToFetch.push(...treeExpanded.root.allSubsidiaryResIds);
            }
            const config = {
                ...this.config,
                domain: ["|", [this.parentFieldName, "=", node.parentResId], ["id", "in", resIdsToFetch]],
            }
            const data = await this._loadData(config);
            this.root = this._createRoot(config, data);
            this.notify();
            return;
        }
        const managerData = await this.keepLast.add(this._fetchManager(node));
        if (managerData) {
            const parentNode = new HierarchyNode(this, this.config, managerData, node.tree, null, false);
            parentNode.createChildNodes();
            node.setParentNode(parentNode);
            this.notify();
        }
    }

    /**
     * Fetch child nodes of given node
     *
     * @param {HierarchyNode} node node to fetch its child nodes
     */
    async fetchSubordinates(node) {
        const childFieldName = this.childFieldName || this.defaultChildFieldName;
        const children = node.data[childFieldName];
        if (children.length) {
            const nodesToUpdate = [];
            if (!(children[0] instanceof Object)) {
                const allNodeResIds = this.root.resIds;
                const existingChildResIds = children.filter((childResId) => allNodeResIds.includes(childResId))
                if (existingChildResIds.length) { // special case with result found with the search view
                    for (const tree of this.root.trees) {
                        if (existingChildResIds.includes(tree.root.resId)) {
                            nodesToUpdate.push(tree.root);
                        }
                    }
                }
                const data = await this.keepLast.add(this._fetchSubordinates(node, existingChildResIds));
                if (data && data.length) {
                    node.data[childFieldName] = data;
                }
            }
            const nodeToCollapse = this._searchNodeToCollapse(node);
            if (nodeToCollapse && !nodesToUpdate.includes(nodeToCollapse)) {
                nodeToCollapse.collapseChildNodes();
            }
            node.populateChildNodes();
            for (const n of nodesToUpdate) {
                n.setParentNode(node);
            }
            this.notify();
        }
    }

    /**
     * Search node to collapse to be able to show the child nodes of node given in parameter
     *
     * @param {HierarchyNode} node node to show its child nodes.
     * @returns {HierarchyNode | null} node found to collapse
     */
    _searchNodeToCollapse(node) {
        const parentNode = node.parentNode;
        let nodeToCollapse = null;
        if (parentNode) {
            nodeToCollapse = parentNode.nodes.find((n) => n.nodes.length);
        } else {
            const treeExpanded = this._findTreeExpanded();
            if (treeExpanded) {
                nodeToCollapse = treeExpanded.root;
            }
        }
        return nodeToCollapse;
    }

    _findTreeExpanded() {
        return this.root.trees.find((t) => t.root.nodes.length);
    }

    /**
     * Get the next model config to use
     *
     * @param {Object} currentConfig current model config used
     * @param {Object} params new params
     * @returns {Object} new model config to use
     */
    _getNextConfig(currentConfig, params) {
        const config = Object.assign({}, currentConfig);
        config.context = "context" in params ? params.context : config.context;
        if ("domain" in params) {
            config.domain = params.domain;
            if (this.isSearchDefaultOrEmpty() && config.context.hierarchy_res_id) {
                config.domain = [["id", "=", config.context.hierarchy_res_id]];
                const globalDomain = this.globalDomain;
                if (globalDomain.length) {
                    config.domain = Domain.and([config.domain, globalDomain]);
                }
                // Just needed for the first load.
                delete config.context.hierarchy_res_id;
            }
        }

        // orderBy
        config.orderBy = "orderBy" in params ? params.orderBy : config.orderBy;
        // re-apply previous orderBy if not given (or no order)
        if (!config.orderBy.length) {
            config.orderBy = currentConfig.orderBy || [];
        }
        // apply default order if no order
        if (this.defaultOrderBy && !config.orderBy.length) {
            config.orderBy = this.defaultOrderBy;
        }
        return config;
    }

    /**
     * Evaluate if the current search query is the default one.
     *
     * @returns {boolean}
     */
    isSearchDefaultOrEmpty() {
        if (!this.env.searchModel) {
            return true;
        }
        const isDisabledOptionalSearchMenuType = (type) => {
            return (
                ["filter", "groupBy", "favorite"].includes(type) &&
                !this.env.searchModel.searchMenuTypes.has(type)
            );
        };
        const activeSearchItems = this.env.searchModel.getSearchItems(
            (item) => item.isActive && !isDisabledOptionalSearchMenuType(item.type)
        );
        if (!activeSearchItems.length) {
            return true;
        }
        const defaultSearchItems = this.env.searchModel.getSearchItems(
            (item) =>
                item.isDefault &&
                item.type !== "favorite" &&
                !isDisabledOptionalSearchMenuType(item.type)
        );
        return JSON.stringify(defaultSearchItems) === JSON.stringify(activeSearchItems);
    }

    /**
     * Load data for hierarchy view
     *
     * @param {Object} config model config
     * @param {boolean} reload all currently loaded resIds instead of using
     *        the config domain
     * @returns {Object[]} main data for hierarchy view
     */
    async _loadData(config, reload = false) {
        let onlyRoots = false;
        let domain = config.domain;
        const resIds = this.resIds;
        if (reload && resIds.length > 0) {
            domain = [["id", "in", resIds]];
        } else if (this.isSearchDefaultOrEmpty()) {
            // If the current SearchModel query is the default one
            // configured for the action or there is no search query, an
            // additional constraint is added to only display "root"
            // records (without a parent).
            onlyRoots = true;
            domain = !domain.length
                ? this.defaultDomain
                : Domain.and([this.defaultDomain, domain]).toList({});
        }
        const hierarchyRead = async () => {
            return await this.orm.call(
                this.resModel,
                "hierarchy_read",
                [
                    domain,
                    this.fieldsToFetch,
                    this.parentFieldName,
                    this.childFieldName,
                    orderByToString(config.orderBy),
                ],
                { context: this.context }
            );
        };
        let result = await hierarchyRead();
        if (!result.length && onlyRoots) {
            domain = config.domain;
            result = await hierarchyRead();
        }
        return this._formatData(result);
    }

    _formatData(data) {
        const dataStringified = JSON.stringify(data);
        const recordsPerParentId = {};
        const recordPerId = {};
        for (const record of data) {
            recordPerId[record.id] = record;
            const parentId = getIdOfMany2oneField(record[this.parentFieldName]);
            if (!(parentId.toString() in recordsPerParentId)) {
                recordsPerParentId[parentId] = [];
            }
            recordsPerParentId[parentId].push(record);
        }
        const formattedData = [];
        const recordIds = []; // to check if we have only one arborescence to display otherwise we display the data as the kanban view
        for (const [parentId, records] of Object.entries(recordsPerParentId)) {
            if (!parentId || !(parentId in recordPerId)) {
                formattedData.push(...records);
            } else {
                const parentRecord = recordPerId[parentId];
                if (recordIds.includes(parentRecord.id)) {
                    return JSON.parse(dataStringified);
                }
                const ancestorId = getIdOfMany2oneField(parentRecord[this.parentFieldName]);
                if (ancestorId in recordsPerParentId) {
                    recordIds.push(...recordsPerParentId[ancestorId].map((r) => r.id));
                }
                parentRecord[this.childFieldName || this.defaultChildFieldName] = records;
            }
        }
        if (!formattedData.length && data?.length) {
            formattedData.push(recordPerId[Object.keys(recordsPerParentId)[0]]);
        }
        return formattedData;
    }

    /**
     * Create forest
     *
     * @param {Object} config model config to use
     * @param {Object[]} data root data
     * @returns {HierarchyForest} forest hierarchy
     */
    _createRoot(config, data) {
        return new HierarchyForest(this, config, data);
    }

    /**
     * Fetch parent node and its children nodes data
     *
     * @param {HierarchyNode} node node to fetch its parent node
     * @returns {Object} the parent node data with children data inside childFieldName
     */
    async _fetchManager(node, exclude_node=true) {
        let domain = new Domain([
            "|",
                ["id", "=", node.parentResId],
                [this.parentFieldName, "=", node.parentResId],
        ]);
        if (exclude_node) {
            domain = Domain.and([
                domain,
                [["id", "!=", node.resId]],
            ])
        }
        const result = await this.orm.searchRead(
            this.resModel,
            domain.toList({}),
            this.fieldsToFetch,
            {
                context: this.context,
                order: orderByToString(this.config.orderBy),
            },
        );
        let managerData = {};
        const children = [];
        for (const data of result) {
            if (data.id === node.parentResId) {
                managerData = data;
            } else {
                children.push(data);
            }
        }
        if (!this.childFieldName) {
            if (children.length) {
                await this._fetchDescendants(children);
            }
        }
        managerData[this.childFieldName || this.defaultChildFieldName] = children;
        return managerData;
    }

    /**
     * Fetch children nodes data for a given node
     *
     * @param {HierarchyNode} node node to fetch its children nodes
     * @param {Array<number> | null} excludeResIds list of ids to exclude (because the nodes already exist)
     * @returns {Object[]} list of child node data
     */
    async _fetchSubordinates(node, excludeResIds = null) {
        let childrenResIds = node.data[this.childFieldName || this.defaultChildFieldName];
        if (excludeResIds) {
            childrenResIds = childrenResIds.filter((childResId) => !excludeResIds.includes(childResId));
        }
        const data = await this.orm.searchRead(
            this.resModel,
            [["id", "in", childrenResIds]],
            this.fieldsToFetch,
            {
                context: this.context,
                order: orderByToString(this.config.orderBy),
            },
        )
        if (!this.childFieldName) {
            await this._fetchDescendants(data);
        }
        return data;
    }

    /**
     * fetch descendants nodes resIds to know if the child nodes have descendants
     *
     * @param {Object[]} childrenData child nodes data to fetch its descendants
     */
    async _fetchDescendants(childrenData) {
        const resIds = childrenData.map((d) => d.id);
        if (resIds.length) {
            const fetchChildren = await this.orm.readGroup(
                this.resModel,
                [[this.parentFieldName, "in", resIds]],
                ['id:array_agg'],
                [this.parentFieldName],
                {
                    context: this.context || {},
                    orderby: orderByToString(this.config.orderBy),
                },
            );
            const childIdsPerId = Object.fromEntries(
                fetchChildren.map((r) => [r[this.parentFieldName][0], r.id])
            );
            for (const d of childrenData) {
                if (d.id.toString() in childIdsPerId) {
                    d[this.defaultChildFieldName] = childIdsPerId[d.id.toString()];
                }
            }
        }
    }

    /**
     * ORM call to update the parentId of a record during @see updateParentNode
     * Can be overridden to not use "write".
     *
     * @param {HierarchyNode} node node related to the record which parentId
     *        should be changed
     * @param {Number} parentResId id of the new parent record
     */
    async updateParentId(node, parentResId = false) {
        return this.orm.write(
            this.resModel,
            [node.resId],
            { [this.parentFieldName]: parentResId },
            { context: this.context }
        );
    }

    /**
     * @param {Number} nodeId of the node to update
     * @param {Object} parentInfo
     * @param {Number} [parentInfo.parentNodeId] nodeId of the parent
     * @param {Number | false} [parentInfo.parentResId] resId of the parent
     * @returns {Promise}
     */
    async updateParentNode(nodeId, { parentNodeId, parentResId }) {
        const node = this.root.nodePerNodeId[nodeId];
        const resId = node.resId;
        // Validation.
        if (!node) {
            return;
        }
        const parentNode = parentNodeId ? this.root.nodePerNodeId[parentNodeId] : null;
        parentResId = parentResId || parentNode?.resId || false;
        const oldParentNode = node.parentNode;
        if (
            (parentNode && !this.validateUpdateParentNode(node, parentNode)) ||
            parentNode?.resId === oldParentNode?.resId
        ) {
            return;
        }
        // Hide the node while waiting for the server response.
        node.hidden = true;
        this.notify({ scrollTarget: "none" });
        // Update the parent server side.
        await this.mutex.exec(async () => {
            try {
                await this.updateParentId(node, parentResId);
            } catch (error) {
                // Show the node again since the operation failed, don't update the view.
                node.hidden = false;
                this.notify({ scrollTarget: "none" });
                throw error;
            }
        });
        // Reload impacted records.
        const domain = this.computeUpdateParentNodeDomain(node, parentResId, parentNode);
        const data = await this.orm.searchRead(this.resModel, domain, this.fieldsToFetch, {
            context: this.context,
            order: orderByToString(this.config.orderBy),
        });
        const formattedData = this._formatData(data);
        // Validate that data coming from the server is still compatible with the current
        // configuration of the hierarchy.
        for (const record of formattedData) {
            if (getIdOfMany2oneField(record[this.parentFieldName]) !== parentResId) {
                node.hidden = false;
                this.notify({ scrollTarget: "none" });
                this.notification.add(
                    _t(
                        `The parent of "%s" was successfully updated. Reloading records to account for other changes.`,
                        node.data.display_name || node.data.name
                    ),
                    { type: "success" }
                );
                return this.reload();
            }
        }
        // Handle the expanded tree.
        let nodeToCollapse;
        const treeExpanded = this._findTreeExpanded();
        const expandedParentNodeIds =
            treeExpanded?.root.descendantsParentNodes.map((node) => node.id) || [];
        if (!node.isLeaf || !expandedParentNodeIds.includes(parentNode?.id)) {
            // Handle cases where the expanded tree will be altered.
            // If node is not a leaf, the new expanded tree will contain its descendants.
            // If parentNode is not a parent in the current expanded tree, it will become one
            // in the new expanded tree.
            // Compute the depth of the parent of parentNode. That node is guaranteed to be a
            // parent in the current expanded tree.
            const depth = expandedParentNodeIds.findIndex(
                (id) => id === parentNode?.parentNode?.id
            );
            if (depth === -1) {
                // Drop as root or drop as the child of a root that is not part of the current
                // expanded tree. The current expanded tree should be fully closed.
                nodeToCollapse = treeExpanded?.root;
            } else {
                // Drop anywhere else (at a position that can be related to the expanded tree with
                // the depth of the parent of parentNode). In that case the existing hierarchy is
                // split at the depth of the parent, and will be completed by node's remaining
                // expanded tree.
                const nodeIdToCollapse = expandedParentNodeIds.at(depth + 1);
                if (nodeIdToCollapse) {
                    nodeToCollapse = treeExpanded?.nodePerNodeId[nodeIdToCollapse];
                }
            }
        } else {
            // Handle cases where node is a leaf dropped in the current expanded tree. In that case,
            // the tree is kept open.
            // Descendants of parentNode will always be reloaded to account for changes caused by
            // the drop operation.
            nodeToCollapse = parentNode;
        }
        // Update the view.
        if (oldParentNode) {
            oldParentNode.removeChildNode(node);
        } else {
            node.tree.removeNodes([node]);
        }
        nodeToCollapse?.collapseChildNodes();
        if (!parentNode) {
            // Drop as root, reset the hierarchy.
            nodeId = forestId = treeId = 0;
            this.root = this._createRoot(this.config, formattedData);
        } else {
            // Update parentNode data.
            parentNode.data[this.childFieldName || this.defaultChildFieldName] = formattedData;
            parentNode.populateChildNodes();
        }
        const newNodeId = Object.keys(this.root.nodePerNodeId).find((key) => {
            return this.root.nodePerNodeId[key].resId === resId;
        });
        this.notify({ scrollTarget: newNodeId });
    }

    validateUpdateParentNode(node, parentNode) {
        if (parentNode.resId === node.resId) {
            this.notification.add(_t("The parent record cannot be the record dragged."), {
                type: "danger",
            });
            return false;
        } else if (node.allSubsidiaryResIds.includes(parentNode.resId)) {
            this.notification.add(_t("Cannot change the parent because it will cause a cyclic."), {
                type: "danger",
            });
            return false;
        }
        return true;
    }

    /**
     * Returns a domain to get a recordSet containing:
     * - node.
     * - all children under the new parent.
     * - all descendants in the final expanded tree (after the operation), which
     *   are at a depth impacted by the update @see updateParentNode (part
     *   about the expanded tree).
     *
     * @param {HierarchyNode} node that is moving
     * @param {Number | false} parentResId resId of the parent
     * @param {HierarchyNode} [parentNode] which receives node as its child
     *                        (undefined if node is dropped as a root).
     * @returns {Array} domain
     */
    computeUpdateParentNodeDomain(node, parentResId, parentNode) {
        const domainsOr = [[["id", "=", node.resId]]];
        // Include the new parent children (for ordering).
        domainsOr.push([[this.parentFieldName, "=", parentResId]]);
        if (!node.isLeaf) {
            // Include node descendants (keep that part of the expanded tree).
            const expandedTreeParentResIds = node.descendantsParentNodes.map((node) => node.resId);
            domainsOr.push([[this.parentFieldName, "in", expandedTreeParentResIds]]);
        } else if (!parentNode) {
            // Keep the current expanded tree (if any) from its root if node is a leaf dropped as a
            // root.
            const expandedTreeParentResIds = node.tree.root.descendantsParentNodes.map(
                (node) => node.resId
            );
            domainsOr.push([[this.parentFieldName, "in", expandedTreeParentResIds]]);
        } else if (!parentNode.isLeaf) {
            // Keep the current expanded tree (if any) from the target parent if node is a leaf.
            const expandedTreeParentResIds = parentNode.descendantsParentNodes.map(
                (node) => node.resId
            );
            domainsOr.push([[this.parentFieldName, "in", expandedTreeParentResIds]]);
        }
        let domain = Domain.or(domainsOr);
        const globalDomain = this.globalDomain;
        if (globalDomain.length) {
            domain = Domain.and([domain, globalDomain]);
        }
        return domain.toList({});
    }
}

return __exports;
});
;

/********************************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_node_draggable.js  *
*  Lines: 109                                                       *
********************************************************************/
odoo.define('@web_hierarchy/hierarchy_node_draggable', ['@odoo/owl', '@web/core/utils/timing', '@web/core/utils/objects', '@web/core/utils/draggable_hook_builder'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { onWillUnmount, reactive, useEffect, useExternalListener } = require("@odoo/owl");
const { useThrottleForAnimation } = require("@web/core/utils/timing");
const { pick } = require("@web/core/utils/objects");
const { makeDraggableHook } = require("@web/core/utils/draggable_hook_builder");

const hookParams = {
    name: "useHierarchyNodeDraggable",
    acceptedParams: {
        rows: [String],
    },
    defaultParams: {
        edgeScrolling: { speed: 20, threshold: 60 },
        rows: null,
    },
    onComputeParams({ ctx, params }) {
        // Row selector
        ctx.rowSelector = params.rows || null;
        if (ctx.rowSelector) {
            ctx.fullSelector = `${ctx.rowSelector} ${ctx.fullSelector}`;
        }
    },
    onDragStart(params) {
        const { ctx, addListener, callHandler } = params;

        const onElementPointerEnter = (ev) => {
            const element = ev.currentTarget;
            current.hierarchyElement = element;
            callHandler("onElementEnter", { element });
        };

        const onElementPointerLeave = (ev) => {
            const element = ev.currentTarget;
            current.hierarchyElement = null;
            callHandler("onElementLeave", { element });
        };

        const onRowPointerEnter = (ev) => {
            const row = ev.currentTarget;
            current.hierarchyRow = row;
            callHandler("onRowEnter", { row });
        };

        const onRowPointerLeave = (ev) => {
            const row = ev.currentTarget;
            current.hierarchyRow = null;
            callHandler("onRowLeave", { row });
        };

        const { ref, current, elementSelector, rowSelector } = ctx;

        for (const rowEl of ref.el.querySelectorAll(rowSelector)) {
            addListener(rowEl, "pointerenter", onRowPointerEnter);
            addListener(rowEl, "pointerleave", onRowPointerLeave);
        }

        for (const siblingEl of ref.el.querySelectorAll(elementSelector)) {
            if (siblingEl !== current.element) {
                addListener(siblingEl, "pointerenter", onElementPointerEnter);
                addListener(siblingEl, "pointerleave", onElementPointerLeave);
            }
        }

        return pick(current, "element", "row");
    },
    onDragEnd({ ctx }) {
        return pick(ctx.current, "element", "row", "hierarchyRow");
    },
    onDrop({ ctx }) {
        const { current } = ctx;
        const rowElement = current.hierarchyRow;
        const element = current.hierarchyElement;
        if ((rowElement && rowElement !== current.row) || element) {
            return {
                element: current.element,
                row: current.row,
                nextRow: rowElement && current.row !== rowElement ? rowElement : null,
                newParentNode: element,
            };
        }
    },
    onWillStartDrag({ ctx }) {
        const { current, rowSelector } = ctx;

        if (rowSelector) {
            current.row = current.element.closest(rowSelector);
        }

        return pick(current, "element", "row");
    },
};

__exports.useHierarchyNodeDraggable = useHierarchyNodeDraggable; function useHierarchyNodeDraggable(params) {
    const setupHooks = {
        addListener: useExternalListener,
        setup: useEffect,
        teardown: onWillUnmount,
        throttle: useThrottleForAnimation,
        wrapState: reactive,
    }
    return makeDraggableHook({ ...hookParams, setupHooks })(params);
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_renderer.js  *
*  Lines: 152                                                 *
**************************************************************/
odoo.define('@web_hierarchy/hierarchy_renderer', ['@odoo/owl', '@web/core/l10n/translation', '@web/core/utils/hooks', '@web/core/utils/scrolling', '@web_hierarchy/hierarchy_card', '@web_hierarchy/hierarchy_node_draggable'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { Component, useRef, onPatched } = require("@odoo/owl");

const { _t } = require("@web/core/l10n/translation");
const { useBus, useService } = require("@web/core/utils/hooks");
const { scrollTo } = require("@web/core/utils/scrolling");

const { HierarchyCard } = require("@web_hierarchy/hierarchy_card");
const { useHierarchyNodeDraggable } = require("@web_hierarchy/hierarchy_node_draggable");

const HierarchyRenderer = __exports.HierarchyRenderer = class HierarchyRenderer extends Component {
    static components = {
        HierarchyCard,
    };
    static props = {
        model: Object,
        openRecord: Function,
        archInfo: Object,
        templates: Object,
    };
    static template = "web_hierarchy.HierarchyRenderer";

    setup() {
        this.rendererRef = useRef("renderer");
        this.notification = useService("notification");
        if (this.canDragAndDropRecord) {
            useHierarchyNodeDraggable({
                ref: this.rendererRef,
                enable: this.draggable,
                elements: ".o_hierarchy_node_container",
                handle: ".o_hierarchy_node",
                rows: ".o_hierarchy_row",
                ignore: "button",
                onDragStart: ({ addClass, element }) => {
                    addClass(element, "o_hierarchy_dragged");
                    addClass(element.querySelector(".o_hierarchy_node"), "shadow");
                },
                onDragEnd: ({ removeClass, element, row, hierarchyRow }) => {
                    removeClass(element, "o_hierarchy_dragged");
                    if (row) {
                        removeClass(row, "o_hierarchy_hover");
                    }
                    if (hierarchyRow) {
                        removeClass(hierarchyRow, "o_hierarchy_hover");
                    }
                },
                onDrop: (params) => {
                    this.nodeDrop(params);
                },
                onElementEnter: ({ addClass, element }) => {
                    addClass(element, "o_hierarchy_hover");
                },
                onElementLeave: ({ removeClass, element }) => {
                    removeClass(element, "o_hierarchy_hover");
                },
                onRowEnter: ({ addClass, row }) => {
                    addClass(row, "o_hierarchy_hover");
                },
                onRowLeave: ({ removeClass, row }) => {
                    removeClass(row, "o_hierarchy_hover");
                },
            });
        }
        this.scrollTarget = "none";
        useBus(this.props.model.bus, "hierarchyScrollTarget", (ev) => {
            this.scrollTarget = ev.detail?.scrollTarget || "none";
        });
        onPatched(this.onPatched);
    }

    onPatched() {
        if (this.scrollTarget === "none") {
            return;
        }
        const row =
            this.scrollTarget === "bottom"
                ? this.rendererRef.el.querySelector(":scope .o_hierarchy_row:last-child")
                : this.rendererRef.el
                      .querySelector(
                          `:scope .o_hierarchy_node[data-node-id="${this.scrollTarget}"]`
                      )
                      ?.closest(".o_hierarchy_row");
        this.scrollTarget = "none";
        if (!row) {
            return;
        }
        scrollTo(row, { behavior: "smooth" });
    }

    get canDragAndDropRecord() {
        return this.draggable && !this.env.isSmall;
    }

    get draggable() {
        return this.props.archInfo.draggable;
    }

    get rows() {
        const rootNodes = this.props.model.root.rootNodes.filter((n) => !n.hidden);
        const rows = [{ nodes: rootNodes }];
        const processNode = (node) => {
            if (!node.isLeaf) {
                const subNodes = node.nodes.filter((n) => !n.hidden);
                rows.push({ parentNode: node, nodes: subNodes });
                for (const subNode of subNodes) {
                    processNode(subNode);
                }
            }
        };

        for (const node of this.props.model.root.rootNodes) {
            processNode(node);
        }

        return rows;
    }

    async nodeDrop({ element, row, nextRow, newParentNode }) {
        let parentNodeId, parentResId;
        if (newParentNode) {
            parentNodeId = newParentNode.dataset.nodeId;
        } else if (nextRow?.dataset.rowId !== row.dataset.rowId) {
            parentNodeId = nextRow.dataset.parentNodeId;
            if (!parentNodeId) {
                const nodes = this.rows[nextRow.dataset.rowId].nodes || [];
                if (nodes) {
                    parentNodeId = nodes[0].parentNode?.id;
                    if (!parentNodeId) {
                        parentResId = nodes[0].parentResId;
                        if (!nodes.every((node) => node.parentResId === parentResId)) {
                            this.notification.add(
                                _t("Impossible to update the parent node of the dragged node because no parent has been found."),
                                {
                                    type: "danger",
                                }
                            );
                            return;
                        }
                    }
                }
            }
        }
        await this.props.model.updateParentNode(element.dataset.nodeId, { parentResId, parentNodeId });
    }
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_hierarchy/static/src/hierarchy_view.js  *
*  Lines: 35                                              *
**********************************************************/
odoo.define('@web_hierarchy/hierarchy_view', ['@web/core/registry', '@web_hierarchy/hierarchy_arch_parser', '@web_hierarchy/hierarchy_controller', '@web_hierarchy/hierarchy_model', '@web_hierarchy/hierarchy_renderer'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { HierarchyArchParser } = require("@web_hierarchy/hierarchy_arch_parser");
const { HierarchyController } = require("@web_hierarchy/hierarchy_controller");
const { HierarchyModel } = require("@web_hierarchy/hierarchy_model");
const { HierarchyRenderer } = require("@web_hierarchy/hierarchy_renderer");

const hierarchyView = __exports.hierarchyView = {
    type: "hierarchy",
    ArchParser: HierarchyArchParser,
    Controller: HierarchyController,
    Model: HierarchyModel,
    Renderer: HierarchyRenderer,
    buttonTemplate: "web_hierarchy.HierarchyButtons",
    searchMenuTypes: ["filter"],

    props: (genericProps, view) => {
        const { ArchParser, Model, Renderer, buttonTemplate: viewButtonTemplate } = view;
        const { arch, relatedModels, resModel, buttonTemplate } = genericProps;
        return {
            ...genericProps,
            archInfo: new ArchParser().parse(arch, relatedModels, resModel),
            buttonTemplate: buttonTemplate || viewButtonTemplate,
            Model,
            Renderer,
        };
    }
}

registry.category("views").add("hierarchy", hierarchyView);

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_card.js  *
*  Lines: 13                                                                                     *
*************************************************************************************************/
odoo.define('@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_card', ['@web_hierarchy/hierarchy_card'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { HierarchyCard } = require("@web_hierarchy/hierarchy_card");

const HrEmployeeHierarchyCard = __exports.HrEmployeeHierarchyCard = class HrEmployeeHierarchyCard extends HierarchyCard {
    static template = "hr_org_chart.HrEmployeeHierarchyCard";
}

return __exports;
});
;

/*****************************************************************************************************
*  Filepath: /hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer.js  *
*  Lines: 21                                                                                         *
*****************************************************************************************************/
odoo.define('@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer', ['@mail/views/web/fields/avatar/avatar', '@web_hierarchy/hierarchy_renderer', '@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_card'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Avatar } = require("@mail/views/web/fields/avatar/avatar");

const { HierarchyRenderer } = require("@web_hierarchy/hierarchy_renderer");
const { HrEmployeeHierarchyCard } = require("@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_card");

const HrEmployeeHierarchyRenderer = __exports.HrEmployeeHierarchyRenderer = class HrEmployeeHierarchyRenderer extends HierarchyRenderer {
    static template = "hr_org_chart.HrEmployeeHierarchyRenderer";
    static components = {
        ...HierarchyRenderer.components,
        HierarchyCard: HrEmployeeHierarchyCard,
        Avatar,
    };
}

return __exports;
});
;

/*************************************************************************************************
*  Filepath: /hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_view.js  *
*  Lines: 26                                                                                     *
*************************************************************************************************/
odoo.define('@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_view', ['@web/core/registry', '@web_hierarchy/hierarchy_view', '@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer', '@web_hierarchy/hierarchy_controller', '@hr/views/hr_action_helper'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { hierarchyView } = require("@web_hierarchy/hierarchy_view");
const { HrEmployeeHierarchyRenderer } = require("@hr_org_chart/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer");
const { HierarchyController } = require("@web_hierarchy/hierarchy_controller");
const { HrActionHelper } = require("@hr/views/hr_action_helper");

const HrEmployeeHierarchyController = __exports.HrEmployeeHierarchyController = class HrEmployeeHierarchyController extends HierarchyController {
    static template = "hr_org_chart.HierarchyView";
    static components = { ...HierarchyController.components, HrActionHelper };
}

const hrEmployeeHierarchyView = __exports.hrEmployeeHierarchyView = {
    ...hierarchyView,
    Controller: HrEmployeeHierarchyController,
    Renderer: HrEmployeeHierarchyRenderer,
};

registry.category("views").add("hr_employee_hierarchy", hrEmployeeHierarchyView);

return __exports;
});


                    /*******************************************
                    *  Templates                               *
                    *******************************************/

                    odoo.define("web.assets_backend_lazy.bundle.xml", ["@web/core/templates"], function(require) {
                        "use strict";
                        const { checkPrimaryTemplateParents, registerTemplate, registerTemplateExtension } = require("@web/core/templates");
                        /* web.assets_backend_lazy */
                        registerTemplate("web.GraphView.Buttons", `/web/static/src/views/graph/graph_controller.xml`, `<t t-name="web.GraphView.Buttons" xml:space="preserve">
        <div class="btn-group" role="toolbar" aria-label="Main actions">
            <ReportViewMeasures measures="model.metaData.measures" activeMeasures="[model.metaData.measure]" onMeasureSelected.bind="this.onMeasureSelected"/>
        </div>
        <div class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-bar-chart o_graph_button" data-tooltip="Bar Chart" aria-label="Bar Chart" data-mode="bar" t-on-click="() =&gt; this.onModeSelected('bar')" t-att-class="{ active: model.metaData.mode === 'bar' }"/>
            <button class="btn btn-secondary fa fa-line-chart o_graph_button" data-tooltip="Line Chart" aria-label="Line Chart" data-mode="line" t-on-click="() =&gt; this.onModeSelected('line')" t-att-class="{ active: model.metaData.mode === 'line' }"/>
            <button class="btn btn-secondary fa fa-pie-chart o_graph_button" data-tooltip="Pie Chart" aria-label="Pie Chart" data-mode="pie" t-on-click="() =&gt; this.onModeSelected('pie')" t-att-class="{ active: model.metaData.mode === 'pie' }"/>
        </div>
        <div t-if="model.metaData.mode === 'bar'" class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-database o_graph_button" data-tooltip="Stacked" aria-label="Stacked" t-on-click="toggleStacked" t-att-class="{ active: model.metaData.stacked }"/>
        </div>
        <div t-if="model.metaData.mode === 'line'" class="btn-group" role="toolbar" aria-label="Change graph">
            <button class="btn btn-secondary fa fa-database o_graph_button" data-tooltip="Stacked" aria-label="Stacked" t-on-click="toggleStacked" t-att-class="{ active: model.metaData.stacked }"/>
            <button class="btn btn-secondary fa fa-signal o_graph_button" data-tooltip="Cumulative" aria-label="Cumulative" t-on-click="toggleCumulated" t-att-class="{ active: model.metaData.cumulated }"/>
        </div>
        <div t-if="model.metaData.mode !== 'pie' and model.metaData.domains.length === 1" class="btn-group" role="toolbar" aria-label="Sort graph" name="toggleOrderToolbar">
            <button class="btn btn-secondary fa fa-sort-amount-desc o_graph_button" data-tooltip="Descending" aria-label="Descending" t-on-click="() =&gt; this.toggleOrder('DESC')" t-att-class="{ active: model.metaData.order === 'DESC' }"/>
            <button class="btn btn-secondary fa fa-sort-amount-asc o_graph_button" data-tooltip="Ascending" aria-label="Ascending" t-on-click="() =&gt; this.toggleOrder('ASC')" t-att-class="{ active: model.metaData.order === 'ASC' }"/>
        </div>
    </t>

    `);
registerTemplate("web.GraphView", `/web/static/src/views/graph/graph_controller.xml`, `<t t-name="web.GraphView" xml:space="preserve">
        <div t-att-class="props.className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-if="model.data">
                    <t t-if="!model.hasData() or model.useSampleModel and props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-if="model.data.exceeds">
                        <div class="alert alert-info text-center o_graph_alert" role="status">
                            There are too many data. The graph only shows a sample. Use the filters to refine the scope.
                            <a class="o_graph_load_all_btn" href="#" t-on-click="() =&gt; this.loadAll()">
                                Load everything anyway.
                            </a>
                        </div>
                    </t>
                    <t t-component="props.Renderer" model="model" buttonTemplate="props.buttonTemplate"/>
                </t>
                <t t-else="" t-call="web.NoContentHelper">
                    <t t-set="title">Invalid data</t>
                    <t t-set="description">Pie chart cannot mix positive and negative numbers. Try to change your domain to only display positive results</t>
                </t>
            </Layout>
        </div>
    </t>

`);
registerTemplate("web.GraphRenderer.CustomTooltip", `/web/static/src/views/graph/graph_renderer.xml`, `<t t-name="web.GraphRenderer.CustomTooltip" xml:space="preserve">
        <div class="o_graph_custom_tooltip popover show px-2 py-1 pe-none mw-100 position-absolute">
            <table class="overflow-hidden m-0">
                <thead>
                    <tr>
                        <th class="o_measure align-baseline border-0" t-esc="measure"/>
                    </tr>
                </thead>
                <tbody>
                    <tr t-foreach="tooltipItems" t-as="tooltipItem" t-key="tooltipItem_index">
                        <td>
                            <span class="o_square badge p-2 rounded-0 align-middle me-2" t-attf-style="background-color: {{ tooltipItem.boxColor }}"> </span>
                            <small class="o_label d-inline-block text-truncate align-middle smaller" t-attf-style="max-width: {{ maxWidth }}" t-esc="tooltipItem.label"/>
                        </td>
                        <td class="o_value ps-2 text-end fw-bolder">
                            <small class="smaller">
                                <t t-esc="tooltipItem.value"/>
                                <t t-if="mode === 'pie' and tooltipItem.percentage">
                                    (<t t-esc="tooltipItem.percentage"/>%)
                                </t>
                            </small>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </t>

    `);
registerTemplate("web.GraphRenderer", `/web/static/src/views/graph/graph_renderer.xml`, `<t t-name="web.GraphRenderer" xml:space="preserve">
        <div t-att-class="'o_graph_renderer o_renderer h-100 d-flex flex-column border-top ' + props.class" t-ref="root">
            <div class="d-flex d-print-none gap-1 flex-shrink-0 mt-2 mx-3 mb-3 overflow-x-auto">
                <t t-call="{{ props.buttonTemplate }}"/>
            </div>
            <div t-if="model.hasData()" class="o_graph_canvas_container flex-grow-1 position-relative px-3 pb-3" t-ref="container">
                <canvas t-ref="canvas"/>
            </div>
        </div>
    </t>

`);
registerTemplate("web.PivotView.Buttons", `/web/static/src/views/pivot/pivot_controller.xml`, `<t t-name="web.PivotView.Buttons" xml:space="preserve">
        <div class="o_pivot_buttons d-flex d-print-none gap-1 mt-2 mx-3 mb-3">
            <div class="btn-group" role="toolbar" aria-label="Main actions">
                <ReportViewMeasures measures="model.metaData.measures" activeMeasures="model.metaData.activeMeasures" onMeasureSelected.bind="this.onMeasureSelected"/>
            </div>
            <div class="btn-group" role="toolbar" aria-label="Pivot settings">
                <t t-set="noDataDisplayed" t-value="!model.hasData() || !model.metaData.activeMeasures.length"/>
                <button class="btn btn-secondary fa fa-exchange o_pivot_flip_button" t-on-click="onFlipButtonClicked" data-tooltip="Flip axis" aria-label="Flip axis" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
                <button class="btn btn-secondary fa fa-arrows o_pivot_expand_button" t-on-click="onExpandButtonClicked" data-tooltip="Expand all" aria-label="Expand all" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
                <button class="btn btn-secondary fa fa-download o_pivot_download" t-on-click="onDownloadButtonClicked" data-tooltip="Download xlsx" aria-label="Download xlsx" t-attf-disabled="{{noDataDisplayed ? 'disabled' : false}}"/>
            </div>
        </div>
    </t>

    `);
registerTemplate("web.PivotView", `/web/static/src/views/pivot/pivot_controller.xml`, `<t t-name="web.PivotView" xml:space="preserve">
        <div t-att-class="props.className" t-ref="root">
            <Layout className="model.useSampleModel ? 'o_view_sample_data' : ''" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-set="displayNoContent" t-value="                     props.info.noContentHelp !== false and (                         !(model.hasData() and model.metaData.activeMeasures.length) or                         model.useSampleModel                     )"/>
                <t t-if="displayNoContent">
                    <t t-if="props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-else="" t-call="web.NoContentHelper"/>
                </t>
                <t t-component="props.Renderer" model="model" buttonTemplate="props.buttonTemplate"/>
            </Layout>
        </div>
    </t>

`);
registerTemplate("web.PivotHeader", `/web/static/src/views/pivot/pivot_header.xml`, `<t t-name="web.PivotHeader" xml:space="preserve">
        <Dropdown state="this.dropdownState" manual="true" position="props.isXAxis ? 'bottom-start' : 'bottom-end'">
            <th class="bg-view text-nowrap cursor-pointer fw-normal user-select-none" t-att-colspan="props.isXAxis ? cell.width : undefined" t-att-rowspan="props.isXAxis ? cell.height : undefined" t-att-class="{                     o_pivot_header_cell_closed: cell.isLeaf,                     o_pivot_header_cell_opened: !cell.isLeaf,                     'border-top': props.isInHead,                 }" t-attf-style="{{                     props.isXAxis                         ? undefined                         : l10n.direction === 'ltr'                             ? 'padding-left: ' + padding + 'px;'                             : 'padding-right: ' + padding + 'px;'                 }}" t-att-data-tooltip="cell.label" t-attf-data-tooltip-position="{{ l10n.direction === 'ltr' ? 'right' : 'left' }}" t-on-click.stop="this.onClick">
                <i t-attf-class="fa fa-{{ cell.isLeaf ? 'plus-square' : 'minus-square-o' }} me-1"/>
                <span t-esc="cell.title"/>
            </th>

            <t t-set-slot="content">
                <t t-set="currentGroup" t-value="null"/>
                <t t-foreach="items" t-as="item" t-key="item.id">
                    <t t-if="currentGroup !== null and currentGroup !== item.groupNumber">
                        <div class="dropdown-divider" role="separator"/>
                    </t>
                    <t t-if="item.fieldType === 'properties'">
                        <PropertiesGroupByItem item="item" onGroup.bind="onGroupBySelected"/>
                    </t>
                    <t t-elif="item.options">
                        <Dropdown>
                            <button t-att-class="'o_menu_item' + (item.isActive ? ' selected' : '')">
                                <t t-esc="item.description"/>
                            </button>
                            <t t-set-slot="content">
                                <t t-set="subGroup" t-value="null"/>
                                <t t-foreach="item.options" t-as="option" t-key="option.id">
                                    <t t-if="subGroup !== null and subGroup !== option.groupNumber">
                                        <div class="dropdown-divider" role="separator"/>
                                    </t>
                                    <CheckboxItem class="{ o_item_option: true, selected: option.isActive }" checked="option.isActive ? true : false" t-esc="option.description" onSelected="() =&gt; this.onGroupBySelected({ itemId: item.id, optionId: option.id})"/>
                                    <t t-set="subGroup" t-value="option.groupNumber"/>
                                </t>
                            </t>
                        </Dropdown>
                    </t>
                    <t t-else="">
                        <CheckboxItem class="{ o_menu_item: true, selected: item.isActive }" checked="item.isActive" t-esc="item.description" onSelected="() =&gt; this.onGroupBySelected({ itemId: item.id })"/>
                    </t>
                    <t t-set="currentGroup" t-value="item.groupNumber"/>
                </t>
                <t t-if="!hideCustomGroupBy and fields.length">
                    <div t-if="items.length" role="separator" class="dropdown-divider"/>
                    <CustomGroupByItem fields="fields" onAddCustomGroup.bind="onAddCustomGroup"/>
                </t>
            </t>
        </Dropdown>
    </t>

`);
registerTemplate("web.PivotRenderer", `/web/static/src/views/pivot/pivot_renderer.xml`, `<t t-name="web.PivotRenderer" xml:space="preserve">
        <t t-call="{{ props.buttonTemplate }}"/>
        <div t-if="model.hasData() and model.metaData.activeMeasures.length" t-att-class="env.isSmall ? 'table-responsive' : ''" class="o_pivot mx-3">
            <table class="table-hover table table-sm table-bordered table-borderless" t-att-class="{ o_enable_linking: !model.metaData.disableLinking }" t-ref="table">
                <thead>
                    <tr t-foreach="table.headers" t-as="row" t-key="'header_' + row_index" class="border-top-0">
                        <t t-foreach="row" t-as="cell" t-key="'header_row_' + cell_index">
                            <t t-if="cell.measure" t-call="web.PivotMeasure"/>
                            <PivotHeader t-elif="cell.isLeaf !== undefined" t-props="this.getHeaderProps({ cell: cell, isXAxis: true, isInHead: true })"/>
                            <th t-else="" t-att-colspan="cell.width" t-att-rowspan="cell.height" class="border-0 bg-100 fw-normal" t-att-class="{ 'border-0': cell_index != 0 }"/>
                        </t>
                    </tr>
                </thead>
                <tbody>
                    <tr t-foreach="table.rows" t-as="row" t-key="'row_' + row_index">
                        <PivotHeader t-props="this.getHeaderProps({ cell: row, isXAxis: false, isInHead: false })"/>
                        <t t-foreach="row.subGroupMeasurements" t-as="cell" t-key="'row_cell_' + cell_index">
                            <td class="o_pivot_cell_value bg-100" t-att-class="{                                     o_empty: cell.value === undefined,                                     'cursor-pointer': cell.value !== undefined,                                     'fw-bold': cell.isBold,                                 }" t-on-click="() =&gt; this.onOpenView(cell)" t-on-mouseover="onMouseEnter" t-on-mouseout="onMouseLeave">
                                <t t-if="cell.value !== undefined">
                                    <div t-if="cell.originIndexes.length &gt; 1" class="o_variation" t-att-class="{                                              'o_positive text-success': cell.value &gt; 0,                                              'o_negative text-danger': cell.value &lt; 0,                                              o_null: cell.value === 0,                                         }" t-esc="getFormattedVariation(cell)"/>
                                    <div t-elif="model.metaData.measures[cell.measure].type === 'boolean'" class="o_value">
                                        <CheckBox disabled="true" value="cell.value"/>
                                    </div>
                                    <div t-else="1" class="o_value" t-esc="getFormattedValue(cell)"/>
                                </t>
                            </td>
                        </t>
                    </tr>
                </tbody>
            </table>
        </div>
    </t>

    `);
registerTemplate("web.PivotMeasure", `/web/static/src/views/pivot/pivot_renderer.xml`, `<t t-name="web.PivotMeasure" xml:space="preserve">
        <th class="bg-view text-muted text-center text-nowrap fw-normal" t-att-colspan="cell.width" t-att-rowspan="cell.height" t-att-class="{                 'o_pivot_origin_row cursor-pointer user-select-none': cell.originIndexes,                 'o_pivot_measure_row cursor-pointer user-select-none': !cell.originIndexes,                 o_pivot_sort_order_asc: cell.order === 'asc',                 o_pivot_sort_order_desc: cell.order === 'desc',             }" t-on-click.prevent="() =&gt; this.onMeasureClick(cell)" t-on-mouseover="onMouseEnter" t-on-mouseout="onMouseLeave">
            <t t-esc="cell.title"/>
            <i t-if="cell.order === 'asc' || cell.order ==='desc'" t-attf-class="fa fa-caret-{{ cell.order === 'asc' ? 'up' : 'down' }} ms-1"/>
        </th>
    </t>

`);
registerTemplate("mail.ActivityCell", `/mail/static/src/views/web/activity/activity_cell.xml`, `<t t-name="mail.ActivityCell" xml:space="preserve">
        <div class="h-100 cursor-pointer p-1 d-flex flex-column justify-content-between" t-on-click="onClick">
            <div class="d-flex align-items-center justify-content-center position-relative" t-ref="content">
                <div class="o-mail-ActivityCell-deadline" t-out="reportingDateFormatted"/>
            </div>
            <div class="d-flex justify-content-between">
                <div t-if="props.userAssignedIds" class="d-flex justify-content-start">
                    <Avatar t-if="props.userAssignedIds.length &gt; 0" resModel="'res.users'" resId="props.userAssignedIds[0]" displayName="''" noSpacing="true"/>
                    <Avatar t-if="props.userAssignedIds.length &gt; 1" resModel="'res.users'" resId="props.userAssignedIds[1]" displayName="''" noSpacing="true"/>
                    <t t-set="nAdditionalAssignee" t-value="props.userAssignedIds.length - 2"/>
                    <span t-if="nAdditionalAssignee &gt; 0">+<t t-out="nAdditionalAssignee"/></span>
                </div>
                <div t-else=""/>
                <div t-if="props.attachmentsInfo and ongoingActivityCount == 0" class="d-flex w-100 justify-content-center gap-1 px-2">
                    <a t-attf-href="/web/content/#{props.attachmentsInfo.most_recent_id}?download=true" t-on-click.stop="" t-out="props.attachmentsInfo.most_recent_name" class="d-inline-block text-truncate" style="max-width: 120px;"/>
                    <div t-if="props.attachmentsInfo.count &gt; 1" class="text-nowrap">
                        +<t t-out="props.attachmentsInfo.count - 1"/>
                    </div>
                </div>
                <div t-if="totalActivityCount &gt; 1" class="o-mail-ActivityCell-counter badge bg-light rounded-pill border-0 m-1">
                    <t t-if="totalActivityCount == ongoingActivityCount or ongoingActivityCount == 0" t-out="totalActivityCount"/>
                    <t t-else="">
                        <t t-out="ongoingActivityCount"/> / <t t-out="totalActivityCount"/>
                    </t>
                </div>
                <div t-else=""/>
            </div>
        </div>
    </t>

`);
registerTemplate("mail.ActivityController", `/mail/static/src/views/web/activity/activity_controller.xml`, `<t t-name="mail.ActivityController" xml:space="preserve">
        <div t-att-class="props.className + (ui.isSmall ? ' o_action_delegate_scroll': '')">
            <Layout display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar/>
                </t>
                <t t-component="props.Renderer" t-props="rendererProps"/>
            </Layout>
        </div>
    </t>
`);
registerTemplate("mail.ActivityRecord", `/mail/static/src/views/web/activity/activity_record.xml`, `<t t-name="mail.ActivityRecord" xml:space="preserve">
    <td class="o_activity_record p-2 cursor-pointer" t-on-click="() =&gt; this.props.openRecord(this.props.record)">
        <t t-call="{{ recordTemplate }}" t-call-context="this.getRenderingContext()"/>
    </td>
</t>

`);
registerTemplate("mail.ActivityViewHeader", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewHeader" xml:space="preserve">
    <thead>
        <tr>
            <th/>
            <th t-foreach="activeColumns" t-as="type" t-key="type.id" class="o_activity_type_cell p-3" t-attf-class="{{ activeFilter.activityTypeId === type.id ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}" t-attf-width="{{100/activeColumns.length}}%">
                <div>
                    <span t-esc="type.name"/>
                    <span t-if="type.template_ids.length &gt; 0" class="dropdown float-end">
                        <i class="fa fa-ellipsis-v fa-fw" data-bs-toggle="dropdown"/>
                        <div class="dropdown-menu">
                            <t t-foreach="type.template_ids" t-as="template" t-key="template.id">
                                <div data-tooltip="This action will send an email." class="o_template_element o_send_mail_template cursor-pointer" t-on-click="() =&gt; props.onSendMailTemplate(template.id, type.id)">
                                    <i class="fa fa-envelope fa-fw"/> <t t-esc="template.name"/>
                                </div>
                            </t>
                        </div>
                    </span>
                </div>
                <div class="o_activity_counter d-flex align-items-center justify-content-between mb-3 h-0 mt24">
                    <t t-set="group" t-value="getGroupInfo(type)"/>
                    <ColumnProgress t-if="group.data.count" group="group.data" aggregate="group.aggregate" aggregateOn="group.aggregateOn" progressBar="group.data.progressBar" onBarClicked.bind="group.data.filterProgressValue"/>
                </div>
            </th>
            <th class="align-middle" style="width: 32px; min-width: 32px">
                <div class="o_optional_columns_dropdown text-center border-top-0">
                    <Dropdown position="'bottom-end'">
                        <button class="btn p-0" tabindex="-1">
                            <i class="o_optional_columns_dropdown_toggle oi oi-fw oi-settings-adjust"/>
                        </button>

                        <t t-set-slot="content">
                            <t t-foreach="props.activityTypes" t-as="type" t-key="type_index">
                                <DropdownItem closingMode="'none'" onSelected="() =&gt; this.toggleDisplayColumn(type.id)">
                                    <CheckBox onChange="() =&gt; this.toggleDisplayColumn(type.id)" value="storageActiveColumns[type.id]" name="type.name">
                                        <t t-esc="type.name"/>
                                    </CheckBox>
                                </DropdownItem>
                            </t>
                        </t>
                    </Dropdown>
                </div>
            </th>
        </tr>
    </thead>
</t>

`);
registerTemplate("mail.ActivityViewBody", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewBody" xml:space="preserve">
    <tbody>
        <t t-foreach="props.activityResIds" t-as="resId" t-key="resId">
            <t t-call="mail.ActivityViewRow"/>
        </t>
    </tbody>
</t>

`);
registerTemplate("mail.ActivityViewRow", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewRow" xml:space="preserve">
    <t t-set="record" t-value="getRecord(resId)"/>
    <t t-if="record">
        <tr class="o_data_row h-100" t-attf-class="{{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}">
                <ActivityRecord archInfo="props.archInfo" record="record" openRecord="props.openRecord"/>
                <t t-foreach="activeColumns" t-as="type" t-key="type.id">
                    <t t-call="mail.ActivityViewCell"/>
                </t>
            <td/>
        </tr>
    </t>
</t>

`);
registerTemplate("mail.ActivityViewCell", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewCell" xml:space="preserve">
    <t t-set="activityGroup" t-value="props.groupedActivities[resId] and props.groupedActivities[resId][type.id] or {count: 0, ids: [], state: false}"/>
    <t t-set="isCellHidden" t-value="!activeFilter.resIds.has(resId) and activeFilter.activityTypeId === type.id"/>
    <td t-if="activityGroup.state and !isCellHidden" t-attf-class="o_activity_summary_cell p-0 h-100 {{activityGroup.state}} {{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}">
        <ActivityCell activityIds="activityGroup.ids" activityTypeId="type.id" attachmentsInfo="activityGroup.attachments_info" reportingDate="activityGroup.reporting_date" countByState="activityGroup.count_by_state" reloadFunc="props.onReloadData" resId="record.resId" resModel="record.resModel" userAssignedIds="activityGroup.user_assigned_ids"/>
    </td>
    <td t-else="" class="o_activity_summary_cell o_activity_empty_cell cursor-pointer" t-attf-class="{{ activeFilter.resIds.has(resId) ? 'o_activity_filter_' + activeFilter.progressValue.active : '' }}" t-on-click.prevent.stop="() =&gt; props.onEmptyCell(resId, type.id)">
        <i data-tooltip="Create" class="text-center fa fa-plus mt-2 align-items-center justify-content-center h-100"/>
    </td>
</t>

`);
registerTemplate("mail.ActivityViewFooter", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<t t-name="mail.ActivityViewFooter" xml:space="preserve">
    <tfoot>
        <tr class="o_data_row">
            <td class="p-3" colspan="3">
                <span class="btn btn-link o_record_selector cursor-pointer" t-on-click.prevent.stop="props.scheduleActivity">
                    <i class="fa fa-plus pe-2"/> Schedule activity
                </span>
            </td>
        </tr>
    </tfoot>
</t>

`);
registerTemplate("mail.ActivityRenderer", `/mail/static/src/views/web/activity/activity_renderer.xml`, `<div t-name="mail.ActivityRenderer" class="o_activity_view h-100" xml:space="preserve">
    <t t-if="!props.activityTypes.length" t-call="web.NoContentHelper"/>
    <table t-else="" class="table table-bordered mb-5 bg-view o_activity_view_table">
        <t t-call="mail.ActivityViewHeader"/>
        <t t-call="mail.ActivityViewBody"/>
        <t t-call="mail.ActivityViewFooter"/>
    </table>
</div>

`);
registerTemplate("project.BurndownChartView.Buttons", `/project/static/src/views/burndown_chart/burndown_chart_view.xml`, `<t t-name="project.BurndownChartView.Buttons" t-inherit="web.GraphView.Buttons" t-inherit-mode="primary" xml:space="preserve">
        <xpath expr="//button[@data-mode='pie']" position="replace">
        </xpath>
        <xpath expr="//div[@role='toolbar'][@name='toggleOrderToolbar']" position="replace">
        </xpath>
    </t>

`);
registerTemplate("hr.GraphView", `/hr/static/src/views/hr_graph_controller.xml`, `<t t-name="hr.GraphView" t-inherit="web.GraphView" xml:space="preserve">
        <t t-call="web.ActionHelper" position="replace">
            <t t-if="!model.hasData() or model.useSampleModel and props.info.noContentHelp">
                <HrActionHelper noContentTitle.translate="No Data" noContentParagraph.translate="This report gives you an overview of your employees based on the measures of your choice."/>
            </t>
        </t>
    </t>
`);
registerTemplate("hr.PivotView", `/hr/static/src/views/hr_pivot_controller.xml`, `<t t-name="hr.PivotView" t-inherit="web.PivotView" xml:space="preserve">
        <t t-call="web.ActionHelper" position="replace">
            <t t-if="!model.hasData() or model.useSampleModel and props.info.noContentHelp">
                <HrActionHelper noContentTitle.translate="No Data" noContentParagraph.translate="This report gives you an overview of your employees based on the measures of your choice."/>
            </t>
        </t>
    </t>
`);
registerTemplate("web_hierarchy.HierarchyCard", `/web_hierarchy/static/src/hierarchy_card.xml`, `<t t-name="web_hierarchy.HierarchyCard" xml:space="preserve">
        <div class="o_hierarchy_node_container mb-4 d-flex flex-column" t-att-class="classNames" t-att-data-node-id="props.node.id">
            <div class="o_hierarchy_node_button_container w-100 d-flex justify-content-end">
                <button t-if="props.node.parentResId !== false and !props.node.parentNode and props.node.parentResId !== props.node.resId" name="hierarchy_search_parent_node" class="btn p-0" t-on-click.synthetic="onClickArrowUp">
                    <i class="fa fa-chevron-up"/>
                </button>
            </div>
            <div class="o_hierarchy_node w-100 h-100 d-flex flex-column justify-content-between border" t-att-class="{                     'border-bottom-0': props.node.nodes.length or props.node.canShowChildNodes,                 }" t-att-data-node-id="props.node.id" t-on-click.synthetic="onGlobalClick">
                <div class="o_hierarchy_node_content">
                    <Record resModel="props.node.model.resModel" resId="props.node.resId" fields="props.node.model.fields" activeFields="props.node.model.activeFields" values="props.node.data" t-slot-scope="data">
                        <t t-call="{{ templates['hierarchy-box'] }}" t-call-context="getRenderingContext(data)"/>
                    </Record>
                </div>
                <button t-if="props.node.nodes.length or props.node.canShowChildNodes" name="hierarchy_search_subsidiaries" class="o_hierarchy_node_button btn rounded-0 d-grid" t-att-class="{                             'btn-primary': !props.node.nodes.length,                             'btn-secondary': props.node.nodes.length &gt; 0,                         }" t-on-click.synthetic="onClickArrowDown">
                    <t t-if="!props.node.nodes.length">
                        <span style="grid-column: 2;">
                            Unfold
                        </span>
                        <span class="text-end" style="grid-column: 3;">
                            <t t-out="props.node.childResIds.length"/>
                            <i class="fa ps-1" t-att-class="props.archInfo.icon"/>
                        </span>
                    </t>
                    <t t-else="">
                        <span style="grid-column: 2;">
                            Fold
                        </span>
                    </t>
                </button>
            </div>
        </div>
    </t>

`);
registerTemplate("web_hierarchy.HierarchyButtons", `/web_hierarchy/static/src/hierarchy_controller.xml`, `<t t-name="web_hierarchy.HierarchyButtons" xml:space="preserve">
        <div class="d-flex o_grid_buttons">
            <div class="me-2" t-if="props.archInfo.activeActions.create and (!props.archInfo.createInline or displayNoContent)">
                <button class="btn btn-primary o_hierarchy_button_add" type="button" t-on-click="props.createRecord">
                    New
                </button>
            </div>
        </div>
    </t>
    `);
registerTemplate("web_hierarchy.HierarchyView", `/web_hierarchy/static/src/hierarchy_controller.xml`, `<t t-name="web_hierarchy.HierarchyView" xml:space="preserve">
        <div t-attf-class="o_hierarchy_view {{ isMobile ? 'o_action_delegate_scroll' : '' }} {{ props.className }}" t-ref="root">
            <Layout className="(model.useSampleModel ? 'o_view_sample_data' : '') + ' d-flex'" display="props.display">
                <t t-set-slot="control-panel-additional-actions">
                    <CogMenu/>
                </t>
                <t t-set-slot="layout-buttons">
                    <t t-call="{{ props.buttonTemplate }}"/>
                </t>
                <t t-set-slot="layout-actions">
                    <SearchBar toggler="searchBarToggler"/>
                </t>
                <t t-set-slot="control-panel-navigation-additional">
                    <t t-component="searchBarToggler.component" t-props="searchBarToggler.props"/>
                </t>
                <t t-set-slot="default" t-slot-scope="layout">
                <t t-if="displayNoContent">
                    <t t-if="props.info.noContentHelp" t-call="web.ActionHelper">
                        <t t-set="noContentHelp" t-value="props.info.noContentHelp"/>
                    </t>
                    <t t-else="" t-call="web.NoContentHelper"/>
                </t>
                    <t t-component="props.Renderer" model="model" openRecord.bind="openRecord" archInfo="props.archInfo" templates="props.archInfo.templateDocs"/>
                </t>
            </Layout>
        </div>
    </t>
`);
registerTemplate("web_hierarchy.HierarchyRenderer", `/web_hierarchy/static/src/hierarchy_renderer.xml`, `<t t-name="web_hierarchy.HierarchyRenderer" xml:space="preserve">
        <div class="o_hierarchy_renderer w-100 d-flex justify-content-center" t-ref="renderer">
            <div class="o_hierarchy_container d-flex flex-column w-100 w-lg-75 h-100 pt-5 px-2">
                <t t-foreach="rows" t-as="row" t-key="row_index">
                    <t t-set="previousRow" t-value="!row_first ? rows[row_index - 1] : null"/>
                    <t t-if="!row_first">
                        <div t-if="row.parentNode and previousRow.nodes.length &gt; 1" class="o_hierarchy_parent_node_container d-flex justify-content-center">
                            <span t-esc="row.parentNode.data.display_name || row.parentNode.data.name"/>
                        </div>
                        <div class="o_hierarchy_separator d-flex pb-4">
                            <div class="o_hierarchy_line_part o_hierarchy_line_left"/>
                            <div class="o_hierarchy_line_part o_hierarchy_line_right"/>
                        </div>
                    </t>
                    <div class="o_hierarchy_row row justify-content-center flex-wrap row-cols-2 row-cols-lg-5 g-2 g-lg-3 pt-3" t-att-class="{ 'pb-4': row_last }" t-att-data-parent-node-id="row.parentNode?.id" t-att-data-row-id="row_index">
                        <t t-foreach="row.nodes" t-as="node" t-key="node.id">
                            <HierarchyCard node="node" openRecord="props.openRecord" archInfo="props.archInfo" templates="props.templates"/>
                        </t>
                    </div>
                </t>
            </div>
        </div>
    </t>

`);
registerTemplate("hr_org_chart.HrEmployeeHierarchyCard", `/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_card.xml`, `<t t-name="hr_org_chart.HrEmployeeHierarchyCard" t-inherit="web_hierarchy.HierarchyCard" xml:space="preserve">
        <xpath expr="//button[@name='hierarchy_search_subsidiaries']" position="attributes">
            <attribute name="class" separator=" " remove="d-grid"/>
            <attribute name="class" separator=" " remove="rounded-0"/>
        </xpath>
        <xpath expr="//button[@name='hierarchy_search_subsidiaries']" position="inside">
            <t t-out="props.node.childResIds.length"/> people
        </xpath>
        <xpath expr="//button[@name='hierarchy_search_subsidiaries']/t[@t-if]" position="replace">
            <t t-if="!props.node.nodes.length">
                <i class="fa fa-fw fa-caret-right"/>
            </t>
        </xpath>
        <xpath expr="//button[@name='hierarchy_search_subsidiaries']/t[@t-else]" position="replace">
            <t t-else="">
                <i class="fa fa-fw fa-caret-down"/>
            </t>
        </xpath>
    </t>

`);
registerTemplate("hr_org_chart.HierarchyView", `/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_controller.xml`, `<t t-name="hr_org_chart.HierarchyView" t-inherit="web_hierarchy.HierarchyView" t-inherit-mode="primary" xml:space="preserve">
        <t t-call="web.ActionHelper" position="replace">
            <t t-if="props.info.noContentHelp">
                <HrActionHelper noContentTitle.translate="No Data" noContentParagraph.translate="In the Organigram you will have a clear overview of the hierarchy of employees."/>
            </t>
        </t>
    </t>
`);
registerTemplate("hr_org_chart.HrEmployeeHierarchyRenderer", `/hr_org_chart/static/src/views/hr_employee_hierarchy/hr_employee_hierarchy_renderer.xml`, `<t t-name="hr_org_chart.HrEmployeeHierarchyRenderer" t-inherit="web_hierarchy.HierarchyRenderer" xml:space="preserve">
        <xpath expr="//div[hasclass('o_hierarchy_parent_node_container')]/span" position="replace">
            <Avatar resModel="row.parentNode.model.resModel" resId="row.parentNode.resId" displayName="row.parentNode.data.display_name || row.parentNode.data.name"/>
        </xpath>
    </t>

`);
                    });


//# sourceMappingURL=/web/assets/52b3a2f/web.assets_backend_lazy.js.map